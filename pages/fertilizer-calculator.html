---
layout: default
title: Fertilizer PPM Calculator
permalink: /fertilizer-calculator/
---

<style>
  .calculator-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }

  .input-section {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 20px;
  }

  .volume-input {
    margin-bottom: 20px;
  }

  .volume-input label {
    display: block;
    font-weight: bold;
    margin-bottom: 5px;
  }

  .volume-input input {
    padding: 8px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 200px;
  }

  .volume-control-row {
    display: flex;
    align-items: flex-end;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  .volume-field {
    display: flex;
    flex-direction: column;
  }

  .button-group {
    display: flex;
    gap: 10px;
  }

  .btn {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    white-space: nowrap;
  }

  .btn-primary {
    background: #007bff;
    color: white;
  }

  .btn-primary:hover {
    background: #0056b3;
  }

  .btn-danger {
    background: #dc3545;
    color: white;
  }

  .btn-danger:hover {
    background: #c82333;
  }

  .input-error {
    border-color: #dc3545 !important;
    background-color: #fff5f5 !important;
  }

  /* Progress bar styles */
  .progress-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 9999;
    justify-content: center;
    align-items: center;
  }

  .progress-overlay.active {
    display: flex;
  }

  .progress-container {
    background: white;
    padding: 30px 40px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    text-align: center;
    min-width: 300px;
    max-width: 400px;
  }

  .progress-container h3 {
    margin: 0 0 20px 0;
    color: #333;
    font-size: 18px;
  }

  .progress-bar-wrapper {
    background: #e9ecef;
    border-radius: 10px;
    height: 20px;
    overflow: hidden;
    margin-bottom: 15px;
  }

  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #28a745, #20c997);
    border-radius: 10px;
    width: 0%;
    transition: width 0.3s ease;
  }

  .progress-bar.indeterminate {
    width: 30%;
    animation: indeterminate 1.5s infinite ease-in-out;
  }

  @keyframes indeterminate {
    0% {
      transform: translateX(-100%);
    }
    50% {
      transform: translateX(200%);
    }
    100% {
      transform: translateX(-100%);
    }
  }

  .progress-text {
    color: #666;
    font-size: 14px;
    margin: 0;
  }

  .fertilizer-selector {
    margin-bottom: 20px;
  }

  .fertilizer-selector h3 {
    margin-bottom: 10px;
  }

  .fertilizer-item {
    background: white;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .fertilizer-item.active {
    border-color: #007bff;
    background: #f0f8ff;
  }

  .fertilizer-checkbox {
    flex-shrink: 0;
  }

  .fertilizer-info {
    flex-grow: 1;
  }

  .fertilizer-name {
    font-weight: bold;
    margin-bottom: 5px;
  }

  .fertilizer-composition {
    font-size: 0.9em;
    color: #666;
  }

  .fertilizer-input {
    flex-shrink: 0;
  }

  .fertilizer-input input {
    padding: 6px;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 100px;
  }

  .fertilizer-input label {
    display: inline-block;
    margin-left: 5px;
    font-size: 0.9em;
  }

  .results-section {
    background: white;
    padding: 20px;
    border-radius: 8px;
    border: 2px solid #007bff;
  }

  .results-section h2 {
    margin-top: 0;
    color: #007bff;
  }

  .results-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 20px;
  }

  .result-card {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 4px;
    border-left: 4px solid #28a745;
  }

  .result-card.zero {
    opacity: 0.5;
    border-left-color: #ccc;
  }

  .result-label {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 5px;
  }

  .result-value {
    font-size: 1.5em;
    font-weight: bold;
    color: #333;
  }

  .result-unit {
    font-size: 0.8em;
    color: #666;
    margin-left: 4px;
  }

  .search-box {
    margin-bottom: 15px;
  }

  .search-box input {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .conversion-note {
    background: #fff3cd;
    padding: 10px;
    border-radius: 4px;
    margin-top: 15px;
    font-size: 0.9em;
    color: #856404;
  }

  .tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    border-bottom: 2px solid #dee2e6;
  }

  .tab {
    padding: 12px 24px;
    background: transparent;
    border: none;
    border-bottom: 3px solid transparent;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
    color: #6c757d;
    transition: all 0.3s;
  }

  .tab:hover {
    color: #007bff;
    background: #f8f9fa;
  }

  .tab.active {
    color: #007bff;
    border-bottom-color: #007bff;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  .target-input-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
  }

  .target-input-field {
    display: flex;
    flex-direction: column;
  }

  .target-input-field label {
    font-weight: bold;
    margin-bottom: 5px;
    font-size: 0.9em;
  }

  .target-input-field input {
    padding: 8px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .formula-result {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 4px;
    margin-bottom: 15px;
  }

  .formula-fertilizer {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 10px;
    background: white;
    margin-bottom: 8px;
    border-radius: 4px;
    border-left: 4px solid #28a745;
    flex-wrap: wrap;
    gap: 5px;
  }

  .formula-fertilizer-info {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
  }

  .formula-fertilizer-name {
    font-weight: bold;
    color: #333;
  }

  .formula-fertilizer-composition {
    font-size: 0.85em;
    color: #666;
    margin-top: 2px;
  }

  .formula-fertilizer-amount {
    font-weight: bold;
    white-space: nowrap;
    text-align: right;
  }

  .ion-balance-summary {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }

  .ion-balance-card {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 4px;
    text-align: center;
  }

  .ion-balance-card.status {
    border: 2px solid;
  }

  .ion-balance-breakdown {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
  }

  .ion-list-item {
    display: flex;
    justify-content: space-between;
    padding: 8px;
    background: #f8f9fa;
    margin-bottom: 5px;
    border-radius: 4px;
  }

  .nutrient-ratio-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 15px;
    margin-top: 10px;
  }

  .nutrient-ratio-card {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 4px;
    border-left: 4px solid #007bff;
  }

  .comparison-table-wrapper {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    margin-top: 15px;
  }

  .comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 0;
  }

  .comparison-table th,
  .comparison-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
  }

  .comparison-table th {
    background: #f8f9fa;
    font-weight: bold;
  }

  .comparison-table .match {
    color: #28a745;
    font-weight: bold;
  }

  .comparison-table .close {
    color: #ffc107;
    font-weight: bold;
  }

  .comparison-table .miss {
    color: #dc3545;
    font-weight: bold;
  }

  .warning-box {
    background: #fff3cd;
    border-left: 4px solid #ffc107;
    padding: 15px;
    border-radius: 4px;
    margin-top: 15px;
  }

  .error-box {
    background: #f8d7da;
    border-left: 4px solid #dc3545;
    padding: 15px;
    border-radius: 4px;
    margin-top: 15px;
  }

  .fertilizer-selection {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 4px;
    margin-bottom: 20px;
  }

  .fertilizer-selection h4 {
    margin-top: 0;
    margin-bottom: 10px;
  }

  .fertilizer-search {
    margin-bottom: 10px;
  }

  .fertilizer-search input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    box-sizing: border-box;
  }

  .fertilizer-search input:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
  }

  .fertilizer-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 8px;
    max-height: 300px;
    overflow-y: auto;
    padding: 10px;
    background: white;
    border-radius: 4px;
  }

  .fertilizer-checkbox-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 5px;
  }

  .fertilizer-checkbox-item input[type="checkbox"] {
    cursor: pointer;
    margin-top: 3px;
  }

  .fertilizer-checkbox-item label {
    cursor: pointer;
    font-size: 0.9em;
    margin: 0;
    display: flex;
    flex-direction: column;
  }

  .fertilizer-label-name {
    font-weight: bold;
  }

  .fertilizer-label-aliases {
    font-size: 0.85em;
    color: #666;
    margin-top: 2px;
  }

  .selection-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }

  .selection-controls button {
    padding: 5px 10px;
    font-size: 0.85em;
    background: #6c757d;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .selection-controls button:hover {
    background: #5a6268;
  }

  .selected-fertilizer-item {
    background: #f8f9fa;
    padding: 12px 15px;
    border-radius: 4px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    border-left: 4px solid #007bff;
    flex-wrap: wrap;
    gap: 5px;
  }

  .selected-fertilizer-info {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
  }

  .selected-fertilizer-name {
    font-weight: bold;
    color: #333;
  }

  .selected-fertilizer-composition {
    font-size: 0.85em;
    color: #666;
    margin-top: 2px;
  }

  .selected-fertilizer-amount {
    color: #007bff;
    font-weight: bold;
    font-size: 1.1em;
    white-space: nowrap;
  }

  /* Mobile Responsive Styles */
  @media (max-width: 768px) {
    .calculator-container {
      padding: 10px;
    }

    h1 {
      font-size: 1.5em;
    }

    h2 {
      font-size: 1.3em;
    }

    h3 {
      font-size: 1.1em;
    }

    .input-section {
      padding: 15px;
    }

    .volume-control-row {
      flex-direction: column;
      align-items: stretch;
    }

    .volume-field {
      width: 100%;
    }

    .volume-field input {
      width: 100%;
    }

    .button-group {
      width: 100%;
      flex-direction: column;
    }

    .btn {
      width: 100%;
      padding: 12px;
      font-size: 14px;
    }

    .fertilizer-item {
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
      padding: 12px;
    }

    .fertilizer-info {
      width: 100%;
    }

    .fertilizer-input {
      width: 100%;
    }

    .fertilizer-input input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
    }

    .search-box input {
      width: 100%;
      font-size: 16px;
      padding: 10px;
    }

    .results-section {
      padding: 15px;
    }

    .results-grid {
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .result-card {
      padding: 12px;
    }

    .result-value {
      font-size: 1.3em;
    }

    .tabs {
      flex-direction: column;
    }

    .tab {
      width: 100%;
      text-align: center;
    }

    .comparison-table {
      font-size: 14px;
    }

    .comparison-table th,
    .comparison-table td {
      padding: 8px 4px;
      font-size: 12px;
    }

    .comparison-table th:first-child,
    .comparison-table td:first-child {
      position: sticky;
      left: 0;
      background: white;
      z-index: 1;
    }

    .comparison-table th:first-child {
      background: #f8f9fa;
    }

    .ion-balance-summary {
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .ion-balance-card {
      padding: 12px;
    }

    .ion-balance-breakdown {
      grid-template-columns: 1fr;
      gap: 15px;
    }

    .ion-list-item {
      flex-direction: column;
      gap: 5px;
      text-align: left;
    }

    .nutrient-ratio-grid {
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .nutrient-ratio-card {
      padding: 12px;
    }

    .selected-fertilizer-item {
      padding: 10px;
      font-size: 0.9em;
    }

    .selected-fertilizer-amount {
      font-size: 1em;
    }

    .selected-fertilizer-composition,
    .formula-fertilizer-composition {
      font-size: 0.8em;
      word-break: break-word;
    }

    .formula-fertilizer {
      padding: 8px;
    }

    /* Formula Builder Mobile Styles */
    .target-inputs {
      grid-template-columns: 1fr !important;
    }

    .target-input-group {
      width: 100%;
    }

    .target-input-group input {
      width: 100%;
      font-size: 16px;
      padding: 10px;
    }

    .fertilizer-selection-grid {
      grid-template-columns: 1fr !important;
    }

    .available-fert-item {
      padding: 10px;
    }

    /* Ratio and Balance Tables */
    .ratio-table, .balance-table {
      font-size: 0.85em;
      overflow-x: auto;
      display: block;
    }

    .ratio-table td, .ratio-table th,
    .balance-table td, .balance-table th {
      padding: 6px;
    }

    .conversion-note {
      font-size: 0.85em;
      padding: 8px;
    }

    .warning-box {
      font-size: 0.85em;
      padding: 8px;
    }
  }

  @media (max-width: 480px) {
    .calculator-container {
      padding: 5px;
    }

    h1 {
      font-size: 1.3em;
    }

    h2 {
      font-size: 1.1em;
    }

    .input-section, .results-section {
      padding: 10px;
    }

    .btn {
      font-size: 13px;
      padding: 10px;
    }

    .fertilizer-item {
      padding: 10px;
    }

    .fertilizer-name {
      font-size: 0.95em;
    }

    .fertilizer-composition {
      font-size: 0.8em;
    }

    .result-card {
      padding: 10px;
    }

    .result-label {
      font-size: 0.85em;
    }

    .result-value {
      font-size: 1.2em;
    }
  }

  /* Educational Modal Styles */
  .info-icon {
    display: inline-block;
    width: 24px;
    height: 24px;
    background: #007bff;
    color: white;
    border-radius: 50%;
    text-align: center;
    line-height: 24px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    margin-left: 10px;
    transition: all 0.3s;
    vertical-align: middle;
  }

  .info-icon:hover {
    background: #0056b3;
    transform: scale(1.1);
  }

  .copy-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    background: #28a745;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .copy-btn:hover {
    background: #218838;
    transform: translateY(-1px);
  }

  .copy-btn:active {
    transform: translateY(0);
  }

  .copy-btn.copied {
    background: #17a2b8;
  }

  .copy-btn svg {
    width: 16px;
    height: 16px;
  }

  .results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 15px;
  }

  .results-header h2,
  .results-header h3 {
    margin: 0;
  }

  .modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    overflow-y: auto;
    padding: 20px;
  }

  .modal-overlay.active {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .modal-content {
    background: white;
    border-radius: 12px;
    max-width: 800px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    animation: modalSlideIn 0.3s ease-out;
  }

  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-50px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .modal-header {
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    color: white;
    padding: 25px;
    border-radius: 12px 12px 0 0;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .modal-header h2 {
    margin: 0;
    color: white;
    font-size: 1.5em;
  }

  .modal-close {
    position: absolute;
    top: 15px;
    right: 20px;
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    font-size: 28px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
  }

  .modal-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: rotate(90deg);
  }

  .modal-body {
    padding: 30px;
  }

  .explanation-section {
    margin-bottom: 30px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #007bff;
  }

  .explanation-section h3 {
    color: #007bff;
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.2em;
  }

  .explanation-section p {
    margin-bottom: 10px;
    line-height: 1.6;
  }

  .formula-box {
    background: white;
    padding: 20px;
    border-radius: 8px;
    border: 2px solid #007bff;
    margin: 15px 0;
    font-family: 'Courier New', monospace;
    text-align: center;
  }

  .formula-box .formula {
    font-size: 1.2em;
    font-weight: bold;
    color: #007bff;
    margin-bottom: 10px;
  }

  .formula-box .description {
    font-size: 0.9em;
    color: #666;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  }

  .example-box {
    background: #e8f4f8;
    padding: 20px;
    border-radius: 8px;
    margin: 15px 0;
    border-left: 4px solid #17a2b8;
  }

  .example-box h4 {
    color: #17a2b8;
    margin-top: 0;
    margin-bottom: 10px;
  }

  .step {
    padding: 15px;
    margin: 10px 0;
    background: white;
    border-radius: 6px;
    border-left: 3px solid #28a745;
  }

  .step-number {
    display: inline-block;
    background: #28a745;
    color: white;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    text-align: center;
    line-height: 28px;
    margin-right: 10px;
    font-weight: bold;
  }

  .conversion-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: white;
  }

  .conversion-table th,
  .conversion-table td {
    padding: 12px;
    text-align: left;
    border: 1px solid #dee2e6;
  }

  .conversion-table th {
    background: #007bff;
    color: white;
    font-weight: bold;
  }

  .conversion-table tr:nth-child(even) {
    background: #f8f9fa;
  }

  .highlight {
    background: #fff3cd;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: bold;
  }

  @media (max-width: 768px) {
    .modal-content {
      margin: 10px;
      max-height: 95vh;
    }

    .modal-header {
      padding: 20px;
    }

    .modal-header h2 {
      font-size: 1.2em;
    }

    .modal-body {
      padding: 20px;
    }

    .explanation-section {
      padding: 15px;
    }

    .formula-box .formula {
      font-size: 1em;
    }

    /* Mobile-friendly tables */
    .conversion-table {
      display: block;
      overflow-x: auto;
    }

    .conversion-table thead {
      display: none;
    }

    .conversion-table tbody {
      display: block;
    }

    .conversion-table tr {
      display: block;
      margin-bottom: 12px;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 10px;
      background: #f8f9fa;
    }

    .conversion-table td {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border: none;
      border-bottom: 1px solid #eee;
      text-align: right;
    }

    .conversion-table td:last-child {
      border-bottom: none;
    }

    .conversion-table td::before {
      content: attr(data-label);
      font-weight: bold;
      color: #007bff;
      text-align: left;
      flex: 1;
      margin-right: 10px;
    }

    .conversion-table td[style*="monospace"] {
      font-size: 0.8em !important;
      word-break: break-all;
    }

    /* Step section adjustments for mobile */
    .step > div[style*="margin-left: 38px"] {
      margin-left: 0 !important;
    }

    .step p[style*="margin: 10px 0 10px 38px"] {
      margin-left: 0 !important;
    }
  }
</style>

<!-- Progress Bar Overlay -->
<div id="progress-overlay" class="progress-overlay">
  <div class="progress-container">
    <h3 id="progress-title">Calculating...</h3>
    <div class="progress-bar-wrapper">
      <div id="progress-bar" class="progress-bar"></div>
    </div>
    <p id="progress-text" class="progress-text">Initializing solver...</p>
  </div>
</div>

<div class="calculator-container">
  <h1>Fertilizer PPM Calculator</h1>
  <p>Calculate nutrient concentrations (PPM) from fertilizer additions to water.</p>

  <div class="tabs">
    <button class="tab active" data-tab-target="ppm-calc" onclick="switchTab('ppm-calc', this)">Grams to PPM</button>
    <button class="tab" data-tab-target="formula-builder" onclick="switchTab('formula-builder', this)">PPM to Grams</button>
    <button class="tab" data-tab-target="reverse-calc" onclick="switchTab('reverse-calc', this)">NPK Ratio to Grams</button>
  </div>

  <!-- PPM Calculator Tab -->
  <div id="ppm-calc" class="tab-content active">
    <div class="input-section">
    <div class="volume-control-row">
      <div class="volume-field">
        <label for="volume">Solution Volume:</label>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="volume" value="10" min="0.1" step="0.1" oninput="validateVolumeInput(this)">
          <span>liters</span>
        </div>
      </div>
      <div class="button-group">
        <button onclick="calculate()" class="btn btn-primary">
          Calculate PPM
        </button>
        <button onclick="clearAll()" class="btn btn-danger">
          Clear All
        </button>
      </div>
    </div>

    <div class="fertilizer-selector">
      <h3>Select Fertilizers and Enter Amounts</h3>
      <div class="search-box">
        <input type="text" id="search" placeholder="Search fertilizers...">
      </div>
      <div id="fertilizer-list"></div>
    </div>
  </div>

  <div class="results-section" id="selected-fertilizers-section" style="display: none;">
    <div class="results-header">
      <h2>Selected Fertilizers</h2>
      <div id="grams-to-ppm-header-buttons" style="display: flex; gap: 10px;">
        <button class="copy-btn" onclick="displayTwoTankGramsToPPMResults()" title="Split into two tanks for stock solutions" style="background: #17a2b8;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 16px; height: 16px;"><rect x="2" y="7" width="8" height="14" rx="1"></rect><rect x="14" y="7" width="8" height="14" rx="1"></rect><path d="M6 3v4M18 3v4"></path></svg>
          Two Tanks
        </button>
        <button class="copy-btn" onclick="copyGramsToPPMResults()" title="Copy results to clipboard">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          Copy Results
        </button>
      </div>
    </div>
    <div id="selected-fertilizers-list"></div>
  </div>

  <div class="results-section" id="results" style="display: none; margin-top: 20px;">
    <h2>
      Results (PPM)
      <span class="info-icon" onclick="openPPMExplanation()" title="Click to learn how we calculate PPM">?</span>
    </h2>
    <div class="results-grid" id="results-grid"></div>
    <div class="conversion-note">
      <strong>Note:</strong> Oxide values (P₂O₅, K₂O, etc.) are automatically converted to elemental forms (P, K, etc.) using standard conversion factors.
    </div>
  </div>

  <div class="results-section" id="ion-balance-section" style="display: none; margin-top: 20px;">
    <h2>
      Ion Balance
      <span class="info-icon" onclick="openIonBalanceExplanation()" title="Click to learn how we calculate Ion Balance">?</span>
    </h2>
    <div id="ion-balance-result"></div>
    <div class="conversion-note" style="margin-top: 15px;">
      <strong>What is ion balance?</strong> Fertilizers dissolve into charged ions (cations like K⁺, Ca²⁺, NH₄⁺ and anions like NO₃⁻, SO₄²⁻, H₂PO₄⁻). A balanced feed has approximately equal positive and negative charges. Imbalance ≤10% is acceptable; higher values may cause pH swings and nutrient lockouts.
    </div>
  </div>

  <div class="results-section" id="ratio-analysis-section" style="display: none; margin-top: 20px;">
    <h2>Nutrient Ratio Analysis</h2>
    <div id="ratio-analysis-result"></div>
    <div class="conversion-note" style="margin-top: 15px;">
      <strong>What are nutrient ratios?</strong> These ratios show the relative proportions of key nutrients. For example, "1 : 0.5 : 2" for N:P:K means for every 1 part nitrogen, you have 0.5 parts phosphorus and 2 parts potassium. These ratios help compare different fertilizer formulations and match specific crop requirements.
    </div>
  </div>

  <div class="results-section" id="ec-tds-section" style="display: none; margin-top: 20px;">
    <h2>EC Prediction</h2>
    <div id="ec-tds-result"></div>
  </div>

  <div class="results-section" id="warnings-section" style="display: none; margin-top: 20px;">
    <h2>Warnings & Recommendations</h2>
    <div id="warnings-result"></div>
  </div>
  </div>

  <!-- Formula Builder Tab -->
  <div id="formula-builder" class="tab-content">
    <div class="input-section">
      <h3>Target PPM Values</h3>
      <p style="margin-bottom: 15px; color: #666;">Enter your desired nutrient concentrations (at least one required). The calculator will find the best fertilizer combination to match your targets.</p>

      <div style="margin-bottom: 20px;">
        <label for="formula-calculation-mode" style="display: block; margin-bottom: 8px; font-weight: bold;">Input Mode</label>
        <select id="formula-calculation-mode" onchange="updateFormulaCalculationMode()" style="width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;">
          <option value="oxide" selected>Oxide Forms (P₂O₅, K₂O) - Commercial Standard</option>
          <option value="elemental">Elemental Forms (P, K) - Pure Elements</option>
        </select>
        <p style="margin-top: 5px; margin-bottom: 15px; color: #666; font-size: 0.85em;">
          <strong>Oxide mode:</strong> Enter P₂O₅ and K₂O values (matches fertilizer labels and NPK Ratio to Grams output)<br>
          <strong>Elemental mode:</strong> Enter pure P and K values (scientific calculations)
        </p>
      </div>

      <div class="target-input-grid">
        <div class="target-input-field">
          <label for="target-n">Nitrogen (N)</label>
          <input type="number" id="target-n" min="0" step="1" placeholder="e.g., 150" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="target-p" id="target-p-label">Phosphorus (P₂O₅)</label>
          <input type="number" id="target-p" min="0" step="1" placeholder="e.g., 50" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="target-k" id="target-k-label">Potassium (K₂O)</label>
          <input type="number" id="target-k" min="0" step="1" placeholder="e.g., 200" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="target-ca">Calcium (Ca)</label>
          <input type="number" id="target-ca" min="0" step="1" placeholder="e.g., 150" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="target-mg">Magnesium (Mg)</label>
          <input type="number" id="target-mg" min="0" step="1" placeholder="e.g., 50" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="target-s">Sulfur (S)</label>
          <input type="number" id="target-s" min="0" step="1" placeholder="Optional" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="target-si">Silicon (Si) <small style="color:#666">PPM</small></label>
          <input type="number" id="target-si" min="0" step="1" value="0" placeholder="Target PPM" oninput="validateTargetInput(this, true)">
        </div>
      </div>

      <div class="fertilizer-selection">
        <h4>Available Fertilizers</h4>
        <p style="margin-bottom: 10px; color: #666; font-size: 0.9em;">Select the fertilizers you have available. The calculator will use only these to build your formula.</p>
        <div class="fertilizer-search">
          <input type="text" id="available-fertilizer-search" placeholder="Search fertilizers..." oninput="filterAvailableFertilizers(this.value)">
        </div>
        <div class="selection-controls">
          <button onclick="selectAllAvailableFertilizers()">Select All</button>
          <button onclick="deselectAllAvailableFertilizers()">Deselect All</button>
          <button onclick="selectCommonFertilizers()">Select Common Only</button>
        </div>
        <div class="fertilizer-grid" id="available-fertilizers-list"></div>
      </div>

      <div class="volume-input">
        <label for="formula-volume">Solution Volume:</label>
        <input type="number" id="formula-volume" value="10" min="0.1" step="0.1" oninput="validateVolumeInput(this)">
        <span>liters</span>
      </div>

      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button onclick="buildFormula()" style="padding: 10px 20px; font-size: 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
          Build Formula
        </button>
        <button onclick="clearFormulaBuilder()" style="padding: 10px 20px; font-size: 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
          Clear
        </button>
      </div>
    </div>

    <div class="results-section" id="formula-results" style="display: none;">
      <div class="results-header" id="formula-results-header">
        <h2>Recommended Formula</h2>
        <div id="formula-header-buttons" style="display: flex; gap: 10px;">
          <button class="copy-btn" onclick="displayTwoTankFormulaResults()" title="Split into two tanks for stock solutions" style="background: #17a2b8;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 16px; height: 16px;"><rect x="2" y="7" width="8" height="14" rx="1"></rect><rect x="14" y="7" width="8" height="14" rx="1"></rect><path d="M6 3v4M18 3v4"></path></svg>
            Two Tanks
          </button>
          <button class="copy-btn" onclick="copyPPMToGramsResults()" title="Copy results to clipboard">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
            Copy Results
          </button>
        </div>
      </div>
      <div id="formula-output"></div>
    </div>
  </div>

  <!-- Reverse Calculator Tab -->
  <div id="reverse-calc" class="tab-content">
    <div class="input-section">
      <h3>Target Nutrient Ratios</h3>
      <p style="margin-bottom: 15px; color: #666;">Enter your desired nutrient ratios (e.g., N:P:K = 3:1:2). At least one nutrient must be greater than zero. The calculator will find fertilizer amounts that match these ratios.</p>

      <div class="target-input-grid">
        <div class="target-input-field">
          <label for="reverse-n">Nitrogen (N)</label>
          <input type="number" id="reverse-n" min="0" step="1" placeholder="Optional (0 or more)" oninput="validateTargetInput(this)">
        </div>
        <div class="target-input-field">
          <label for="reverse-p">Phosphorus (P)</label>
          <input type="number" id="reverse-p" min="0" step="1" placeholder="Optional (0 or more)" oninput="validateTargetInput(this)">
        </div>
        <div class="target-input-field">
          <label for="reverse-k">Potassium (K)</label>
          <input type="number" id="reverse-k" min="0" step="1" placeholder="Optional (0 or more)" oninput="validateTargetInput(this)">
        </div>
        <div class="target-input-field">
          <label for="reverse-ca">Calcium (Ca)</label>
          <input type="number" id="reverse-ca" min="0" step="1" placeholder="Optional (0 or more)" oninput="validateTargetInput(this)">
        </div>
        <div class="target-input-field">
          <label for="reverse-mg">Magnesium (Mg)</label>
          <input type="number" id="reverse-mg" min="0" step="1" placeholder="Optional (0 or more)" oninput="validateTargetInput(this)">
        </div>
        <div class="target-input-field">
          <label for="reverse-s">Sulfur (S)</label>
          <input type="number" id="reverse-s" min="0" step="1" placeholder="Optional (0 or more)" oninput="validateTargetInput(this, true)">
        </div>
        <div class="target-input-field">
          <label for="reverse-si">Silicon (Si) <small style="color:#666">PPM</small></label>
          <input type="number" id="reverse-si" min="0" step="1" value="0" placeholder="Target PPM (not ratio)" oninput="validateTargetInput(this, true)">
        </div>
      </div>

      <div style="margin-top: 20px; margin-bottom: 20px;">
        <label for="reverse-calculation-mode" style="display: block; margin-bottom: 8px; font-weight: bold;">Calculation Mode</label>
        <select id="reverse-calculation-mode" onchange="updateReverseCalculationMode()" style="width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;">
          <option value="oxide" selected>Oxide Forms (P₂O₅, K₂O) - Commercial Standard</option>
          <option value="elemental">Elemental Forms (P, K) - Pure Elements</option>
        </select>
        <p style="margin-top: 5px; margin-bottom: 15px; color: #666; font-size: 0.85em;">
          <strong>Oxide mode:</strong> Uses P₂O₅ and K₂O (standard fertilizer labels)<br>
          <strong>Elemental mode:</strong> Uses pure P and K (scientific calculations)
        </p>
      </div>

      <div style="margin-top: 20px; margin-bottom: 20px;">
        <label for="reverse-concentration" style="display: block; margin-bottom: 8px; font-weight: bold;">Target EC (mS/cm)</label>
        <select id="reverse-concentration" style="width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="ec:0.2">0.2 mS/cm - Plain Water Supplement</option>
          <option value="ec:0.4">0.4 mS/cm - Recovery/Flush</option>
          <option value="ec:0.6">0.6 mS/cm - Fresh Clones/Cuttings</option>
          <option value="ec:0.8">0.8 mS/cm - Rooted Cuttings</option>
          <option value="ec:1.0">1.0 mS/cm - Seedlings/Young Plants</option>
          <option value="ec:1.2" selected>1.2 mS/cm - General Purpose</option>
          <option value="ec:1.5">1.5 mS/cm - Vegetative Growth</option>
          <option value="ec:1.8">1.8 mS/cm - Active Growth</option>
          <option value="ec:2.0">2.0 mS/cm - Heavy Feeders</option>
          <option value="ec:2.5">2.5 mS/cm - Flowering/Fruiting</option>
          <option value="ec:3.0">3.0 mS/cm - Maximum (experienced growers)</option>
        </select>
        <p style="margin-top: 5px; color: #666; font-size: 0.85em;">
          Select your target EC. Fertilizer amounts will be scaled to achieve this conductivity.<br>
          <strong>Ratios are preserved</strong> while adjusting overall concentration.
        </p>
      </div>

      <div class="fertilizer-selection">
        <h4>Select Fertilizers to Use</h4>
        <p style="margin-bottom: 10px; color: #666; font-size: 0.9em;">Choose which fertilizers you want to use. The calculator will find the best combination from your selection.</p>
        <div class="fertilizer-search">
          <input type="text" id="reverse-fertilizer-search" placeholder="Search fertilizers..." oninput="filterReverseFertilizers(this.value)">
        </div>
        <div class="selection-controls">
          <button onclick="selectAllReverseFertilizers()">Select All</button>
          <button onclick="deselectAllReverseFertilizers()">Deselect All</button>
          <button onclick="selectCommonReverseFertilizers()">Select Common Only</button>
        </div>
        <div class="fertilizer-grid" id="reverse-fertilizers-list"></div>
      </div>

      <div class="volume-input">
        <label for="reverse-volume">Solution Volume:</label>
        <input type="number" id="reverse-volume" value="10" min="0.1" step="0.1" oninput="validateVolumeInput(this)">
        <span>liters</span>
      </div>

      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button onclick="calculateReverse()" style="padding: 10px 20px; font-size: 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
          Calculate Fertilizers
        </button>
        <button onclick="clearReverseCalculator()" style="padding: 10px 20px; font-size: 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
          Clear
        </button>
      </div>
    </div>

    <div class="results-section" id="reverse-results" style="display: none;">
      <div class="results-header" id="reverse-results-header">
        <h2>Required Fertilizers</h2>
        <div id="reverse-header-buttons" style="display: flex; gap: 10px;">
          <button class="copy-btn" onclick="displayTwoTankReverseResults()" title="Split into two tanks for stock solutions" style="background: #17a2b8;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 16px; height: 16px;"><rect x="2" y="7" width="8" height="14" rx="1"></rect><rect x="14" y="7" width="8" height="14" rx="1"></rect><path d="M6 3v4M18 3v4"></path></svg>
            Two Tanks
          </button>
          <button class="copy-btn" onclick="copyNPKRatioResults()" title="Copy results to clipboard">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
            Copy Results
          </button>
        </div>
      </div>
      <div id="reverse-output"></div>
    </div>
  </div>

</div>

<!-- Educational Modal for PPM Calculation -->
<div id="ppm-modal" class="modal-overlay" onclick="closePPMExplanation(event)">
  <div class="modal-content" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h2>Understanding PPM Calculations</h2>
      <button class="modal-close" onclick="closePPMExplanation()">&times;</button>
    </div>
    <div class="modal-body">

      <!-- What is PPM? -->
      <div class="explanation-section">
        <h3>What is PPM?</h3>
        <p>
          <strong>PPM stands for "Parts Per Million"</strong> - it's a way to measure very small concentrations, similar to how we use percentages.
          Think of it like this: if you have 1 million drops of water, PPM tells you how many drops of nutrients are mixed in.
        </p>
        <p>
          For example, <span class="highlight">100 PPM of Nitrogen</span> means there are 100 grams of nitrogen in every 1 million grams (1000 liters) of water.
          In simpler terms: <strong>1 PPM = 1 milligram per liter (mg/L)</strong>.
        </p>
      </div>

      <!-- The Basic Formula -->
      <div class="explanation-section">
        <h3>The Basic Formula</h3>
        <p>Here's the formula we use to calculate PPM:</p>

        <div class="formula-box">
          <div class="formula">PPM = (grams × 1000 × percentage) ÷ liters</div>
          <div class="description">This tells us the concentration of nutrients in your solution</div>
        </div>

        <p>Let's break down each part:</p>
        <ul style="line-height: 1.8;">
          <li><strong>grams</strong> = Amount of fertilizer you're adding</li>
          <li><strong>1000</strong> = Converts grams to milligrams (mg)</li>
          <li><strong>percentage</strong> = The nutrient content in the fertilizer (÷ 100)</li>
          <li><strong>liters</strong> = Volume of water in your solution</li>
        </ul>
      </div>

      <!-- Step by Step Example -->
      <div class="explanation-section">
        <h3>Step-by-Step Example</h3>

        <div class="example-box">
          <h4>Real World Scenario:</h4>
          <p>You want to add <strong>2 grams</strong> of Calcium Nitrate (which contains <strong>19% Nitrogen</strong>) to <strong>10 liters</strong> of water.</p>
          <p><em>Question: How much Nitrogen (in PPM) will be in your final solution?</em></p>
        </div>

        <div class="step">
          <span class="step-number">1</span>
          <strong>Identify your values:</strong>
          <ul style="margin: 10px 0 0 38px; line-height: 1.6;">
            <li>Fertilizer amount = 2 grams</li>
            <li>Nitrogen percentage = 19% (or 0.19)</li>
            <li>Water volume = 10 liters</li>
          </ul>
        </div>

        <div class="step">
          <span class="step-number">2</span>
          <strong>Plug into the formula:</strong>
          <div style="margin: 10px 0 0 38px;">
            <code>PPM = (2 grams × 1000 × 0.19) ÷ 10 liters</code>
          </div>
        </div>

        <div class="step">
          <span class="step-number">3</span>
          <strong>Calculate step by step:</strong>
          <ul style="margin: 10px 0 0 38px; line-height: 1.6;">
            <li>2 × 1000 = 2000 mg</li>
            <li>2000 × 0.19 = 380 mg of nitrogen</li>
            <li>380 ÷ 10 = <strong>38 PPM</strong></li>
          </ul>
        </div>

        <div class="step">
          <span class="step-number">4</span>
          <strong>Result:</strong>
          <div style="margin: 10px 0 0 38px;">
            Your solution contains <span class="highlight">38 PPM of Nitrogen</span>
          </div>
        </div>
      </div>

      <!-- Multiple Fertilizers -->
      <div class="explanation-section">
        <h3>Using Multiple Fertilizers</h3>
        <p>
          When you use multiple fertilizers, we calculate the PPM from each one separately and then <strong>add them together</strong>.
        </p>

        <div class="example-box">
          <h4>Example with Two Fertilizers:</h4>
          <p>You add both Calcium Nitrate (2g, 19% N) and Potassium Nitrate (1.5g, 13% N) to 10 liters:</p>

          <ul style="line-height: 1.8; margin-top: 10px;">
            <li><strong>From Calcium Nitrate:</strong> (2 × 1000 × 0.19) ÷ 10 = 38 PPM</li>
            <li><strong>From Potassium Nitrate:</strong> (1.5 × 1000 × 0.13) ÷ 10 = 19.5 PPM</li>
            <li><strong>Total Nitrogen:</strong> 38 + 19.5 = <span class="highlight">57.5 PPM</span></li>
          </ul>
        </div>
      </div>

      <!-- Oxide Conversions -->
      <div class="explanation-section">
        <h3>Understanding Oxide Conversions</h3>
        <p>
          Many fertilizers list nutrients in their <strong>oxide form</strong> (like P₂O₅ for phosphorus or K₂O for potassium),
          but plants actually use the <strong>elemental form</strong>. Don't worry - the calculator handles this automatically!
        </p>

        <table class="conversion-table">
          <thead>
            <tr>
              <th>Oxide Form (on fertilizer label)</th>
              <th>Elemental Form (what plants use)</th>
              <th>Conversion Factor</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td data-label="Oxide Form">P₂O₅ (Phosphate)</td>
              <td data-label="Elemental Form">P (Phosphorus)</td>
              <td data-label="Conversion Factor">Multiply by 0.436</td>
            </tr>
            <tr>
              <td data-label="Oxide Form">K₂O (Potash)</td>
              <td data-label="Elemental Form">K (Potassium)</td>
              <td data-label="Conversion Factor">Multiply by 0.830</td>
            </tr>
            <tr>
              <td data-label="Oxide Form">MgO (Magnesium Oxide)</td>
              <td data-label="Elemental Form">Mg (Magnesium)</td>
              <td data-label="Conversion Factor">Multiply by 0.603</td>
            </tr>
            <tr>
              <td data-label="Oxide Form">CaO (Calcium Oxide)</td>
              <td data-label="Elemental Form">Ca (Calcium)</td>
              <td data-label="Conversion Factor">Multiply by 0.715</td>
            </tr>
          </tbody>
        </table>

        <div class="example-box" style="margin-top: 15px;">
          <h4>Quick Example:</h4>
          <p>
            If a fertilizer gives you <strong>100 PPM of P₂O₅</strong>, the actual phosphorus available to plants is:<br>
            <strong>100 × 0.436 = 43.6 PPM of P</strong>
          </p>
          <p style="margin-top: 10px; color: #17a2b8; font-weight: bold;">
            ✓ The calculator does this conversion automatically for you!
          </p>
        </div>
      </div>

      <!-- Why This Matters -->
      <div class="explanation-section">
        <h3>Why Does This Matter?</h3>
        <p>
          Understanding PPM helps you:
        </p>
        <ul style="line-height: 1.8;">
          <li><strong>Feed plants properly:</strong> Different plants need different nutrient levels (e.g., tomatoes might need 150-200 PPM nitrogen)</li>
          <li><strong>Avoid over-feeding:</strong> Too much nutrients can burn or damage plants</li>
          <li><strong>Save money:</strong> Use just the right amount of fertilizer</li>
          <li><strong>Compare recipes:</strong> Understand different fertilizer formulations</li>
        </ul>
      </div>

      <!-- Quick Tips -->
      <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
        <h3 style="color: #28a745;">Quick Tips</h3>
        <ul style="line-height: 1.8;">
          <li>Start with lower PPM values and increase gradually</li>
          <li>1 PPM = 1 mg/L (milligram per liter)</li>
          <li>More fertilizer ≠ better growth; balance is key</li>
          <li>Check your water's existing nutrient content if possible</li>
          <li>Different growth stages may need different PPM levels</li>
        </ul>
      </div>

    </div>
  </div>
</div>

<!-- Educational Modal for Ion Balance -->
<div id="ion-balance-modal" class="modal-overlay" onclick="closeIonBalanceExplanation(event)">
  <div class="modal-content" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h2>Understanding Ion Balance</h2>
      <button class="modal-close" onclick="closeIonBalanceExplanation()">&times;</button>
    </div>
    <div class="modal-body" id="ion-balance-modal-body">
      <!-- Content will be dynamically generated -->
    </div>
  </div>
</div>

<!-- MILP dependencies -->
<script src="/assets/vendor/lp-model/lp-model.min.js"></script>
<script src="/assets/vendor/highs/highs.js"></script>

<script>
// Progress bar helper functions
const progressBar = {
  overlay: null,
  bar: null,
  title: null,
  text: null,

  init() {
    this.overlay = document.getElementById('progress-overlay');
    this.bar = document.getElementById('progress-bar');
    this.title = document.getElementById('progress-title');
    this.text = document.getElementById('progress-text');
  },

  show(title = 'Calculating...') {
    if (!this.overlay) this.init();
    this.title.textContent = title;
    this.bar.style.width = '0%';
    this.bar.classList.remove('indeterminate');
    this.text.textContent = 'Initializing...';
    this.overlay.classList.add('active');
  },

  update(percent, message) {
    if (!this.bar) this.init();
    this.bar.classList.remove('indeterminate');
    this.bar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
    if (message) this.text.textContent = message;
  },

  setIndeterminate(message) {
    if (!this.bar) this.init();
    this.bar.classList.add('indeterminate');
    if (message) this.text.textContent = message;
  },

  hide() {
    if (!this.overlay) this.init();
    this.overlay.classList.remove('active');
  }
};

// MILP solver helper (browser) using highs.js + lp-model
async function solveMilpBrowser({ fertilizers, targets, volume, tolerance = 0.01 }) {
  const highsFactory = window.highs || window.Module;
  if (!window.LPModel || typeof highsFactory !== 'function') {
    throw new Error('MILP dependencies not loaded');
  }

  const { Model } = window.LPModel;
  const highs = await highsFactory({
    locateFile: (f) => `/assets/vendor/highs/${f}`
  });

  const nutrients = ['N_total', 'P2O5', 'K2O', 'Ca', 'Mg', 'S', 'Si'];
  const tPlus = {}, tMinus = {};
  nutrients.forEach(n => {
    const t = targets[n] || 0;
    tPlus[n] = t > 0 ? t * (1 + tolerance) : 0;
    tMinus[n] = t > 0 ? t * (1 - tolerance) : 0;
  });

  const model = new Model();
  const x = {}, y = {}, slackPlus = {}, slackMinus = {};
  fertilizers.forEach(f => {
    x[f.id] = model.addVar({ lb: 0, ub: '+infinity', vtype: 'CONTINUOUS', name: `x_${f.id}` });
    y[f.id] = model.addVar({ lb: 0, ub: 1, vtype: 'BINARY', name: `y_${f.id}` });
  });
  nutrients.forEach(n => {
    slackPlus[n] = model.addVar({ lb: 0, ub: '+infinity', vtype: 'CONTINUOUS', name: `s_plus_${n}` });
    slackMinus[n] = model.addVar({ lb: 0, ub: '+infinity', vtype: 'CONTINUOUS', name: `s_minus_${n}` });
  });

  const BIG_M = 10000;
  fertilizers.forEach(f => {
    model.addConstr([[1, x[f.id]], [-BIG_M, y[f.id]]], '<=', 0);
  });

  function perGramContrib(fert) {
    const c = { N_total: 0, P2O5: 0, K2O: 0, Ca: 0, Mg: 0, S: 0, Si: 0 };
    const hasNForms = fert.pct.N_NO3 || fert.pct.N_NH4;
    Object.entries(fert.pct).forEach(([nutrient, pct]) => {
      const ppm = (1 * 1000 * (pct / 100)) / volume;
      if (nutrient === 'N_NO3' || nutrient === 'N_NH4') {
        c.N_total += ppm;
      } else if (nutrient === 'N_total') {
        if (!hasNForms) c.N_total += ppm;
      } else if (nutrient === 'P2O5' || nutrient === 'K2O' || nutrient === 'Ca' || nutrient === 'Mg' || nutrient === 'S') {
        c[nutrient] += ppm;
      } else if (nutrient === 'SiO2') {
        c.Si += ppm * 0.46744; // SiO2 to Si conversion
      } else if (nutrient === 'SiOH4') {
        c.Si += ppm * 0.2922; // Si(OH)4 to Si conversion
      } else if (nutrient === 'Si') {
        c.Si += ppm;
      }
    });
    return c;
  }

  nutrients.forEach(n => {
    const terms = [];
    fertilizers.forEach(f => {
      const c = perGramContrib(f);
      if (c[n] !== 0) terms.push([c[n], x[f.id]]);
    });
    if (tMinus[n] > 0) {
      model.addConstr([...terms, [-1, slackMinus[n]]], '>=', tMinus[n]);
    }
    const ub = tPlus[n] > 0 ? tPlus[n] : 0;
    model.addConstr([...terms, [-1, slackPlus[n]]], '<=', ub);
  });

  const objective = [];
  fertilizers.forEach(f => objective.push([1, y[f.id]]));
  nutrients.forEach(n => {
    const isTargeted = (targets[n] || 0) > 0;
    const slackPenalty = isTargeted ? 100 : 50;
    objective.push([slackPenalty, slackPlus[n]]);
    objective.push([slackPenalty, slackMinus[n]]);
  });
  model.setObjective(objective, 'MINIMIZE');

  const lp = model.toLPFormat();
  const solution = highs.solve(lp);
  if (!solution || !model.variables) throw new Error('MILP solver failed');

  const formula = {};
  if (solution.Columns) {
    fertilizers.forEach(f => {
      const col = solution.Columns[`x_${f.id}`] || solution.Columns[f.id];
      const grams = col && typeof col.Primal === 'number' ? col.Primal : 0;
      if (grams > 1e-4) formula[f.id] = grams;
    });
  }

  const achieved = { N_total: 0, N_NO3: 0, N_NH4: 0, P2O5: 0, K2O: 0, P: 0, K: 0, Ca: 0, Mg: 0, S: 0, Si: 0 };
  Object.entries(formula).forEach(([fid, grams]) => {
    const fert = fertilizers.find(f => f.id === fid);
    if (!fert) return;
    const hasNForms = fert.pct.N_NO3 || fert.pct.N_NH4;
    Object.entries(fert.pct).forEach(([nutrient, pct]) => {
      const ppm = (grams * 1000 * (pct / 100)) / volume;
      if (nutrient === 'N_NO3') {
        achieved.N_NO3 += ppm;
        achieved.N_total += ppm;
      } else if (nutrient === 'N_NH4') {
        achieved.N_NH4 += ppm;
        achieved.N_total += ppm;
      } else if (nutrient === 'N_total') {
        if (!hasNForms) achieved.N_total += ppm;
      } else if (nutrient === 'P2O5') {
        achieved.P2O5 += ppm;
        achieved.P += ppm * 0.436; // P2O5 to P conversion
      } else if (nutrient === 'K2O') {
        achieved.K2O += ppm;
        achieved.K += ppm * 0.830; // K2O to K conversion
      } else if (nutrient === 'SiO2') {
        achieved.Si += ppm * 0.46744; // SiO2 to Si conversion
      } else if (nutrient === 'SiOH4') {
        achieved.Si += ppm * 0.2922; // Si(OH)4 to Si conversion
      } else if (achieved[nutrient] !== undefined) {
        achieved[nutrient] += ppm;
      }
    });
  });

  return { formula, achieved };
}

// Fertilizer database
const FERTILIZERS = [
  {
    id: "calcium_nitrate_calcinit_typical",
    name: "Calcium Nitrate - Calcinit type (15.5% N, 19% Ca)",
    aliases: ["YaraLiva Calcinit", "Calcium nitrate 15.5-0-0 + Ca", "Calcinit"],
    pct: { N_total: 15.5, N_NO3: 14.4, N_NH4: 1.1, Ca: 19.0 }
  },
  {
    id: "potassium_nitrate_typical",
    name: "Potassium Nitrate",
    aliases: ["KNO3", "13.7-0-46.3"],
    pct: { N_total: 13.7, N_NO3: 13.7, K2O: 46.3 }
  },
  {
    id: "map_typical",
    name: "Mono Ammonium Phosphate (MAP)",
    aliases: ["NH4H2PO4", "12-61-0", "12 61", "12:61" ],
    pct: { N_total: 12.0, N_NH4: 12.0, P2O5: 61.0 }
  },
  {
    id: "mkp_typical",
    name: "Mono Potassium Phosphate (MKP)",
    aliases: ["KH2PO4", "0-52-34", "0:52:34", "52 34"],
    pct: { P2O5: 52.0, K2O: 34.0 }
  },
  {
    id: "dap_common",
    name: "Di Ammonium Phosphate (DAP)",
    aliases: ["(NH4)2HPO4", "18-46-0"],
    pct: { N_total: 18.0, N_NH4: 18.0, P2O5: 46.0 }
  },
  {
    id: "ssp_common",
    name: "Single Super Phosphate (SSP)",
    aliases: ["SSP", "Superphosphate", "0-16-0", "Ca(H2PO4)2"],
    pct: { P2O5: 16.0, Ca: 20.0, S: 12.0 }
  },
  {
    id: "urea_common",
    name: "Urea",
    aliases: ["CO(NH2)2", "46-0-0"],
    pct: { N_total: 46.0, N_Urea: 46.0 }
  },
  {
    id: "ammonium_sulfate_common",
    name: "Ammonium Sulfate",
    aliases: ["(NH4)2SO4", "21-0-0 + 24S"],
    pct: { N_total: 21.0, N_NH4: 21.0, S: 24.0 }
  },
  {
    id: "ammonium_nitrate_common",
    name: "Ammonium Nitrate - Solid (34% N)",
    aliases: ["NH4NO3", "34-0-0 (typical)", "Ammonium Nitrate solid"],
    pct: { N_total: 34.0, N_NO3: 17.0, N_NH4: 17.0 }
  },
  {
    id: "magnesium_sulfate_heptahydrate_common",
    name: "Magnesium Sulfate - Heptahydrate / Epsom Salt (9.86% Mg)",
    aliases: ["MgSO4·7H2O", "Epsom Salt", "Magnesium Sulfate 7H2O"],
    pct: { Mg: 9.86, S: 13.0 }
  },
  {
    id: "magnesium_sulfate_16mgo",
    name: "Magnesium Sulfate (16% MgO) (~9.6% Mg, ~13% S)",
    aliases: ["MgSO4", "Magnesium Sulphate", "Epsom Salt", "MgSO4·7H2O (if heptahydrate)"],
    pct: { MgO: 16.0, Mg: 9.6, S: 13.0 }
  },
  {
    id: "magnesium_nitrate_hexahydrate_typical",
    name: "Magnesium Nitrate - Hexahydrate (10.9% N, 9.5% Mg)",
    aliases: ["Mg(NO3)2·6H2O", "Magnesium Nitrate 6H2O"],
    pct: { N_total: 10.9, N_NO3: 10.9, Mg: 9.5 }
  },
  {
    id: "potassium_sulfate_common",
    name: "Potassium Sulfate (SOP)",
    aliases: ["K2SO4", "0-0-50 + ~17S"],
    pct: { K2O: 50.0, S: 17.0 }
  },
  {
    id: "potassium_chloride_common",
    name: "Potassium Chloride (MOP)",
    aliases: ["KCl", "0-0-60"],
    pct: { K2O: 60.0, Cl: 47.6 }
  },
  {
    id: "calcium_chloride_dihydrate_common",
    name: "Calcium Chloride - Dihydrate (27.2% Ca)",
    aliases: ["CaCl2·2H2O", "Calcium Chloride 2H2O"],
    pct: { Ca: 27.2, Cl: 48.3 }
  },
  {
    id: "langbeinite_common",
    name: "Langbeinite / Sul-Po-Mag",
    aliases: ["K2SO4·2MgSO4", "0-0-22 + 11Mg + 22S"],
    pct: { K2O: 22.0, Mg: 11.0, S: 22.0 }
  },
  {
    id: "uan32_solution_typical",
    name: "UAN Solution (example: 32-0-0)",
    aliases: ["UAN-32"],
    pct: { N_total: 32.0, N_Urea: 16.0, N_NO3: 8.0, N_NH4: 8.0 }
  },
  {
    id: "ammonium_thiosulfate_common",
    name: "Ammonium Thiosulfate (ATS)",
    aliases: ["12-0-0-26S (common liquid)"],
    pct: { N_total: 12.0, N_NH4: 12.0, S: 26.0 }
  },
  {
    id: "potassium_thiosulfate_common",
    name: "Potassium Thiosulfate (KTS)",
    aliases: ["0-0-25-17S (common liquid)"],
    pct: { K2O: 25.0, S: 17.0 }
  },
  {
    id: "fe_edta_13",
    name: "Iron Chelate - EDTA (13% Fe)",
    aliases: ["Fe-EDTA 13", "Fe-EDTA 13%"],
    pct: { Fe: 13.0 }
  },
  {
    id: "boric_acid_common",
    name: "Boric Acid",
    aliases: ["H3BO3"],
    pct: { B: 17.5 }
  },
  {
    id: "zinc_sulfate_heptahydrate_common",
    name: "Zinc Sulfate - Heptahydrate (22.7% Zn)",
    aliases: ["ZnSO4·7H2O", "Zinc Sulfate 7H2O"],
    pct: { Zn: 22.7, S: 11.2 }
  },
  {
    id: "nitric_acid_38",
    name: "Nitric Acid 38%",
    aliases: ["HNO3 38%"],
    pct: { N_total: 8.4, N_NO3: 8.4 }
  },
  {
    id: "nitric_acid_60",
    name: "Nitric Acid 60%",
    aliases: ["HNO3 60%"],
    pct: { N_total: 13.3, N_NO3: 13.3 }
  },
  {
    id: "phosphoric_acid_49",
    name: "Phosphoric Acid 49%",
    aliases: ["H3PO4 49%"],
    pct: { P: 18.6 }
  },
  {
    id: "potassium_bicarbonate",
    name: "Potassium Bicarbonate",
    aliases: ["KHCO3"],
    pct: { K: 39.0 }
  },
  {
    id: "ammonium_nitrate_liquid",
    name: "Ammonium Nitrate - Liquid (18% N)",
    aliases: ["NH4NO3 liquid", "Ammonium Nitrate liquid"],
    pct: { N_total: 18.0, N_NO3: 9.0, N_NH4: 9.0 }
  },
  {
    id: "urea_phosphate",
    name: "Urea Phosphate",
    aliases: ["CO(NH2)2·H3PO4"],
    pct: { N_total: 17.5, N_Urea: 17.5, P: 19.6 }
  },
  {
    id: "calcium_nitrate_4h2o",
    name: "Calcium Nitrate - Tetrahydrate (11.5% N, 16.5% Ca)",
    aliases: ["Ca(NO3)2·4H2O", "Calcium Nitrate 4H2O"],
    pct: { N_total: 11.5, N_NO3: 11.5, Ca: 16.5 }
  },
  {
    id: "calcium_nitrate_anhydrous",
    name: "Calcium Nitrate - Anhydrous (15.5% N, 18.5% Ca)",
    aliases: ["Ca(NO3)2", "Calcium Nitrate anhydrous"],
    pct: { N_total: 15.5, N_NO3: 15.5, Ca: 18.5 }
  },
  {
    id: "calcium_nitrate_liquid",
    name: "Calcium Nitrate - Liquid (8.7% N, 12.5% Ca)",
    aliases: ["Ca(NO3)2 liquid", "Calcium Nitrate liquid"],
    pct: { N_total: 8.7, N_NO3: 8.7, Ca: 12.5 }
  },
  {
    id: "calcium_chloride_solid",
    name: "Calcium Chloride - Solid (36% Ca)",
    aliases: ["CaCl2 solid", "Calcium Chloride solid"],
    pct: { Ca: 36.0, Cl: 63.9 }
  },
  {
    id: "calcium_chloride_liquid",
    name: "Calcium Chloride - Liquid (11.8% Ca)",
    aliases: ["CaCl2 liquid", "Calcium Chloride liquid"],
    pct: { Ca: 11.8, Cl: 20.9 }
  },
  {
    id: "magnesium_sulfate_anhydrous",
    name: "Magnesium Sulfate - Anhydrous (19.6% Mg)",
    aliases: ["MgSO4", "Magnesium Sulfate anhydrous"],
    pct: { Mg: 19.6, S: 26.5 }
  },
  {
    id: "magnesium_nitrate_liquid",
    name: "Magnesium Nitrate - Liquid (7% N, 6.1% Mg)",
    aliases: ["Mg(NO3)2 liquid", "Magnesium Nitrate liquid"],
    pct: { N_total: 7.0, N_NO3: 7.0, Mg: 6.1 }
  },
  {
    id: "fe_dtpa_12",
    name: "Iron Chelate - DTPA solid (12% Fe)",
    aliases: ["Fe-DTPA 12%", "Fe-DTPA 12"],
    pct: { Fe: 12.0 }
  },
  {
    id: "fe_dtpa_liquid_3",
    name: "Iron Chelate - DTPA liquid (3% Fe)",
    aliases: ["Fe-DTPA 3%", "Fe-DTPA 3"],
    pct: { Fe: 3.0 }
  },
  {
    id: "fe_dtpa_liquid_6",
    name: "Iron Chelate - DTPA liquid (6% Fe)",
    aliases: ["Fe-DTPA 6%", "Fe-DTPA 6"],
    pct: { Fe: 6.0 }
  },
  {
    id: "fe_eddha_6",
    name: "Iron Chelate - EDDHA (6% Fe)",
    aliases: ["Fe-EDDHA 6%", "Fe-EDDHA 6"],
    pct: { Fe: 6.0 }
  },
  {
    id: "fe_hbed_6",
    name: "Iron Chelate - HBED (6% Fe)",
    aliases: ["Fe-HBED 6%", "Fe-HBED 6"],
    pct: { Fe: 6.0 }
  },
  {
    id: "mn_edta_13",
    name: "Manganese Chelate - EDTA (13% Mn)",
    aliases: ["Mn-EDTA 13%", "Mn-EDTA 13"],
    pct: { Mn: 13.0 }
  },
  {
    id: "zn_edta_15",
    name: "Zinc Chelate - EDTA (15% Zn)",
    aliases: ["Zn-EDTA 15%", "Zn-EDTA 15"],
    pct: { Zn: 15.0 }
  },
  {
    id: "cu_edta_15",
    name: "Copper Chelate - EDTA (15% Cu)",
    aliases: ["Cu-EDTA 15%", "Cu-EDTA 15"],
    pct: { Cu: 15.0 }
  },
  {
    id: "manganese_sulfate",
    name: "Manganese Sulfate",
    aliases: ["MnSO4·H2O"],
    pct: { Mn: 32.5, S: 18.9 }
  },
  {
    id: "zinc_sulfate_mono",
    name: "Zinc Sulfate - Monohydrate (36% Zn)",
    aliases: ["ZnSO4·H2O", "Zinc Sulfate H2O"],
    pct: { Zn: 36.0 }
  },
  {
    id: "borax",
    name: "Borax",
    aliases: ["Na2B4O7·10H2O"],
    pct: { B: 11.3 }
  },
  {
    id: "copper_sulfate",
    name: "Copper Sulfate",
    aliases: ["CuSO4·5H2O"],
    pct: { Cu: 25.5, S: 12.8 }
  },
  {
    id: "sodium_molybdate",
    name: "Sodium Molybdate",
    aliases: ["Na2MoO4·2H2O"],
    pct: { Mo: 39.6 }
  },
  {
    id: "ammonium_molybdate",
    name: "Ammonium Molybdate",
    aliases: ["(NH4)6Mo7O24·4H2O"],
    pct: { Mo: 52.0, N_total: 8.0, N_NH4: 8.0 }
  },
  {
    id: "potassium_silicate_liquid_typical",
    name: "Potassium Silicate (3.7% Si, 7.8% K2O)",
    aliases: ["Potassium Silicate", "Pro-TeKt", "Liquid Potassium Silicate", "K2SiO3 solution"],
    pct: { K2O: 7.8, Si: 3.7 }
  },
  {
    id: "rexolin_cxk",
    name: "Rexolin CXK (Chelated Micronutrient Mix)",
    aliases: ["Rexolin CXK", "CXK"],
    pct: { Fe: 3.4, Mn: 3.2, Zn: 4.2, B: 1.5, Mg: 1.2, Mo: 0.05 }
  },
  {
    id: "utkarsh_double_combi",
    name: "Utkarsh Double Combi (Micronutrient Mix)",
    aliases: ["Utkarsh Double Combi", "Double Combi"],
    pct: { Ca: 1.0, Mg: 2.5, Zn: 2.0, Fe: 2.0, Mn: 1.0, B: 1.0, Cu: 0.5, Mo: 0.05, Co: 0.005 }
  }
];

// Conversion factors for oxides to elements
const OXIDE_CONVERSIONS = {
  P2O5_to_P: 0.43646,
  K2O_to_K: 0.83013,
  CaO_to_Ca: 0.71469,
  MgO_to_Mg: 0.60317,
  SO3_to_S: 0.40059,
  SiO2_to_Si: 0.46744,
  SiOH4_to_Si: 0.2922  // Si(OH)4 orthosilicic acid to elemental Si
};

// Molar masses for nutrients (g/mol) - for EC calculation
const MOLAR_MASSES = {
  'N_NO3': 14.007,
  'N_NH4': 14.007,
  'P': 30.974,
  'K': 39.098,
  'Mg': 24.305,
  'Ca': 40.078,
  'S': 32.065,
  'Fe': 55.845,
  'Mn': 54.938,
  'Zn': 65.38,
  'B': 10.811,
  'Cu': 63.546,
  'Mo': 95.95,
  'Na': 22.99,
  'Cl': 35.453
};

// Ionic charges (absolute values) - for EC calculation
const IONIC_CHARGES = {
  'N_NO3': 1,
  'N_NH4': 1,
  'P': 1,      // H2PO4- form
  'K': 1,
  'Mg': 2,
  'Ca': 2,
  'S': 2,      // SO4 2- form
  'Fe': 2,
  'Mn': 2,
  'Zn': 2,
  'B': 1,      // typically present as borate
  'Cu': 2,
  'Mo': 2,
  'Na': 1,
  'Cl': 1
};

// EC contribution factors - LEGACY, kept for backward compatibility
// Units: S·cm²/mol (molar conductivity)
const EC_CONTRIBUTIONS = {
  'N_NO3': 71.46,
  'N_NH4': 73.5,
  'P': 57,         // H2PO4-
  'K': 73,
  'Mg': 106,
  'Ca': 119,
  'S': 160,        // SO4 2-
  'Fe': 108.0,
  'Mn': 0,         // negligible
  'Zn': 0,         // negligible
  'B': 0,          // negligible
  'Cu': 0,         // negligible
  'Mo': 76.35,
  'Na': 50.01,
  'Cl': 0
};

// ============================================================================
// NEW EC ESTIMATION MODEL - Ionic Molar Conductivity at Infinite Dilution (25°C)
// ============================================================================
// λ (lambda) values in S·cm²/mol at 25°C
// Formula: EC (mS/cm) = 0.001 × Σ(λᵢ × cᵢ) where cᵢ is in mmol/L
const IONIC_MOLAR_CONDUCTIVITY = {
  // CATIONS
  'K+': 73.5,
  'Na+': 50.1,
  'NH4+': 73.5,
  'Ca2+': 119.0,
  'Mg2+': 106.0,
  'Fe2+': 108.0,
  'Fe3+': 204.0,
  'Mn2+': 107.0,
  'Zn2+': 105.6,
  'Cu2+': 107.2,
  // ANIONS
  'NO3-': 71.5,
  'Cl-': 76.3,
  'SO4^2-': 160.0,
  'H2PO4-': 33.5,
  'HPO4^2-': 114.0,
  'HCO3-': 44.5,
  'OH-': 198.0,
  'H+': 349.8
};

// Ionic charges for EC calculation
const ION_CHARGES = {
  'K+': 1,
  'Na+': 1,
  'NH4+': 1,
  'Ca2+': 2,
  'Mg2+': 2,
  'Fe2+': 2,
  'Fe3+': 3,
  'Mn2+': 2,
  'Zn2+': 2,
  'Cu2+': 2,
  'NO3-': 1,
  'Cl-': 1,
  'SO4^2-': 2,
  'H2PO4-': 1,
  'HPO4^2-': 2,
  'HCO3-': 1,
  'OH-': 1,
  'H+': 1
};

/**
 * Estimate EC from ion concentrations using the sum of ionic molar conductivities model.
 *
 * @param {Object} ions_mmolL - Ion concentrations in mmol/L, e.g., { 'K+': 4.0, 'Ca2+': 3.0, 'NO3-': 7.0 }
 * @param {Object} options - Optional settings
 * @param {number} options.temperatureC - Temperature in Celsius (default 25). Applies 2%/°C correction.
 * @param {boolean} options.applyIonicStrengthCorrection - Apply non-ideality correction (default true)
 * @param {number} options.ionicStrengthK - Dampening factor for ionic strength correction (default 0.5)
 * @returns {Object} { ec_mS_cm, ec_at_temp, ionicStrength, contributions, temperatureC }
 */
function estimateEC(ions_mmolL, options = {}) {
  const {
    temperatureC = 25,
    applyIonicStrengthCorrection = true,
    ionicStrengthK = 0.5  // Tunable dampening factor
  } = options;

  // Calculate raw EC at 25°C and per-ion contributions
  let ec_raw = 0;
  const contributions = {};

  for (const [ion, c_mmolL] of Object.entries(ions_mmolL)) {
    if (IONIC_MOLAR_CONDUCTIVITY[ion] && c_mmolL > 0) {
      // EC (mS/cm) = 0.001 × λᵢ × cᵢ (mmol/L)
      const contrib = 0.001 * IONIC_MOLAR_CONDUCTIVITY[ion] * c_mmolL;
      contributions[ion] = {
        concentration_mmolL: c_mmolL,
        lambda: IONIC_MOLAR_CONDUCTIVITY[ion],
        contribution_mS_cm: contrib
      };
      ec_raw += contrib;
    }
  }

  // Calculate ionic strength: I = 0.5 × Σ(cᵢ × zᵢ²) where cᵢ is in mol/L
  let ionicStrength = 0;
  for (const [ion, c_mmolL] of Object.entries(ions_mmolL)) {
    if (ION_CHARGES[ion] && c_mmolL > 0) {
      const c_molL = c_mmolL / 1000;  // Convert mmol/L to mol/L
      const z = ION_CHARGES[ion];
      ionicStrength += c_molL * z * z;
    }
  }
  ionicStrength = ionicStrength / 2;

  // Apply ionic strength correction (non-ideality at real concentrations)
  // ec_corrected = ec_raw / (1 + k × √I)
  let ec_25 = ec_raw;
  if (applyIonicStrengthCorrection && ionicStrength > 0) {
    ec_25 = ec_raw / (1 + ionicStrengthK * Math.sqrt(ionicStrength));
  }

  // Apply temperature correction: 2% per °C deviation from 25°C
  // ec_T = ec_25 × (1 + 0.02 × (T - 25))
  const tempCorrectionFactor = 1 + 0.02 * (temperatureC - 25);
  const ec_at_temp = ec_25 * tempCorrectionFactor;

  return {
    ec_mS_cm: ec_25,           // EC at 25°C (standard)
    ec_at_temp: ec_at_temp,    // EC at specified temperature
    ionicStrength: ionicStrength,
    contributions: contributions,
    temperatureC: temperatureC,
    rawEC: ec_raw,             // Before ionic strength correction
    correctionApplied: applyIonicStrengthCorrection
  };
}

/**
 * Convert PPM results to ion concentrations in mmol/L for EC estimation.
 * Maps nutrient PPM values to their ionic forms.
 *
 * @param {Object} ppmResults - PPM values from the calculator, e.g., { N_NO3: 150, Ca: 100, ... }
 * @returns {Object} Ion concentrations in mmol/L
 */
function ppmToIonsForEC(ppmResults) {
  const ions_mmolL = {};

  // Nitrogen forms
  if (ppmResults.N_NO3 > 0) {
    // NO3- ion: PPM of N → mmol/L of NO3-
    // N has molar mass 14.007 g/mol
    ions_mmolL['NO3-'] = ppmResults.N_NO3 / 14.007;
  }
  if (ppmResults.N_NH4 > 0) {
    // NH4+ ion: PPM of N → mmol/L of NH4+
    ions_mmolL['NH4+'] = ppmResults.N_NH4 / 14.007;
  }

  // Phosphorus as H2PO4- (dominant form at pH 5.5-6.5)
  if (ppmResults.P > 0) {
    ions_mmolL['H2PO4-'] = ppmResults.P / 30.974;
  }

  // Potassium as K+
  if (ppmResults.K > 0) {
    ions_mmolL['K+'] = ppmResults.K / 39.098;
  }

  // Calcium as Ca2+
  if (ppmResults.Ca > 0) {
    ions_mmolL['Ca2+'] = ppmResults.Ca / 40.078;
  }

  // Magnesium as Mg2+
  if (ppmResults.Mg > 0) {
    ions_mmolL['Mg2+'] = ppmResults.Mg / 24.305;
  }

  // Sulfur as SO4^2-
  if (ppmResults.S > 0) {
    ions_mmolL['SO4^2-'] = ppmResults.S / 32.065;
  }

  // Sodium as Na+ (if present)
  if (ppmResults.Na > 0) {
    ions_mmolL['Na+'] = ppmResults.Na / 22.99;
  }

  // Chloride as Cl- (if present)
  if (ppmResults.Cl > 0) {
    ions_mmolL['Cl-'] = ppmResults.Cl / 35.453;
  }

  // Iron as Fe2+ (assume ferrous for most fertigation)
  if (ppmResults.Fe > 0) {
    ions_mmolL['Fe2+'] = ppmResults.Fe / 55.845;
  }

  // Manganese as Mn2+
  if (ppmResults.Mn > 0) {
    ions_mmolL['Mn2+'] = ppmResults.Mn / 54.938;
  }

  // Zinc as Zn2+
  if (ppmResults.Zn > 0) {
    ions_mmolL['Zn2+'] = ppmResults.Zn / 65.38;
  }

  // Copper as Cu2+
  if (ppmResults.Cu > 0) {
    ions_mmolL['Cu2+'] = ppmResults.Cu / 63.546;
  }

  return ions_mmolL;
}

/**
 * Estimate EC from PPM results (convenience wrapper)
 * @param {Object} ppmResults - PPM values from the calculator
 * @param {Object} options - Options passed to estimateEC
 * @returns {Object} EC estimation results
 */
function estimateECFromPPM(ppmResults, options = {}) {
  const ions_mmolL = ppmToIonsForEC(ppmResults);
  return estimateEC(ions_mmolL, options);
}

// Ion balance data: molar mass and ions for each fertilizer
// Format: {formula: 'chemical formula', ion: 'name', charge: number (absolute value), count: number, type: 'cation'|'anion'}
const ION_DATA = {
  potassium_nitrate_typical: {
    formula: 'KNO₃',
    molarMass: 101.1,
    ions: [
      {ion: 'K⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  map_typical: {
    formula: 'NH₄H₂PO₄',
    molarMass: 115,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'H₂PO₄⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  mkp_typical: {
    formula: 'KH₂PO₄',
    molarMass: 136.1,
    ions: [
      {ion: 'K⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'H₂PO₄⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  dap_common: {
    formula: '(NH₄)₂HPO₄',
    molarMass: 132.1,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'HPO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  ammonium_sulfate_common: {
    formula: '(NH₄)₂SO₄',
    molarMass: 132.14,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  ammonium_nitrate_common: {
    formula: 'NH₄NO₃',
    molarMass: 80,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  ammonium_nitrate_liquid: {
    formula: 'NH₄NO₃',
    molarMass: 80,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  magnesium_sulfate_heptahydrate_common: {
    formula: 'MgSO₄·7H₂O',
    molarMass: 246.47,
    ions: [
      {ion: 'Mg²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  magnesium_sulfate_anhydrous: {
    formula: 'MgSO₄',
    molarMass: 120.37,
    ions: [
      {ion: 'Mg²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  magnesium_nitrate_hexahydrate_typical: {
    formula: 'Mg(NO₃)₂·6H₂O',
    molarMass: 256,
    ions: [
      {ion: 'Mg²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  magnesium_nitrate_liquid: {
    formula: 'Mg(NO₃)₂',
    molarMass: 148.3,
    ions: [
      {ion: 'Mg²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  potassium_sulfate_common: {
    formula: 'K₂SO₄',
    molarMass: 174.3,
    ions: [
      {ion: 'K⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  potassium_chloride_common: {
    formula: 'KCl',
    molarMass: 74.6,
    ions: [
      {ion: 'K⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'Cl⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  calcium_nitrate_calcinit_typical: {
    formula: '5Ca(NO₃)₂·NH₄NO₃·10H₂O',
    molarMass: 1080,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 5, type: 'cation'},
      {ion: 'NH₄⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 11, type: 'anion'}
    ]
  },
  calcium_nitrate_4h2o: {
    formula: 'Ca(NO₃)₂·4H₂O',
    molarMass: 236.18,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  calcium_nitrate_anhydrous: {
    formula: 'Ca(NO₃)₂',
    molarMass: 164.1,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  calcium_chloride_dihydrate_common: {
    formula: 'CaCl₂·2H₂O',
    molarMass: 147,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'Cl⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  calcium_chloride_solid: {
    formula: 'CaCl₂',
    molarMass: 111,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'Cl⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  nitric_acid_38: {
    formula: 'HNO₃',
    molarMass: 167,
    ions: [
      {ion: 'NO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  nitric_acid_60: {
    formula: 'HNO₃',
    molarMass: 105,
    ions: [
      {ion: 'NO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  phosphoric_acid_49: {
    formula: 'H₃PO₄',
    molarMass: 167,
    ions: [
      {ion: 'H₂PO₄⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  calcium_nitrate_liquid: {
    formula: 'Ca(NO₃)₂',
    molarMass: 164.1,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  calcium_chloride_liquid: {
    formula: 'CaCl₂',
    molarMass: 111,
    ions: [
      {ion: 'Ca²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'Cl⁻', charge: 1, count: 2, type: 'anion'}
    ]
  },
  langbeinite_common: {
    formula: 'K₂Mg₂(SO₄)₃',
    molarMass: 415,
    ions: [
      {ion: 'K⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'Mg²⁺', charge: 2, count: 2, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 3, type: 'anion'}
    ]
  },
  ammonium_thiosulfate_common: {
    formula: '(NH₄)₂S₂O₃',
    molarMass: 148.2,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'S₂O₃²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  potassium_thiosulfate_common: {
    formula: 'K₂S₂O₃',
    molarMass: 190.3,
    ions: [
      {ion: 'K⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'S₂O₃²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  potassium_bicarbonate: {
    formula: 'KHCO₃',
    molarMass: 100.1,
    ions: [
      {ion: 'K⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'HCO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  urea_phosphate: {
    formula: 'CO(NH₂)₂·H₃PO₄',
    molarMass: 158.1,
    ions: [
      {ion: 'H₂PO₄⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  manganese_sulfate: {
    formula: 'MnSO₄',
    molarMass: 169,
    ions: [
      {ion: 'Mn²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  zinc_sulfate_heptahydrate_common: {
    formula: 'ZnSO₄·7H₂O',
    molarMass: 287.6,
    ions: [
      {ion: 'Zn²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  zinc_sulfate_mono: {
    molarMass: 179.5,
    ions: [
      {ion: 'Zn²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  copper_sulfate: {
    molarMass: 249.7,
    ions: [
      {ion: 'Cu²⁺', charge: 2, count: 1, type: 'cation'},
      {ion: 'SO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  sodium_molybdate: {
    molarMass: 241.9,
    ions: [
      {ion: 'Na⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'MoO₄²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  ammonium_molybdate: {
    molarMass: 1235.9,
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 6, type: 'cation'},
      {ion: 'Mo₇O₂₄⁶⁻', charge: 6, count: 1, type: 'anion'}
    ]
  },
  uan32_solution_typical: {
    // UAN-32 contains urea (non-ionic) + ammonium nitrate (ionic)
    // Only accounting for the ammonium nitrate portion (50% of N)
    molarMass: 160,  // Effective based on ionic portion
    ions: [
      {ion: 'NH₄⁺', charge: 1, count: 1, type: 'cation'},
      {ion: 'NO₃⁻', charge: 1, count: 1, type: 'anion'}
    ]
  },
  borax: {
    molarMass: 381.4,
    ions: [
      {ion: 'Na⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'B₄O₇²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  },
  potassium_silicate_liquid_typical: {
    molarMass: 154.3,  // K2SiO3
    ions: [
      {ion: 'K⁺', charge: 1, count: 2, type: 'cation'},
      {ion: 'SiO₃²⁻', charge: 2, count: 1, type: 'anion'}
    ]
  }
};

// Common fertilizers (most frequently used)
const COMMON_FERTILIZERS = [
  'calcium_nitrate_calcinit_typical',
  'potassium_nitrate_typical',
  'map_typical',
  'mkp_typical',
  'magnesium_sulfate_heptahydrate_common'
];

// Fertilizer compatibility groups for two-tank system
// Main incompatibility: Calcium + Sulfate = Calcium Sulfate (gypsum) precipitation
// Also: Calcium + Phosphate at high concentrations can precipitate
const FERTILIZER_COMPATIBILITY = {
  // Fertilizers containing Calcium (Tank A candidates)
  calcium_sources: [
    'calcium_nitrate_calcinit_typical',
    'calcium_nitrate_4h2o',
    'calcium_nitrate_anhydrous',
    'calcium_nitrate_liquid',
    'calcium_chloride_dihydrate_common',
    'calcium_chloride_solid',
    'calcium_chloride_liquid'
  ],
  // Fertilizers containing Sulfate (Tank B candidates)
  sulfate_sources: [
    'magnesium_sulfate_heptahydrate_common',
    'magnesium_sulfate_anhydrous',
    'potassium_sulfate_common',
    'ammonium_sulfate_common',
    'langbeinite_common',
    'ammonium_thiosulfate_common',
    'potassium_thiosulfate_common',
    'manganese_sulfate',
    'zinc_sulfate_heptahydrate_common',
    'zinc_sulfate_mono',
    'copper_sulfate'
  ],
  // Fertilizers containing Phosphate (can go with sulfates, caution with calcium at high conc)
  phosphate_sources: [
    'map_typical',
    'mkp_typical',
    'dap_common',
    'ssp_typical',
    'phosphoric_acid_49',
    'urea_phosphate'
  ],
  // Silicate sources (Tank B - incompatible with calcium, alkaline pH)
  silicate_sources: [
    'potassium_silicate_liquid_typical'
  ],
  // Neutral fertilizers (compatible with both tanks)
  neutral: [
    'potassium_nitrate_typical',
    'magnesium_nitrate_hexahydrate_typical',
    'magnesium_nitrate_liquid',
    'ammonium_nitrate_common',
    'ammonium_nitrate_liquid',
    'potassium_chloride_common',
    'nitric_acid_38',
    'nitric_acid_60',
    'urea_common',
    'urea_liquid',
    'uan32_solution_typical',
    'potassium_bicarbonate',
    'boric_acid_common',
    'borax',
    'sodium_molybdate',
    'ammonium_molybdate'
  ]
};

// Helper function to check if a fertilizer contains calcium
function hasCaContent(fertId) {
  const fert = FERTILIZERS.find(f => f.id === fertId);
  return fert && fert.pct && fert.pct.Ca > 0;
}

// Helper function to check if a fertilizer contains sulfate
function hasSulfateContent(fertId) {
  const fert = FERTILIZERS.find(f => f.id === fertId);
  return fert && fert.pct && fert.pct.S > 0;
}

// Helper function to check if a fertilizer contains phosphate
function hasPhosphateContent(fertId) {
  const fert = FERTILIZERS.find(f => f.id === fertId);
  return fert && fert.pct && (fert.pct.P2O5 > 0 || fert.pct.P > 0);
}

// Helper function to check if a fertilizer contains silicate (incompatible with calcium)
function hasSilicateContent(fertId) {
  const fert = FERTILIZERS.find(f => f.id === fertId);
  return fert && fert.pct && (fert.pct.SiO2 > 0 || fert.pct.SiOH4 > 0 || fert.pct.Si > 0);
}

// Validation functions
function validateVolumeInput(input) {
  const value = parseFloat(input.value);

  // Remove error class first
  input.classList.remove('input-error');

  // Check for invalid values
  if (input.value !== '' && (isNaN(value) || value <= 0)) {
    input.classList.add('input-error');
    // Reset to minimum valid value if user tries to leave field
    if (value <= 0) {
      input.value = 0.1;
    }
  }

  // Auto-recalculate if results are showing
  if (document.getElementById('results') && document.getElementById('results').style.display !== 'none') {
    const validValue = parseFloat(input.value);
    if (!isNaN(validValue) && validValue > 0) {
      calculate();
    }
  }
}

function validateGramsInput(input) {
  const value = parseFloat(input.value);

  // Remove error class first
  input.classList.remove('input-error');

  // Check for negative values
  if (input.value !== '' && (isNaN(value) || value < 0)) {
    input.classList.add('input-error');
    // Reset to 0 for negative values
    if (value < 0) {
      input.value = 0;
    }
  }
}

function validateTargetInput(input, allowZero = false) {
  const value = parseFloat(input.value);

  // Remove error class first
  input.classList.remove('input-error');

  // Check for invalid values
  if (input.value !== '') {
    if (isNaN(value) || value < 0) {
      input.classList.add('input-error');
      if (value < 0) {
        input.value = allowZero ? 0 : 0.1;
      }
    } else if (!allowZero && value === 0) {
      input.classList.add('input-error');
    }
  }
}

// Initialize the page
function init() {
  renderFertilizerList();
  renderAvailableFertilizersList();
  renderReverseFertilizersList();

  // Add event listeners
  document.getElementById('search').addEventListener('input', filterFertilizers);
}

// Render available fertilizers list for formula builder
function renderAvailableFertilizersList() {
  const container = document.getElementById('available-fertilizers-list');
  container.innerHTML = '';

  FERTILIZERS.forEach(fert => {
    const item = document.createElement('div');
    item.className = 'fertilizer-checkbox-item';
    item.id = `available-item-${fert.id}`;

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `available-${fert.id}`;
    checkbox.checked = COMMON_FERTILIZERS.includes(fert.id); // Pre-select common fertilizers

    const label = document.createElement('label');
    label.htmlFor = `available-${fert.id}`;

    const nameSpan = document.createElement('span');
    nameSpan.className = 'fertilizer-label-name';
    nameSpan.textContent = fert.name;
    label.appendChild(nameSpan);

    if (fert.aliases && fert.aliases.length > 0) {
      const aliasSpan = document.createElement('span');
      aliasSpan.className = 'fertilizer-label-aliases';
      aliasSpan.textContent = fert.aliases.join(', ');
      label.appendChild(aliasSpan);
    }

    item.appendChild(checkbox);
    item.appendChild(label);
    container.appendChild(item);
  });
}

// Select all available fertilizers
function selectAllAvailableFertilizers() {
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`available-${fert.id}`);
    if (checkbox) checkbox.checked = true;
  });
}

// Deselect all available fertilizers
function deselectAllAvailableFertilizers() {
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`available-${fert.id}`);
    if (checkbox) checkbox.checked = false;
  });
}

// Select only common fertilizers
function selectCommonFertilizers() {
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`available-${fert.id}`);
    if (checkbox) {
      checkbox.checked = COMMON_FERTILIZERS.includes(fert.id);
    }
  });
}

// Filter available fertilizers based on search term
function filterAvailableFertilizers(searchTerm) {
  const normalizedSearch = searchTerm.toLowerCase().trim();

  FERTILIZERS.forEach(fert => {
    const item = document.getElementById(`available-item-${fert.id}`);
    if (!item) return;

    // Search in name and aliases
    const nameMatch = fert.name.toLowerCase().includes(normalizedSearch);
    const aliasMatch = fert.aliases && fert.aliases.some(alias =>
      alias.toLowerCase().includes(normalizedSearch)
    );

    // Show/hide based on match
    if (nameMatch || aliasMatch || normalizedSearch === '') {
      item.style.display = '';
    } else {
      item.style.display = 'none';
    }
  });
}

// Render the fertilizer list
function renderFertilizerList(filter = '') {
  const container = document.getElementById('fertilizer-list');

  // If list is empty, create all items first
  if (container.children.length === 0) {
    FERTILIZERS.forEach(fertilizer => {
      const item = document.createElement('div');
      item.className = 'fertilizer-item';
      item.id = `fert-${fertilizer.id}`;
      item.dataset.fertId = fertilizer.id;

      const composition = Object.entries(fertilizer.pct)
        .map(([key, val]) => `${key}: ${val}%`)
        .join(', ');

      item.innerHTML = `
        <div class="fertilizer-checkbox">
          <input type="checkbox" id="check-${fertilizer.id}"
                 onchange="toggleFertilizer('${fertilizer.id}')">
        </div>
        <label for="check-${fertilizer.id}" class="fertilizer-info">
          <div class="fertilizer-name">${fertilizer.name}</div>
          <div class="fertilizer-composition">${composition}</div>
        </label>
        <div class="fertilizer-input">
          <input type="number" id="grams-${fertilizer.id}"
                 value="0" min="0" step="0.1"
                 disabled
                 oninput="validateGramsInput(this)"
                 onchange="handleGramsChange('${fertilizer.id}')">
          <label>grams</label>
        </div>
      `;

      container.appendChild(item);
    });
  }

  // Filter by showing/hiding items
  const searchText = filter.toLowerCase();
  FERTILIZERS.forEach(fertilizer => {
    const item = document.getElementById(`fert-${fertilizer.id}`);
    if (item) {
      const matches = fertilizer.name.toLowerCase().includes(searchText) ||
                     fertilizer.aliases.some(a => a.toLowerCase().includes(searchText));
      item.style.display = matches ? '' : 'none';
    }
  });
}

// Filter fertilizers based on search
function filterFertilizers() {
  const search = document.getElementById('search').value;
  renderFertilizerList(search);
}

// Toggle fertilizer selection
function toggleFertilizer(id) {
  const checkbox = document.getElementById(`check-${id}`);
  const input = document.getElementById(`grams-${id}`);
  const item = document.getElementById(`fert-${id}`);

  if (checkbox.checked) {
    input.disabled = false;
    item.classList.add('active');
  } else {
    input.disabled = true;
    input.value = 0;
    item.classList.remove('active');
  }

  // Auto-calculate if results are showing
  if (document.getElementById('results').style.display !== 'none') {
    calculate();
  }
}

// Handle grams input change
function handleGramsChange(id) {
  if (document.getElementById('results').style.display !== 'none') {
    calculate();
  }
}

// Calculate EC using ionic molar conductivity model
function calculateECTDS(results) {
  // Calculate ionic strength
  let ionicStrength = 0;

  for (const [nutrient, ppm] of Object.entries(results)) {
    if (MOLAR_MASSES[nutrient] && IONIC_CHARGES[nutrient]) {
      const molarConc = ppm / (1000 * MOLAR_MASSES[nutrient]); // Convert ppm to mol/L
      const zi = IONIC_CHARGES[nutrient];
      ionicStrength += zi * zi * molarConc;
    }
  }
  ionicStrength = ionicStrength / 2; // Ionic strength formula

  // Calculate EC using ionic molar conductivity
  // Result is directly in mS/cm (EC contribution factors are calibrated for this)
  let predictedEC = 0;

  for (const [nutrient, ppm] of Object.entries(results)) {
    if (EC_CONTRIBUTIONS[nutrient] && MOLAR_MASSES[nutrient] && IONIC_CHARGES[nutrient]) {
      const molarConc = ppm / (1000 * MOLAR_MASSES[nutrient]);
      const zi = IONIC_CHARGES[nutrient];
      const contribution = molarConc * EC_CONTRIBUTIONS[nutrient] * Math.exp(-0.7025187 * Math.sqrt(ionicStrength) * Math.pow(zi, 1.5));
      predictedEC += contribution;
    }
  }

  return {
    ec: predictedEC,
    ionicStrength: ionicStrength
  };
}

// Check for warnings (incompatibilities and imbalances)
function checkWarnings(results, activeFertilizers, ionBalance = null) {
  const warnings = [];

  // Extract common values
  const ca = results.Ca || 0;
  const mg = results.Mg || 0;
  const k = results.K || 0;
  const p = results.P || 0;
  const s = results.S || 0;
  const si = results.Si || 0;
  const cl = results.Cl || 0;
  const na = results.Na || 0;
  const fe = results.Fe || 0;
  const mn = results.Mn || 0;
  const zn = results.Zn || 0;
  const cu = results.Cu || 0;
  const b = results.B || 0;
  const mo = results.Mo || 0;
  const nh4 = results.N_NH4 || 0;
  const no3 = results.N_NO3 || 0;
  const totalN = nh4 + no3;

  // ============================================================================
  // SECTION A: STOCK SOLUTION / MIXING COMPATIBILITY (HARD warnings)
  // ============================================================================

  // 1. Calcium + Sulfate incompatibility (in stock solutions)
  if (ca > 10 && s > 10) {
    const caFertilizers = activeFertilizers.filter(f => f.pct && f.pct.Ca).map(f => f.name).join(', ');
    const sFertilizers = activeFertilizers.filter(f => f.pct && f.pct.S).map(f => f.name).join(', ');
    warnings.push({
      level: 'warning',
      category: 'Stock Solution: Ca + Sulfate',
      message: `Calcium and sulfate are both present. When making STOCK SOLUTIONS, keep calcium sources (${caFertilizers || 'calcium fertilizers'}) separate from sulfate sources (${sFertilizers || 'sulfate fertilizers'}) to prevent calcium sulfate precipitation (gypsum). This warning doesn't apply to the final diluted nutrient solution.`
    });
  }

  // 8. Calcium + Phosphate incompatibility (Ca-P precipitate)
  if (ca > 10 && p > 10) {
    const caFertilizers = activeFertilizers.filter(f => f.pct && f.pct.Ca).map(f => f.name).join(', ');
    const pFertilizers = activeFertilizers.filter(f => f.pct && (f.pct.P || f.pct.P2O5)).map(f => f.name).join(', ');
    warnings.push({
      level: 'warning',
      category: 'Stock Solution: Ca + Phosphate',
      message: `Calcium (${ca.toFixed(1)} ppm) and phosphate (${p.toFixed(1)} ppm P) are both present. When making STOCK SOLUTIONS, keep calcium sources (${caFertilizers || 'calcium fertilizers'}) in Tank A and phosphate sources (${pFertilizers || 'phosphate fertilizers'}) in Tank B to prevent calcium phosphate precipitation.`
    });
  }

  // 9. Calcium + Silicate incompatibility (Ca-silicate gel/scale)
  if (ca > 10 && si > 10) {
    warnings.push({
      level: 'warning',
      category: 'Stock Solution: Ca + Silicate',
      message: `Calcium (${ca.toFixed(1)} ppm) and silicate (${si.toFixed(1)} ppm Si) are both present. When making STOCK SOLUTIONS, keep calcium and potassium silicate in separate concentrates to prevent calcium silicate gel/scale formation. Often silicate needs its own tank or sequential dosing.`
    });
  }

  // ============================================================================
  // SECTION B: NITROGEN / AMMONIUM BALANCE
  // ============================================================================

  // 2. High NH4 ratio (>30% - HARD warning)
  if (totalN > 0) {
    const nh4Ratio = (nh4 / totalN) * 100;
    if (nh4Ratio > 30) {
      warnings.push({
        level: 'warning',
        category: 'High Ammonium',
        message: `High ammonium ratio (${nh4Ratio.toFixed(1)}% NH₄⁺). Recommended: Keep NH₄⁺ below 20-30% of total N to avoid toxicity and root zone acidification. Consider using more nitrate-based fertilizers.`
      });
    }
  }

  // 12. Zero Ammonium (SOFT warning - optional guidance)
  if (totalN > 0 && nh4 === 0) {
    warnings.push({
      level: 'info',
      category: 'Zero Ammonium',
      message: `No ammonium nitrogen in formula. A small NH₄⁺ share (5-15% of total N) can help with nutrient uptake and provide mild acidifying effect. This is optional—0% NH₄⁺ works fine if pH and media are managed.`
    });
  }

  // 13. Very Low Ammonium (<3% - SOFT warning)
  if (totalN > 0 && nh4 > 0) {
    const nh4Ratio = (nh4 / totalN) * 100;
    if (nh4Ratio < 3) {
      warnings.push({
        level: 'info',
        category: 'Very Low Ammonium',
        message: `Very low ammonium ratio (${nh4Ratio.toFixed(1)}% NH₄⁺). Consider increasing to 5-15% of total N for better uptake behavior and mild acidifying effect. This is optional guidance.`
      });
    }
  }

  // ============================================================================
  // SECTION C: NUTRIENT PRESENCE CHECKS (important for RO water)
  // ============================================================================

  // 14. Missing Calcium baseline
  if (ca < 20 && totalN > 0) {
    warnings.push({
      level: 'info',
      category: 'Low Calcium',
      message: `Calcium is low (${ca.toFixed(1)} ppm). RO/soft water often needs intentional Ca supply. Typical hydroponic feeds target 40-120 ppm Ca depending on crop and system.`
    });
  }

  // 15. Missing Magnesium baseline
  if (mg < 10 && totalN > 0) {
    warnings.push({
      level: 'info',
      category: 'Low Magnesium',
      message: `Magnesium is low (${mg.toFixed(1)} ppm). RO/soft water often needs Mg added. Common targets are 15-50 ppm Mg depending on crop and system.`
    });
  }

  // 16. Micronutrients missing (sanity check for complete feeds)
  if (totalN > 0) {
    const missingMicros = [];
    if (fe === 0) missingMicros.push('Fe');
    if (b === 0) missingMicros.push('B');
    if (mn === 0) missingMicros.push('Mn');
    if (zn === 0) missingMicros.push('Zn');
    if (cu === 0) missingMicros.push('Cu');
    if (mo === 0) missingMicros.push('Mo');

    if (missingMicros.length > 0) {
      warnings.push({
        level: 'info',
        category: 'Missing Micronutrients',
        message: `Missing micronutrients: ${missingMicros.join(', ')}. If formulating a complete feed, ensure all essential micros are included. Ignore if using a separate micro mix.`
      });
    }
  }

  // ============================================================================
  // SECTION D: RATIO / ANTAGONISM RULES (SOFT warnings)
  // ============================================================================

  // 3. Ca:Mg ratio (optimal is 3:1 to 5:1)
  if (ca > 10 && mg > 5) {
    const ratio = ca / mg;
    if (ratio < 2) {
      warnings.push({
        level: 'info',
        category: 'Ca:Mg Ratio',
        message: `Ca:Mg ratio is ${ratio.toFixed(2)}:1 (${ca.toFixed(1)} ppm Ca : ${mg.toFixed(1)} ppm Mg). Optimal range is 3:1 to 5:1. Consider reducing magnesium or increasing calcium.`
      });
    } else if (ratio > 7) {
      warnings.push({
        level: 'info',
        category: 'Ca:Mg Ratio',
        message: `Ca:Mg ratio is ${ratio.toFixed(2)}:1 (${ca.toFixed(1)} ppm Ca : ${mg.toFixed(1)} ppm Mg). Optimal range is 3:1 to 5:1. Consider reducing calcium or increasing magnesium.`
      });
    }
  }

  // 4. K:Ca ratio (should be reasonably balanced)
  if (k > 10 && ca > 10) {
    const kCaRatio = k / ca;
    if (kCaRatio > 3) {
      warnings.push({
        level: 'info',
        category: 'K:Ca Ratio',
        message: `K:Ca ratio is ${kCaRatio.toFixed(2)}:1. Very high potassium relative to calcium may interfere with calcium uptake. Optimal K:Ca ratio is typically 0.5:1 to 2:1 depending on crop.`
      });
    }
  }

  // 17. K:Mg antagonism risk
  if (k > 10 && mg > 5) {
    const kMgRatio = k / mg;
    if (kMgRatio > 6) {
      warnings.push({
        level: 'info',
        category: 'K:Mg Ratio',
        message: `K:Mg ratio is ${kMgRatio.toFixed(2)}:1 (${k.toFixed(1)} ppm K : ${mg.toFixed(1)} ppm Mg). Optimal range is 2:1 to 4:1. Too much K can suppress Mg uptake, causing Mg deficiency symptoms.`
      });
    } else if (kMgRatio < 1.5) {
      warnings.push({
        level: 'info',
        category: 'K:Mg Ratio',
        message: `K:Mg ratio is ${kMgRatio.toFixed(2)}:1 (${k.toFixed(1)} ppm K : ${mg.toFixed(1)} ppm Mg). Optimal range is 2:1 to 4:1. Low K relative to Mg may limit growth and quality.`
      });
    }
  }

  // 18. (Ca + Mg):K balance
  if (k > 10 && (ca + mg) > 10) {
    const caMgSum = ca + mg;
    if (k > caMgSum * 1.5) {
      warnings.push({
        level: 'info',
        category: '(Ca+Mg):K Balance',
        message: `Potassium (${k.toFixed(1)} ppm) is high relative to Ca+Mg (${caMgSum.toFixed(1)} ppm). Excess K vs Ca+Mg increases risk of Ca/Mg deficiencies even when totals look adequate. Consider balancing.`
      });
    }
  }

  // 19. N:K ratio (vegetative vs generative style)
  if (totalN > 0 && k > 0) {
    const nkRatio = totalN / k;
    warnings.push({
      level: 'info',
      category: 'N:K Ratio',
      message: `N:K ratio is 1:${(k/totalN).toFixed(2)} (${totalN.toFixed(1)} ppm N : ${k.toFixed(1)} ppm K). Vegetative feeds typically use N:K ~ 1:1 to 1:1.5; flowering/fruiting feeds use N:K ~ 1:1.5 to 1:2+. Adjust based on growth stage.`
    });
  }

  // ============================================================================
  // SECTION E: TOXICITY / UNDESIRABLE IONS
  // ============================================================================

  // 5. EC levels (high and low)
  const ecData = calculateECTDS(results);
  if (ecData.ec > 3.5) {
    warnings.push({
      level: 'warning',
      category: 'High EC',
      message: `Electrical conductivity is very high (${ecData.ec.toFixed(2)} mS/cm). This may cause salt stress in plants. Consider reducing fertilizer amounts or increasing solution volume. Most crops prefer EC between 1.5-2.5 mS/cm.`
    });
  } else if (ecData.ec < 0.5 && totalN > 0) {
    warnings.push({
      level: 'info',
      category: 'Low EC',
      message: `Electrical conductivity is quite low (${ecData.ec.toFixed(2)} mS/cm). This solution may be too dilute for optimal plant growth. Consider increasing fertilizer amounts. Most crops prefer EC between 1.5-2.5 mS/cm.`
    });
  }

  // 6. High Chloride
  if (cl > 100) {
    warnings.push({
      level: 'warning',
      category: 'High Chloride',
      message: `Chloride level is ${cl.toFixed(1)} ppm. High chloride (>100 ppm) can be toxic to sensitive crops. Consider using sulfate-based fertilizers instead of chloride-based ones.`
    });
  }

  // 20. High Sodium
  if (na > 50) {
    const severity = na > 100 ? 'warning' : 'info';
    warnings.push({
      level: severity,
      category: 'High Sodium',
      message: `Sodium level is ${na.toFixed(1)} ppm. ${na > 100 ? 'This is very high!' : ''} Sodium can accumulate and compete with K/Ca/Mg uptake. Keep Na as low as possible, ideally <50 ppm.`
    });
  }

  // 21. High Boron (narrow safe window)
  if (b > 0.5) {
    const severity = b > 1.0 ? 'warning' : 'info';
    warnings.push({
      level: severity,
      category: 'High Boron',
      message: `Boron level is ${b.toFixed(2)} ppm. ${b > 1.0 ? 'This may cause toxicity!' : 'This is on the high end.'} Boron has a narrow safe window (typically 0.2-0.5 ppm). Many crops show toxicity not far above sufficiency levels.`
    });
  }

  // 22. High Cu/Zn/Mn (micros can go toxic fast)
  if (cu > 0.1) {
    warnings.push({
      level: cu > 0.2 ? 'warning' : 'info',
      category: 'High Copper',
      message: `Copper level is ${cu.toFixed(2)} ppm. ${cu > 0.2 ? 'This may cause toxicity!' : 'This is on the high end.'} Typical range is 0.02-0.1 ppm Cu.`
    });
  }

  if (zn > 0.5) {
    warnings.push({
      level: zn > 1.0 ? 'warning' : 'info',
      category: 'High Zinc',
      message: `Zinc level is ${zn.toFixed(2)} ppm. ${zn > 1.0 ? 'This may cause toxicity!' : 'This is on the high end.'} Typical range is 0.05-0.3 ppm Zn.`
    });
  }

  if (mn > 2) {
    warnings.push({
      level: mn > 3 ? 'warning' : 'info',
      category: 'High Manganese',
      message: `Manganese level is ${mn.toFixed(2)} ppm. ${mn > 3 ? 'This may cause toxicity!' : 'This is on the high end.'} Typical range is 0.1-1.0 ppm Mn.`
    });
  }

  // ============================================================================
  // SECTION F: CALCULATOR SANITY CHECK
  // ============================================================================

  // 23. Charge balance (electroneutrality) - use data from ion balance section if available
  if (ionBalance && ionBalance.totalCations > 0.1) {
    // Use the properly calculated ion balance data
    if (ionBalance.imbalance > 15) {
      warnings.push({
        level: 'info',
        category: 'Charge Balance',
        message: `Ion charge imbalance detected (${ionBalance.imbalance.toFixed(1)}% difference). Cations: ${ionBalance.totalCations.toFixed(2)} meq/L, Anions: ${ionBalance.totalAnions.toFixed(2)} meq/L. This may indicate missing ions in the formula or reflect natural variation. Values within ~10-15% are typically acceptable.`
      });
    }
  }

  return warnings;
}

// Display EC results
function displayECTDS(ecData) {
  const resultsSection = document.getElementById('ec-tds-section');
  const outputDiv = document.getElementById('ec-tds-result');

  resultsSection.style.display = 'block';

  let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';

  html += `
    <div class="result-card">
      <div class="result-label">Electrical Conductivity (EC)</div>
      <div class="result-value">
        ${ecData.ec.toFixed(3)}
        <span class="result-unit">mS/cm</span>
      </div>
    </div>
  `;

  html += `
    <div class="result-card">
      <div class="result-label">Ionic Strength</div>
      <div class="result-value">
        ${ecData.ionicStrength.toFixed(4)}
        <span class="result-unit">mol/L</span>
      </div>
    </div>
  `;

  html += '</div>';

  html += `
    <div class="conversion-note" style="margin-top: 15px;">
      <strong>About EC:</strong> EC (Electrical Conductivity) measures the solution's ability to conduct electricity,
      indicating total dissolved salts. Most hydroponic crops prefer EC between 1.5-2.5 mS/cm.
      Calculation uses the LMCv2 model from HydroBuddy.
    </div>
  `;

  outputDiv.innerHTML = html;
}

// Display warnings
function displayWarnings(warnings) {
  const resultsSection = document.getElementById('warnings-section');
  const outputDiv = document.getElementById('warnings-result');

  if (warnings.length === 0) {
    resultsSection.style.display = 'none';
    return;
  }

  resultsSection.style.display = 'block';

  let html = '';

  warnings.forEach(warning => {
    const boxClass = warning.level === 'warning' ? 'warning-box' :
                     warning.level === 'error' ? 'error-box' : 'conversion-note';
    const icon = warning.level === 'warning' ? '⚠️' :
                 warning.level === 'error' ? '❌' : 'ℹ️';

    html += `
      <div class="${boxClass}" style="margin-bottom: 10px;">
        <strong>${icon} ${warning.category}</strong><br>
        ${warning.message}
      </div>
    `;
  });

  outputDiv.innerHTML = html;
}

// Store last Grams to PPM calculation result for copy function
let lastGramsToPPMCalculation = null;

// Main calculation function
function calculate() {
  const volumeInput = document.getElementById('volume');
  const volume = parseFloat(volumeInput.value);

  // Validate volume
  if (!volume || volume <= 0 || isNaN(volume)) {
    alert('Please enter a valid volume greater than 0');
    volumeInput.classList.add('input-error');
    volumeInput.focus();
    return;
  }
  volumeInput.classList.remove('input-error');

  // Collect all active fertilizers and their amounts
  const activeFertilizers = [];
  let hasInvalidGrams = false;

  FERTILIZERS.forEach(f => {
    const checkbox = document.getElementById(`check-${f.id}`);
    if (checkbox && checkbox.checked) {
      const gramsInput = document.getElementById(`grams-${f.id}`);
      const grams = parseFloat(gramsInput.value);

      // Validate grams input
      if (isNaN(grams) || grams < 0) {
        gramsInput.classList.add('input-error');
        hasInvalidGrams = true;
      } else {
        gramsInput.classList.remove('input-error');
        if (grams > 0) {
          activeFertilizers.push({ ...f, grams });
        }
      }
    }
  });

  if (hasInvalidGrams) {
    alert('Please fix the invalid input values (highlighted in red)');
    return;
  }

  if (activeFertilizers.length === 0) {
    alert('Please select at least one fertilizer with an amount greater than 0');
    return;
  }

  // Calculate PPM for each nutrient
  const ppmResults = {};

  activeFertilizers.forEach(fert => {
    Object.entries(fert.pct).forEach(([nutrient, percentage]) => {
      // ppm = (grams × 1000 × (pct/100)) / liters
      const ppm = (fert.grams * 1000 * (percentage / 100)) / volume;

      if (!ppmResults[nutrient]) {
        ppmResults[nutrient] = 0;
      }

      // Handle nitrogen forms properly to avoid double counting
      if (nutrient === 'N_NO3' || nutrient === 'N_NH4') {
        ppmResults[nutrient] += ppm;
        // Also add to N_total
        if (!ppmResults.N_total) ppmResults.N_total = 0;
        ppmResults.N_total += ppm;
      } else if (nutrient === 'N_total') {
        // Only use N_total if there are no specific nitrogen forms
        if (!fert.pct.N_NO3 && !fert.pct.N_NH4) {
          ppmResults[nutrient] += ppm;
        }
      } else {
        ppmResults[nutrient] += ppm;
      }
    });
  });

  // Convert oxides to elements
  const finalResults = { ...ppmResults };

  // P from P2O5
  if (ppmResults.P2O5) {
    finalResults.P = (finalResults.P || 0) + (ppmResults.P2O5 * OXIDE_CONVERSIONS.P2O5_to_P);
  }

  // K from K2O
  if (ppmResults.K2O) {
    finalResults.K = (finalResults.K || 0) + (ppmResults.K2O * OXIDE_CONVERSIONS.K2O_to_K);
  }

  // Ca from CaO
  if (ppmResults.CaO) {
    finalResults.Ca = (finalResults.Ca || 0) + (ppmResults.CaO * OXIDE_CONVERSIONS.CaO_to_Ca);
  }

  // Mg from MgO
  if (ppmResults.MgO) {
    finalResults.Mg = (finalResults.Mg || 0) + (ppmResults.MgO * OXIDE_CONVERSIONS.MgO_to_Mg);
  }

  // S from SO3
  if (ppmResults.SO3) {
    finalResults.S = (finalResults.S || 0) + (ppmResults.SO3 * OXIDE_CONVERSIONS.SO3_to_S);
  }

  // Si from SiO2
  if (ppmResults.SiO2) {
    finalResults.Si = (finalResults.Si || 0) + (ppmResults.SiO2 * OXIDE_CONVERSIONS.SiO2_to_Si);
  }

  // Si from SiOH4 (orthosilicic acid)
  if (ppmResults.SiOH4) {
    finalResults.Si = (finalResults.Si || 0) + (ppmResults.SiOH4 * OXIDE_CONVERSIONS.SiOH4_to_Si);
  }

  // Display selected fertilizers
  displaySelectedFertilizers(activeFertilizers);

  // Display results
  displayResults(finalResults);

  // Calculate and display EC
  const ecData = calculateECTDS(finalResults);
  displayECTDS(ecData);

  // Calculate and display ion balance (must be before warnings so we can use the data)
  const ionBalance = calculateIonBalance(activeFertilizers, volume);

  // Check and display warnings (pass ion balance data)
  const warnings = checkWarnings(finalResults, activeFertilizers, ionBalance);
  displayWarnings(warnings);

  // Calculate and display nutrient ratios
  const ratios = calculateNutrientRatios(finalResults);
  displayNutrientRatios(ratios);

  // Store calculation data for copy function
  lastGramsToPPMCalculation = {
    activeFertilizers,
    volume,
    results: finalResults,
    ecData,
    ionBalance,
    ratios
  };
}

// Display selected fertilizers
function displaySelectedFertilizers(activeFertilizers) {
  const section = document.getElementById('selected-fertilizers-section');
  const list = document.getElementById('selected-fertilizers-list');

  section.style.display = 'block';
  list.innerHTML = '';

  if (activeFertilizers.length === 0) {
    section.style.display = 'none';
    return;
  }

  activeFertilizers.forEach(fert => {
    const item = document.createElement('div');
    item.className = 'selected-fertilizer-item';

    const composition = Object.entries(fert.pct)
      .map(([key, val]) => `${key}: ${val}%`)
      .join(', ');

    item.innerHTML = `
      <div class="selected-fertilizer-info">
        <div class="selected-fertilizer-name">${fert.name}</div>
        <div class="selected-fertilizer-composition">${composition}</div>
      </div>
      <div class="selected-fertilizer-amount">${fert.grams.toFixed(2)} g</div>
    `;

    list.appendChild(item);
  });
}

// Display the results
function displayResults(results) {
  const resultsSection = document.getElementById('results');
  const resultsGrid = document.getElementById('results-grid');

  resultsSection.style.display = 'block';
  resultsGrid.innerHTML = '';

  // Define display order and labels
  const displayOrder = [
    { key: 'N_total', label: 'Total Nitrogen (N)' },
    { key: 'N_NO3', label: 'Nitrate-N (NO₃-N)' },
    { key: 'N_NH4', label: 'Ammonium-N (NH₄-N)' },
    { key: 'N_Urea', label: 'Urea-N' },
    { key: 'P', label: 'Phosphorus (P)' },
    { key: 'P2O5', label: 'P₂O₅ (oxide form)' },
    { key: 'K', label: 'Potassium (K)' },
    { key: 'K2O', label: 'K₂O (oxide form)' },
    { key: 'Ca', label: 'Calcium (Ca)' },
    { key: 'Mg', label: 'Magnesium (Mg)' },
    { key: 'S', label: 'Sulfur (S)' },
    { key: 'Fe', label: 'Iron (Fe)' },
    { key: 'B', label: 'Boron (B)' },
    { key: 'Zn', label: 'Zinc (Zn)' },
    { key: 'Mn', label: 'Manganese (Mn)' },
    { key: 'Cu', label: 'Copper (Cu)' },
    { key: 'Mo', label: 'Molybdenum (Mo)' },
    { key: 'Cl', label: 'Chlorine (Cl)' },
    { key: 'Si', label: 'Silicon (Si)' }
  ];

  displayOrder.forEach(item => {
    if (results[item.key] !== undefined) {
      const card = document.createElement('div');
      const value = results[item.key];
      card.className = `result-card ${value < 0.01 ? 'zero' : ''}`;

      card.innerHTML = `
        <div class="result-label">${item.label}</div>
        <div class="result-value">
          ${value.toFixed(2)}
          <span class="result-unit">ppm</span>
        </div>
      `;

      resultsGrid.appendChild(card);
    }
  });

  // Scroll to results
  resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Calculate nutrient ratios
function calculateNutrientRatios(results) {
  const ratios = [];

  // Helper function to calculate ratio with 2 or 3 values
  function getRatio(values, names, decimals = 2) {
    // Filter out zero values
    const nonZeroValues = values.filter(v => v > 0);
    if (nonZeroValues.length === 0) return null;

    // Find the smallest non-zero value to use as base
    const minValue = Math.min(...nonZeroValues);

    // Calculate ratios relative to 1
    const ratioValues = values.map(v => v > 0 ? parseFloat((v / minValue).toFixed(decimals)) : 0);

    return {
      name: names.join(' : '),
      ratio: ratioValues.join(' : '),
      values: values,
      labels: names
    };
  }

  // N:P:K (elemental)
  const npk = getRatio(
    [results.N_total || 0, results.P || 0, results.K || 0],
    ['N', 'P', 'K']
  );
  if (npk) ratios.push(npk);

  // N:P2O5:K2O (oxide form) - common in fertilizer labels
  const npkOxide = getRatio(
    [results.N_total || 0, results.P2O5 || 0, results.K2O || 0],
    ['N', 'P₂O₅', 'K₂O']
  );
  if (npkOxide) ratios.push(npkOxide);

  // N:K ratio
  if ((results.N_total || 0) > 0 && (results.K || 0) > 0) {
    const nk = getRatio(
      [results.N_total || 0, results.K || 0],
      ['N', 'K']
    );
    if (nk) ratios.push(nk);
  }

  // NO3:NH4 ratio
  if ((results.N_NO3 || 0) > 0 || (results.N_NH4 || 0) > 0) {
    const no3nh4 = getRatio(
      [results.N_NO3 || 0, results.N_NH4 || 0],
      ['NO₃', 'NH₄']
    );
    if (no3nh4) ratios.push(no3nh4);
  }

  // Ca:Mg ratio
  if ((results.Ca || 0) > 0 && (results.Mg || 0) > 0) {
    const camg = getRatio(
      [results.Ca || 0, results.Mg || 0],
      ['Ca', 'Mg']
    );
    if (camg) ratios.push(camg);
  }

  // K:Ca ratio
  if ((results.K || 0) > 0 && (results.Ca || 0) > 0) {
    const kca = getRatio(
      [results.K || 0, results.Ca || 0],
      ['K', 'Ca']
    );
    if (kca) ratios.push(kca);
  }

  // K:Ca:Mg ratio in meq/L (accounts for different valences)
  if ((results.K || 0) > 0 && (results.Ca || 0) > 0 && (results.Mg || 0) > 0) {
    // Convert ppm to meq/L
    // meq/L = (ppm × valence) / atomic_weight
    const kMeq = (results.K || 0) / 39.1;  // K: valence 1, atomic weight 39.1
    const caMeq = (results.Ca || 0) * 2 / 40.08;  // Ca: valence 2, atomic weight 40.08
    const mgMeq = (results.Mg || 0) * 2 / 24.31;  // Mg: valence 2, atomic weight 24.31

    const kcamgMeq = getRatio(
      [kMeq, caMeq, mgMeq],
      ['K', 'Ca', 'Mg']
    );
    if (kcamgMeq) {
      kcamgMeq.name = 'K : Ca : Mg (meq/L basis)';
      kcamgMeq.values = [kMeq, caMeq, mgMeq];
      kcamgMeq.unit = 'meq/L';
      ratios.push(kcamgMeq);
    }
  }

  return ratios;
}

// Display nutrient ratio analysis
function displayNutrientRatios(ratios) {
  const ratioSection = document.getElementById('ratio-analysis-section');
  const ratioResult = document.getElementById('ratio-analysis-result');

  if (ratios.length === 0) {
    ratioSection.style.display = 'none';
    return;
  }

  ratioSection.style.display = 'block';

  let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';

  ratios.forEach(ratio => {
    const unit = ratio.unit || 'ppm';
    html += `
      <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; border-left: 4px solid #007bff;">
        <div style="font-weight: bold; margin-bottom: 8px; color: #007bff; font-size: 1.1em;">
          ${ratio.name}
        </div>
        <div style="font-size: 1.3em; font-weight: bold; color: #333; margin-bottom: 8px;">
          ${ratio.ratio}
        </div>
        <div style="font-size: 0.85em; color: #666;">
          ${ratio.labels.map((label, i) => `${label}: ${ratio.values[i].toFixed(1)} ${unit}`).join(' | ')}
        </div>
      </div>
    `;
  });

  html += '</div>';
  ratioResult.innerHTML = html;
}

// Calculate and display ion balance
function calculateIonBalance(activeFertilizers, volume) {
  let totalCations = 0;  // meq/L
  let totalAnions = 0;   // meq/L
  const ionDetails = {};  // Track individual ion contributions

  // Calculate meq for each fertilizer
  activeFertilizers.forEach(fert => {
    const ionData = ION_DATA[fert.id];

    if (!ionData) {
      // Skip fertilizers without ion data (like chelates, urea, etc.)
      return;
    }

    // Convert grams to moles
    const moles = fert.grams / ionData.molarMass;

    // Calculate meq for each ion
    ionData.ions.forEach(ionInfo => {
      const meq = moles * ionInfo.count * ionInfo.charge * 1000;
      const meqPerLiter = meq / volume;

      // Track by ion name
      if (!ionDetails[ionInfo.ion]) {
        ionDetails[ionInfo.ion] = {
          meq: 0,
          type: ionInfo.type
        };
      }
      ionDetails[ionInfo.ion].meq += meqPerLiter;

      // Add to totals
      if (ionInfo.type === 'cation') {
        totalCations += meqPerLiter;
      } else {
        totalAnions += meqPerLiter;
      }
    });
  });

  // Calculate imbalance percentage
  const average = (totalCations + totalAnions) / 2;
  const imbalance = average > 0 ? Math.abs(totalCations - totalAnions) / average * 100 : 0;

  // Display results
  const ionBalanceSection = document.getElementById('ion-balance-section');
  const ionBalanceResult = document.getElementById('ion-balance-result');

  ionBalanceSection.style.display = 'block';

  // Determine status
  let statusColor, statusText;
  if (imbalance <= 10) {
    statusColor = '#28a745';
    statusText = 'Balanced ✓';
  } else if (imbalance <= 20) {
    statusColor = '#ffc107';
    statusText = 'Caution ⚠';
  } else {
    statusColor = '#dc3545';
    statusText = 'Imbalanced ✗';
  }

  let html = `
    <div class="ion-balance-summary">
      <div class="ion-balance-card">
        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Cations</div>
        <div style="font-size: 1.5em; font-weight: bold; color: #007bff;">${totalCations.toFixed(2)} <span style="font-size: 0.7em;">meq/L</span></div>
      </div>
      <div class="ion-balance-card">
        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Anions</div>
        <div style="font-size: 1.5em; font-weight: bold; color: #007bff;">${totalAnions.toFixed(2)} <span style="font-size: 0.7em;">meq/L</span></div>
      </div>
      <div class="ion-balance-card status" style="background: ${statusColor}20; border-color: ${statusColor};">
        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Imbalance</div>
        <div style="font-size: 1.5em; font-weight: bold; color: ${statusColor};">${imbalance.toFixed(1)}%</div>
        <div style="font-size: 0.9em; color: ${statusColor}; margin-top: 5px;">${statusText}</div>
      </div>
    </div>
  `;

  // Add individual ion breakdown
  const cations = Object.entries(ionDetails).filter(([ion, data]) => data.type === 'cation');
  const anions = Object.entries(ionDetails).filter(([ion, data]) => data.type === 'anion');

  if (cations.length > 0 || anions.length > 0) {
    html += `<div class="ion-balance-breakdown">`;

    // Cations column
    html += `<div><h4 style="margin-top: 0; color: #007bff;">Cations (+)</h4>`;
    cations.forEach(([ion, data]) => {
      const percentage = totalCations > 0 ? (data.meq / totalCations * 100).toFixed(1) : 0;
      html += `
        <div class="ion-list-item">
          <span>${ion}</span>
          <span><strong>${data.meq.toFixed(2)}</strong> meq/L (${percentage}%)</span>
        </div>
      `;
    });
    html += `</div>`;

    // Anions column
    html += `<div><h4 style="margin-top: 0; color: #007bff;">Anions (-)</h4>`;
    anions.forEach(([ion, data]) => {
      const percentage = totalAnions > 0 ? (data.meq / totalAnions * 100).toFixed(1) : 0;
      html += `
        <div class="ion-list-item">
          <span>${ion}</span>
          <span><strong>${data.meq.toFixed(2)}</strong> meq/L (${percentage}%)</span>
        </div>
      `;
    });
    html += `</div>`;

    html += `</div>`;
  }

  ionBalanceResult.innerHTML = html;

  // Return ion balance data for copy function
  return {
    totalCations,
    totalAnions,
    imbalance,
    statusText: statusText.replace(/[✓⚠✗]/g, '').trim(),
    ionDetails
  };
}

// Clear all selections and reset the form
function clearAll() {
  // Clear search box
  document.getElementById('search').value = '';

  // Reset volume input
  const volumeInput = document.getElementById('volume');
  volumeInput.value = 10;
  volumeInput.classList.remove('input-error');

  // Reset all fertilizers
  FERTILIZERS.forEach(f => {
    const checkbox = document.getElementById(`check-${f.id}`);
    const input = document.getElementById(`grams-${f.id}`);
    const item = document.getElementById(`fert-${f.id}`);

    if (checkbox) checkbox.checked = false;
    if (input) {
      input.value = 0;
      input.disabled = true;
      input.classList.remove('input-error');
    }
    if (item) {
      item.classList.remove('active');
      item.style.display = ''; // Show all items
    }
  });

  // Hide results
  document.getElementById('selected-fertilizers-section').style.display = 'none';
  document.getElementById('results').style.display = 'none';
  document.getElementById('ion-balance-section').style.display = 'none';
  document.getElementById('ratio-analysis-section').style.display = 'none';
  document.getElementById('ec-tds-section').style.display = 'none';
  document.getElementById('warnings-section').style.display = 'none';
}

// Tab switching
function switchTab(tabId, tabButton) {
  // Hide all tabs
  document.querySelectorAll('.tab-content').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelectorAll('.tab').forEach(btn => {
    btn.classList.remove('active');
  });

  // Show selected tab
  const targetTab = document.getElementById(tabId);
  if (targetTab) {
    targetTab.classList.add('active');
  }

  // Mark the clicked tab active (or fall back by data attribute)
  if (tabButton instanceof HTMLElement) {
    tabButton.classList.add('active');
  } else {
    const fallbackButton = document.querySelector(`.tab[data-tab-target="${tabId}"]`);
    if (fallbackButton) {
      fallbackButton.classList.add('active');
    }
  }
}

// Clear formula builder
function clearFormulaBuilder() {
  // Clear target inputs and remove error states
  const targetIds = ['target-n', 'target-p', 'target-k', 'target-ca', 'target-mg', 'target-s', 'target-si'];
  targetIds.forEach(id => {
    const input = document.getElementById(id);
    input.value = id === 'target-si' ? '0' : '';  // Si defaults to 0
    input.classList.remove('input-error');
  });

  // Reset volume input
  const volumeInput = document.getElementById('formula-volume');
  volumeInput.value = '10';
  volumeInput.classList.remove('input-error');

  // Clear search box
  const searchInput = document.getElementById('available-fertilizer-search');
  if (searchInput) {
    searchInput.value = '';
    filterAvailableFertilizers('');
  }

  // Hide results
  document.getElementById('formula-results').style.display = 'none';
}

// Formula builder - main function
async function buildFormula() {
  // Validate volume first
  const volumeInput = document.getElementById('formula-volume');
  const volume = parseFloat(volumeInput.value);

  if (!volume || volume <= 0 || isNaN(volume)) {
    alert('Please enter a valid solution volume greater than 0');
    volumeInput.classList.add('input-error');
    volumeInput.focus();
    return;
  }
  volumeInput.classList.remove('input-error');

  // Get and validate target values
  const targetInputs = {
    N: document.getElementById('target-n'),
    P: document.getElementById('target-p'),
    K: document.getElementById('target-k'),
    Ca: document.getElementById('target-ca'),
    Mg: document.getElementById('target-mg'),
    S: document.getElementById('target-s'),
    Si: document.getElementById('target-si')
  };

  const targets = {};
  let hasInvalidInput = false;
  let hasAtLeastOneTarget = false;

  Object.entries(targetInputs).forEach(([key, input]) => {
    const value = parseFloat(input.value);

    if (input.value === '' || isNaN(value)) {
      input.classList.remove('input-error');
      targets[key] = 0;
    } else if (value < 0) {
      input.classList.add('input-error');
      hasInvalidInput = true;
      targets[key] = 0;
    } else {
      input.classList.remove('input-error');
      targets[key] = value;
      if (value > 0) {
        hasAtLeastOneTarget = true;
      }
    }
  });

  // Validate at least one nutrient target is specified
  if (!hasAtLeastOneTarget) {
    alert('Please enter a positive value for at least one nutrient target');
    return;
  }

  if (hasInvalidInput) {
    alert('Please fix the invalid input values (highlighted in red)');
    return;
  }

  // Get available fertilizers
  const availableFertilizers = [];
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`available-${fert.id}`);
    if (checkbox && checkbox.checked) {
      availableFertilizers.push(fert);
    }
  });

  if (availableFertilizers.length === 0) {
    alert('Please select at least one available fertilizer');
    return;
  }

  // Get calculation mode
  const mode = document.getElementById('formula-calculation-mode').value;

  // Show progress bar
  progressBar.show('Building Formula');
  progressBar.update(10, 'Validating inputs...');

  try {
    // Allow UI to update
    await new Promise(resolve => setTimeout(resolve, 50));

    progressBar.update(30, 'Preparing optimization model...');
    await new Promise(resolve => setTimeout(resolve, 50));

    progressBar.update(50, 'Running MILP solver...');
    progressBar.setIndeterminate('Optimizing fertilizer combination...');

    // Run optimization algorithm using absolute PPM targets
    const result = await optimizeFormula(targets, volume, availableFertilizers, 75, mode, { useAbsoluteTargets: true, useMilp: true });

    progressBar.update(90, 'Preparing results...');
    await new Promise(resolve => setTimeout(resolve, 50));

    progressBar.update(100, 'Complete!');
    await new Promise(resolve => setTimeout(resolve, 200));

    // Hide progress bar
    progressBar.hide();

    // Display results
    displayFormulaResults(result, targets, volume, mode);
  } catch (error) {
    progressBar.hide();
    console.error('Formula optimization error:', error);
    alert('An error occurred during calculation. Please try again.');
  }
}

// Simple weighted projected gradient NNLS solver for fertilizer grams
function solveNonNegativeLeastSquares(matrix, target, iterations = 1500, weights = []) {
  const rows = matrix.length;
  const cols = target.length;

  if (rows === 0 || cols === 0) {
    return { x: [], error: 0 };
  }

  let x = new Array(rows).fill(0);
  let bestX = x.slice();
  let bestError = Number.POSITIVE_INFINITY;
  const w = weights.length === cols ? weights.slice() : new Array(cols).fill(1);
  const w2 = w.map(v => v * v);

  for (let iter = 0; iter < iterations; iter++) {
    // Compute Ax
    const Ax = new Array(cols).fill(0);
    for (let i = 0; i < rows; i++) {
      const xi = x[i];
      if (xi === 0) continue;
      const row = matrix[i];
      for (let j = 0; j < cols; j++) {
        Ax[j] += row[j] * xi;
      }
    }

    // Compute residual and error
    const residual = new Array(cols);
    let error = 0;
    for (let j = 0; j < cols; j++) {
      residual[j] = Ax[j] - target[j];
      const scaled = residual[j] * w[j];
      error += scaled * scaled;
    }

    if (error < bestError) {
      bestError = error;
      bestX = x.slice();
    }

    // Step size schedule
    const lr = iter < iterations * 0.5 ? 0.0006 : iter < iterations * 0.8 ? 0.0003 : 0.00015;
    const reg = 1e-4; // tiny L2 to discourage runaway solutions

    // Compute gradient for each fertilizer
    const grad = new Array(rows).fill(0);
    for (let i = 0; i < rows; i++) {
      const row = matrix[i];
      let g = 0;
      for (let j = 0; j < cols; j++) {
        g += row[j] * residual[j] * w2[j];
      }
      grad[i] = g + reg * x[i];
    }

    // Gradient descent step with projection to non-negative
    for (let i = 0; i < rows; i++) {
      x[i] = Math.max(0, x[i] - lr * grad[i]);
    }
  }

  return { x: bestX, error: bestError };
}

// Try to prune fertilizers while staying within tolerance
function pruneSolution(matrix, targetVector, weights, baseSolution, fertilizers, tolerance = 0.01, iterations = 800) {
  // Start from current solution and try removing fertilizers greedily while staying within tolerance.
  let activeIndices = baseSolution.x
    .map((grams, idx) => ({ idx, grams }))
    .filter(item => item.grams > 1e-4)
    .map(item => item.idx);

  let best = { x: baseSolution.x.slice(), error: baseSolution.error, active: activeIndices.slice() };

  // Helper to compute achieved vector for a solution
  function computeAchieved(solX) {
    const cols = targetVector.length;
    const achieved = new Array(cols).fill(0);
    for (let i = 0; i < solX.length; i++) {
      const xi = solX[i];
      if (xi === 0) continue;
      const row = matrix[i];
      for (let j = 0; j < cols; j++) {
        achieved[j] += row[j] * xi;
      }
    }
    return achieved;
  }

  function withinTolerance(achieved) {
    for (let j = 0; j < targetVector.length; j++) {
      const target = targetVector[j];
      // Only enforce tolerance on nutrients with a positive target
      if (target > 0) {
        const diff = Math.abs(achieved[j] - target) / target;
        if (diff > tolerance) return false;
      }
    }
    return true;
  }

  // Greedy pruning: at each step, try removing each active fertilizer and keep the best feasible removal
  let improved = true;
  while (improved && activeIndices.length > 1) {
    improved = false;
    let bestCandidate = null;

    activeIndices.forEach(removeIdx => {
      const remaining = activeIndices.filter(idx => idx !== removeIdx);
      if (remaining.length === 0) return;

      const reducedMatrix = remaining.map(idx => matrix[idx]);
      const reducedSolution = solveNonNegativeLeastSquares(reducedMatrix, targetVector, iterations, weights);

      // Expand reduced solution back to full vector
      const fullX = new Array(matrix.length).fill(0);
      remaining.forEach((idx, pos) => {
        fullX[idx] = reducedSolution.x[pos];
      });

      const achieved = computeAchieved(fullX);

      if (withinTolerance(achieved)) {
        const candidate = {
          x: fullX,
          error: reducedSolution.error,
          active: remaining.slice()
        };

        if (
          !bestCandidate ||
          candidate.active.length < bestCandidate.active.length ||
          (candidate.active.length === bestCandidate.active.length && candidate.error < bestCandidate.error)
        ) {
          bestCandidate = candidate;
        }
      }
    });

    if (bestCandidate) {
      best = bestCandidate;
      activeIndices = bestCandidate.active;
      improved = true;
    }
  }

  return best;
}

// Optimization algorithm - finds best fertilizer combination from available fertilizers
async function optimizeFormula(targetRatios, volume, availableFertilizers, concentration = 75, mode = 'oxide', options = {}) {
  // Optional MILP path (uses highs.js if available)
  if (options.useMilp && typeof solveMilpBrowser === 'function') {
    const P_to_P2O5 = 1 / OXIDE_CONVERSIONS.P2O5_to_P;
    const K_to_K2O = 1 / OXIDE_CONVERSIONS.K2O_to_K;

    let ppmTargets;

    // If useAbsoluteTargets is true, use the input values directly as PPM targets
    if (options.useAbsoluteTargets) {
      ppmTargets = {
        N_total: targetRatios.N || 0,
        P2O5: mode === 'elemental'
          ? (targetRatios.P || 0) * P_to_P2O5
          : (targetRatios.P || 0),
        K2O: mode === 'elemental'
          ? (targetRatios.K || 0) * K_to_K2O
          : (targetRatios.K || 0),
        Ca: targetRatios.Ca || 0,
        Mg: targetRatios.Mg || 0,
        S: targetRatios.S || 0,
        Si: targetRatios.Si || 0
      };
    } else {
      // Build absolute ppm targets based on ratio/concentration
      // Note: Si is treated as absolute PPM, not as a ratio like N-P-K
      const ratioNutrients = { N: targetRatios.N, P: targetRatios.P, K: targetRatios.K, Ca: targetRatios.Ca, Mg: targetRatios.Mg, S: targetRatios.S };
      const ratioValues = Object.values(ratioNutrients).filter(v => v > 0);
      const minRatio = ratioValues.length > 0 ? Math.min(...ratioValues) : 1;
      const normalizedRatios = {
        N: targetRatios.N / minRatio,
        P: targetRatios.P / minRatio,
        K: targetRatios.K / minRatio,
        Ca: targetRatios.Ca / minRatio,
        Mg: targetRatios.Mg / minRatio,
        S: targetRatios.S / minRatio
      };
      const basePPMForMinRatio = concentration;

      ppmTargets = {
        N_total: normalizedRatios.N * basePPMForMinRatio,
        P2O5: mode === 'elemental'
          ? normalizedRatios.P * basePPMForMinRatio * P_to_P2O5
          : normalizedRatios.P * basePPMForMinRatio,
        K2O: mode === 'elemental'
          ? normalizedRatios.K * basePPMForMinRatio * K_to_K2O
          : normalizedRatios.K * basePPMForMinRatio,
        Ca: normalizedRatios.Ca * basePPMForMinRatio,
        Mg: normalizedRatios.Mg * basePPMForMinRatio,
        S: normalizedRatios.S * basePPMForMinRatio,
        Si: targetRatios.Si || 0  // Si is absolute PPM, not scaled by concentration
      };
    }

    const milpResult = await solveMilpBrowser({ fertilizers: availableFertilizers, targets: ppmTargets, volume, tolerance: 0.01 });
    return { formula: milpResult.formula, achieved: milpResult.achieved, targetRatios, targetPPM: ppmTargets };
  }

  // Normalize target ratios - find smallest non-zero value and normalize to that
  // Note: Si is treated as absolute PPM, not as a ratio like N-P-K
  const ratioNutrients = { N: targetRatios.N, P: targetRatios.P, K: targetRatios.K, Ca: targetRatios.Ca, Mg: targetRatios.Mg, S: targetRatios.S };
  const ratioValues = Object.values(ratioNutrients).filter(v => v > 0);
  const minRatio = ratioValues.length > 0 ? Math.min(...ratioValues) : 1;

  const normalizedRatios = {
    N: targetRatios.N / minRatio,
    P: targetRatios.P / minRatio,
    K: targetRatios.K / minRatio,
    Ca: targetRatios.Ca / minRatio,
    Mg: targetRatios.Mg / minRatio,
    S: targetRatios.S / minRatio
  };

  // Use user-selected concentration (base PPM for minimum ratio nutrient)
  // concentration=50 → EC~1.0, concentration=75 → EC~1.5, concentration=100 → EC~2.0
  const basePPMForMinRatio = concentration;

  // If elemental mode, convert P and K to oxide equivalents for internal calculation
  // P = P2O5 × 0.436, so P2O5 = P / 0.436
  // K = K2O × 0.830, so K2O = K / 0.830
  const P_to_P2O5 = 1 / OXIDE_CONVERSIONS.P2O5_to_P;  // ~2.29
  const K_to_K2O = 1 / OXIDE_CONVERSIONS.K2O_to_K;    // ~1.20

  const targetPPM_Commercial = {
    N: normalizedRatios.N * basePPMForMinRatio,
    P2O5: mode === 'elemental'
      ? normalizedRatios.P * basePPMForMinRatio * P_to_P2O5  // Convert elemental P to P2O5
      : normalizedRatios.P * basePPMForMinRatio,              // Already P2O5
    K2O: mode === 'elemental'
      ? normalizedRatios.K * basePPMForMinRatio * K_to_K2O   // Convert elemental K to K2O
      : normalizedRatios.K * basePPMForMinRatio,              // Already K2O
    Ca: normalizedRatios.Ca * basePPMForMinRatio,
    Mg: normalizedRatios.Mg * basePPMForMinRatio,
    S: normalizedRatios.S * basePPMForMinRatio,
    Si: targetRatios.Si || 0  // Si is absolute PPM, not scaled by concentration
  };

  // If user wants absolute ppm targets (not ratios), override with direct values
  if (options.useAbsoluteTargets) {
    targetPPM_Commercial.N = targetRatios.N || 0;
    targetPPM_Commercial.P2O5 = mode === 'elemental'
      ? (targetRatios.P || 0) * P_to_P2O5
      : (targetRatios.P || 0);
    targetPPM_Commercial.K2O = mode === 'elemental'
      ? (targetRatios.K || 0) * K_to_K2O
      : (targetRatios.K || 0);
    targetPPM_Commercial.Ca = targetRatios.Ca || 0;
    targetPPM_Commercial.Mg = targetRatios.Mg || 0;
    targetPPM_Commercial.S = targetRatios.S || 0;
    targetPPM_Commercial.Si = targetRatios.Si || 0;
  }

  const formula = {};
  const achieved = { N_total: 0, N_NO3: 0, N_NH4: 0, P2O5: 0, K2O: 0, P: 0, K: 0, Ca: 0, Mg: 0, S: 0, Si: 0 };

  // Helper function to calculate PPM contribution from a fertilizer
  function calculatePPM(fert, grams) {
    const contribution = { N_total: 0, N_NO3: 0, N_NH4: 0, P2O5: 0, K2O: 0, P: 0, K: 0, Ca: 0, Mg: 0, S: 0, Si: 0 };

    Object.entries(fert.pct).forEach(([nutrient, percentage]) => {
      const ppm = (grams * 1000 * (percentage / 100)) / volume;

      if (nutrient === 'P2O5') {
        contribution.P2O5 += ppm;  // Track commercial P2O5
        contribution.P += ppm * OXIDE_CONVERSIONS.P2O5_to_P;  // Also track elemental
      } else if (nutrient === 'K2O') {
        contribution.K2O += ppm;  // Track commercial K2O
        contribution.K += ppm * OXIDE_CONVERSIONS.K2O_to_K;  // Also track elemental
      } else if (nutrient === 'N_NO3') {
        contribution.N_NO3 += ppm;
        contribution.N_total += ppm;
      } else if (nutrient === 'N_NH4') {
        contribution.N_NH4 += ppm;
        contribution.N_total += ppm;
      } else if (nutrient === 'N_total') {
        // Skip N_total if we have specific forms (N_NO3/N_NH4)
        // Only use N_total if there are no specific nitrogen forms defined
        if (!fert.pct.N_NO3 && !fert.pct.N_NH4) {
          contribution.N_total += ppm;
        }
      } else if (nutrient === 'CaO' && OXIDE_CONVERSIONS.CaO_to_Ca) {
        contribution.Ca += ppm * OXIDE_CONVERSIONS.CaO_to_Ca;
      } else if (nutrient === 'MgO' && OXIDE_CONVERSIONS.MgO_to_Mg) {
        contribution.Mg += ppm * OXIDE_CONVERSIONS.MgO_to_Mg;
      } else if (nutrient === 'SO3' && OXIDE_CONVERSIONS.SO3_to_S) {
        contribution.S += ppm * OXIDE_CONVERSIONS.SO3_to_S;
      } else if (nutrient === 'SiO2' && OXIDE_CONVERSIONS.SiO2_to_Si) {
        contribution.Si += ppm * OXIDE_CONVERSIONS.SiO2_to_Si;
      } else if (nutrient === 'SiOH4' && OXIDE_CONVERSIONS.SiOH4_to_Si) {
        contribution.Si += ppm * OXIDE_CONVERSIONS.SiOH4_to_Si;
      } else if (nutrient === 'Si') {
        contribution.Si += ppm;
      } else {
        contribution[nutrient] = (contribution[nutrient] || 0) + ppm;
      }
    });

    return contribution;
  }

  // Helper function to add fertilizer to formula
  function addFertilizer(fert, grams) {
    if (!formula[fert.id]) formula[fert.id] = 0;
    formula[fert.id] += grams;

    const contribution = calculatePPM(fert, grams);
    Object.keys(contribution).forEach(nutrient => {
      achieved[nutrient] += contribution[nutrient];
    });
  }

  // Find best fertilizer for a specific nutrient
  function findBestFor(nutrient, preferNH4 = false, preferS = false) {
    let best = null;
    let bestScore = -1;

    availableFertilizers.forEach(fert => {
      let score = 0;

      // Primary nutrient availability
      if (nutrient === 'Ca' && fert.pct.Ca) score += fert.pct.Ca * 10;
      if (nutrient === 'P' && fert.pct.P2O5) score += fert.pct.P2O5 * 10;
      if (nutrient === 'K' && fert.pct.K2O) score += fert.pct.K2O * 10;
      if (nutrient === 'Mg' && fert.pct.Mg) score += fert.pct.Mg * 10;

      // Bonus for NH4 if needed
      if (preferNH4 && fert.pct.N_NH4) score += fert.pct.N_NH4 * 5;

      // Bonus for S if needed
      if (preferS && fert.pct.S) score += fert.pct.S * 3;

      if (score > bestScore) {
        bestScore = score;
        best = fert;
      }
    });

    return best;
  }

  // Helper to calculate nutrient weight contribution (in grams) from fertilizer
  function calculateNutrientGrams(fert, fertGrams) {
    const grams = { N: 0, P: 0, K: 0, Ca: 0, Mg: 0, S: 0 };

    Object.entries(fert.pct).forEach(([nutrient, percentage]) => {
      const nutrientGrams = fertGrams * (percentage / 100);

      if (nutrient === 'P2O5') {
        grams.P += nutrientGrams * OXIDE_CONVERSIONS.P2O5_to_P;
      } else if (nutrient === 'K2O') {
        grams.K += nutrientGrams * OXIDE_CONVERSIONS.K2O_to_K;
      } else if (nutrient === 'N_NO3' || nutrient === 'N_NH4') {
        grams.N += nutrientGrams;
      } else if (nutrient === 'N_total' && !fert.pct.N_NO3 && !fert.pct.N_NH4) {
        grams.N += nutrientGrams;
      } else if (nutrient === 'Ca' || nutrient === 'Mg' || nutrient === 'S') {
        grams[nutrient] += nutrientGrams;
      }
    });

    return grams;
  }

  // Build matrix (fertilizers x nutrients) for least-squares solver
  // Use hard weights for nutrients the user targeted (>0), and soft weights for untargeted nutrients to discourage excess without blocking solutions
  const allNutrients = ['N_total', 'P2O5', 'K2O', 'Ca', 'Mg', 'S'];
  const targetedKeys = allNutrients.filter(key => (targetPPM_Commercial[key] || 0) > 0);
  const extraKeys = allNutrients.filter(key => (targetPPM_Commercial[key] || 0) === 0);
  const nutrientKeys = targetedKeys.concat(extraKeys);

  const weights = [];
  const targetVector = [];
  const softWeight = 0.1; // softer penalty for nutrients with 0 target

  nutrientKeys.forEach(key => {
    const isTargeted = (targetPPM_Commercial[key] || 0) > 0;
    weights.push(isTargeted ? 1 : softWeight);
    targetVector.push(targetPPM_Commercial[key] || 0);
  });

  // If no nutrients were targeted, fall back to equal weights to keep the solver stable
  if (targetedKeys.length === 0) {
    weights.fill(1);
  }

  const matrix = availableFertilizers.map(fert => {
    // Contribution per gram of this fertilizer
    const contrib = calculatePPM(fert, 1);
    return nutrientKeys.map(key => contrib[key] || 0);
  });

  const pruneTolerance = typeof options.pruneTolerance === 'number' ? options.pruneTolerance : 0.01;

  // Helper to solve and optionally prune for a given subset of indices
  function solveForSubset(indices) {
    const subsetMatrix = indices.map(idx => matrix[idx]);
    const subsetFerts = indices.map(idx => availableFertilizers[idx]);
    const baseSolution = solveNonNegativeLeastSquares(subsetMatrix, targetVector, 1500, weights);
    const pruned = pruneSolution(subsetMatrix, targetVector, weights, baseSolution, subsetFerts, pruneTolerance, 800);
    return pruned && pruned.x ? { solution: pruned, indices } : { solution: baseSolution, indices };
  }

  // Evaluate error for positive targets only
  function evaluateSolution(solObj) {
    const achievedVec = new Array(targetVector.length).fill(0);
    solObj.solution.x.forEach((xi, pos) => {
      if (xi === 0) return;
      const row = solObj.indices.map(idx => matrix[idx])[pos];
      row.forEach((val, j) => {
        achievedVec[j] += val * xi;
      });
    });
    let err = 0;
    targetVector.forEach((t, j) => {
      if (t > 0) {
        const diff = Math.abs(achievedVec[j] - t) / t;
        err += diff * diff;
      } else {
        err += achievedVec[j] * achievedVec[j] * 1e-6;
      }
    });
    return { err, achievedVec };
  }

  // Try exhaustive search of small subsets (up to 3 fertilizers) to favor sparse solutions
  let best = null;
  let bestWithin = null;
  const maxCombo = Math.min(4, availableFertilizers.length);

  if (availableFertilizers.length <= 8) {
    function choose(start, depth, combo) {
      if (depth === 0) {
        const sol = solveForSubset(combo);
        const { err } = evaluateSolution(sol);
        const usedCount = sol.solution.x.filter(v => v > 1e-4).length;
        const withinTol = targetVector.every((t, j) => {
          if (t <= 0) return true;
          const achieved = sol.solution.x.reduce((sum, xi, pos) => {
            const row = sol.indices.map(idx => matrix[idx])[pos];
            return sum + xi * row[j];
          }, 0);
          return Math.abs(achieved - t) / t <= pruneTolerance;
        });

        if (withinTol) {
          if (!bestWithin || usedCount < bestWithin.usedCount || (usedCount === bestWithin.usedCount && err < bestWithin.err)) {
            bestWithin = { sol, err, usedCount };
          }
        }
        if (
          !best ||
          usedCount < best.usedCount ||
          (usedCount === best.usedCount && err < best.err)
        ) {
          best = { sol, err, usedCount };
        }
        return;
      }
      for (let i = start; i <= availableFertilizers.length - depth; i++) {
        combo.push(i);
        choose(i + 1, depth - 1, combo);
        combo.pop();
      }
    }

    for (let size = 1; size <= maxCombo; size++) {
      choose(0, size, []);
      if (best && best.usedCount === size) break;
    }
  }

  // Fallback to full set if no best found
  let chosen = bestWithin;

  if (!chosen) {
    const baseSolution = solveNonNegativeLeastSquares(matrix, targetVector, 1500, weights);
    const pruned = pruneSolution(matrix, targetVector, weights, baseSolution, availableFertilizers, pruneTolerance, 800);
    chosen = { sol: pruned && pruned.x ? pruned : baseSolution, err: 0, usedCount: availableFertilizers.length };
  }

  // Apply solved grams to formula/achieved using chosen subset
  const finalSol = chosen.sol.solution || chosen.sol;
  const finalIndices = chosen.sol.active || chosen.sol.indices || availableFertilizers.map((_, i) => i);
  finalSol.x.forEach((grams, pos) => {
    if (grams > 0.0001) {
      const fertIdx = finalIndices[pos] !== undefined ? finalIndices[pos] : pos;
      addFertilizer(availableFertilizers[fertIdx], grams);
    }
  });

  // Safety fallback: if nothing was added, use the full set without pruning
  if (Object.keys(formula).length === 0) {
    const baseSolution = solveNonNegativeLeastSquares(matrix, targetVector, 1500, weights);
    baseSolution.x.forEach((grams, index) => {
      if (grams > 0.0001) {
        addFertilizer(availableFertilizers[index], grams);
      }
    });
  }

  return { formula, achieved, targetRatios, targetPPM: targetPPM_Commercial };
}

// Store last formula builder calculation result for explanation modals
let lastFormulaCalculation = null;

// Display formula results
function displayFormulaResults(result, targets, volume, mode = 'oxide') {
  // Store data for explanation modals
  lastFormulaCalculation = { result, targets, volume, mode };

  const resultsSection = document.getElementById('formula-results');
  const outputDiv = document.getElementById('formula-output');

  resultsSection.style.display = 'block';

  let html = '<div class="formula-result"><h3>Fertilizers to Add (per ' + volume + 'L)</h3>';

  // Display formula and calculate total grams
  let totalGrams = 0;
  const fertEntries = Object.entries(result.formula);

  fertEntries.forEach(([fertId, grams]) => {
    const fert = FERTILIZERS.find(f => f.id === fertId);
    if (fert) {
      totalGrams += grams;
      const composition = Object.entries(fert.pct)
        .map(([key, val]) => `${key}: ${val}%`)
        .join(', ');
      html += `
        <div class="formula-fertilizer">
          <div class="formula-fertilizer-info">
            <div class="formula-fertilizer-name">${fert.name}</div>
            <div class="formula-fertilizer-composition">${composition}</div>
          </div>
          <div class="formula-fertilizer-amount">${grams.toFixed(2)} g</div>
        </div>
      `;
    }
  });

  // Show total grams
  if (fertEntries.length > 1) {
    html += `
      <div class="formula-fertilizer" style="background: #e8f5e9; border-left: 4px solid #4caf50; margin-top: 10px;">
        <div class="formula-fertilizer-info">
          <div class="formula-fertilizer-name" style="color: #2e7d32; font-weight: bold;">TOTAL (${fertEntries.length} fertilizers)</div>
        </div>
        <div class="formula-fertilizer-amount" style="color: #2e7d32; font-size: 1.2em;">${totalGrams.toFixed(2)} g</div>
      </div>
    `;
  }

  html += '</div>';

  // Comparison table - show values in the same mode as input
  html += '<h3>Target vs Achieved</h3>';
  html += '<div class="comparison-table-wrapper">';
  html += '<table class="comparison-table">';
  html += '<tr><th>Nutrient</th><th>Target (ppm)</th><th>Achieved (ppm)</th><th>Difference</th></tr>';

  // Choose nutrients and labels based on mode
  const nutrients = mode === 'elemental'
    ? ['N_total', 'P', 'K', 'Ca', 'Mg', 'S', 'Si']
    : ['N_total', 'P2O5', 'K2O', 'Ca', 'Mg', 'S', 'Si'];

  const labels = mode === 'elemental'
    ? {
        N_total: 'Nitrogen (N)',
        P: 'Phosphorus (P)',
        K: 'Potassium (K)',
        Ca: 'Calcium (Ca)',
        Mg: 'Magnesium (Mg)',
        S: 'Sulfur (S)',
        Si: 'Silicon (Si)'
      }
    : {
        N_total: 'Nitrogen (N)',
        P2O5: 'Phosphorus (P₂O₅)',
        K2O: 'Potassium (K₂O)',
        Ca: 'Calcium (Ca)',
        Mg: 'Magnesium (Mg)',
        S: 'Sulfur (S)',
        Si: 'Silicon (Si)'
      };

  let allGood = true;
  const warnings = [];

  nutrients.forEach(nutrient => {
    // Map nutrient key to target key
    let targetKey;
    if (nutrient === 'N_total') targetKey = 'N';
    else if (nutrient === 'P2O5') targetKey = 'P';
    else if (nutrient === 'K2O') targetKey = 'K';
    else targetKey = nutrient;

    const target = targets[targetKey];
    const achieved = result.achieved[nutrient] || 0;

    if (target === 0 && (nutrient === 'S' || nutrient === 'Si')) return; // Skip S/Si if not specified

    const diff = achieved - target;
    const percentDiff = target > 0 ? (Math.abs(diff) / target * 100) : 0;

    let className = 'match';
    let status = '✓';

    if (percentDiff > 20) {
      className = 'miss';
      status = '✗';
      allGood = false;
      warnings.push(`${labels[nutrient]} is ${percentDiff.toFixed(1)}% off target`);
    } else if (percentDiff > 10) {
      className = 'close';
      status = '⚠';
      warnings.push(`${labels[nutrient]} is ${percentDiff.toFixed(1)}% off target (acceptable range)`);
    }

    html += `
      <tr>
        <td>${labels[nutrient]}</td>
        <td>${target.toFixed(1)}</td>
        <td class="${className}">${achieved.toFixed(1)} ${status}</td>
        <td class="${className}">${diff >= 0 ? '+' : ''}${diff.toFixed(1)} (${percentDiff.toFixed(1)}%)</td>
      </tr>
    `;
  });

  html += '</table>';
  html += '</div>';

  // Mode note
  if (mode === 'elemental') {
    html += `<div class="conversion-note" style="margin-top: 15px;">
      <strong>Elemental Mode:</strong> Values shown are pure elemental forms (P, K).
      <br>
      To convert to oxide forms: P₂O₅ = P × 2.29, K₂O = K × 1.20
    </div>`;
  } else {
    html += `<div class="conversion-note" style="margin-top: 15px;">
      <strong>Oxide Mode:</strong> Values shown are commercial oxide forms (P₂O₅, K₂O).
      <br>
      To convert to elements: P = P₂O₅ × 0.436, K = K₂O × 0.830
    </div>`;
  }

  // NH4-N percentage
  const nh4Percent = result.achieved.N_total > 0 ? (result.achieved.N_NH4 / result.achieved.N_total * 100) : 0;
  html += `<div class="conversion-note" style="margin-top: 15px;">
    <strong>Nitrogen Form:</strong> ${result.achieved.N_NH4.toFixed(1)} ppm NH₄-N (${nh4Percent.toFixed(1)}% of total N),
    ${result.achieved.N_NO3.toFixed(1)} ppm NO₃-N (${(100 - nh4Percent).toFixed(1)}% of total N)
  </div>`;

  // Calculate ion balance for this formula
  const activeFertilizers = Object.entries(result.formula).map(([fertId, grams]) => {
    const fert = FERTILIZERS.find(f => f.id === fertId);
    return { ...fert, grams };
  });

  const ionBalance = calculateIonBalanceForFormula(activeFertilizers, volume);

  html += '<h3 style="margin-top: 20px;">Ion Balance <span class="info-icon" onclick="openFormulaIonBalanceExplanation()" title="Click to learn how we calculate Ion Balance">?</span></h3>';
  html += `<div class="ion-balance-summary" style="margin-top: 10px;">
    <div class="ion-balance-card">
      <div style="font-size: 0.9em; color: #666;">Cations</div>
      <div style="font-size: 1.3em; font-weight: bold;">${ionBalance.totalCations.toFixed(2)} meq/L</div>
    </div>
    <div class="ion-balance-card">
      <div style="font-size: 0.9em; color: #666;">Anions</div>
      <div style="font-size: 1.3em; font-weight: bold;">${ionBalance.totalAnions.toFixed(2)} meq/L</div>
    </div>
    <div class="ion-balance-card status" style="background: ${ionBalance.statusColor}20; border-color: ${ionBalance.statusColor};">
      <div style="font-size: 0.9em; color: #666;">Imbalance</div>
      <div style="font-size: 1.3em; font-weight: bold; color: ${ionBalance.statusColor};">${ionBalance.imbalance.toFixed(1)}%</div>
      <div style="font-size: 0.9em; color: ${ionBalance.statusColor};">${ionBalance.statusText}</div>
    </div>
  </div>`;

  // Add EC prediction
  const ecData = calculateECTDS(result.achieved);
  const ecColor = ecData.ec > 3.5 ? '#dc3545' : ecData.ec < 0.5 ? '#ffc107' : '#28a745';
  const ecStatus = ecData.ec > 3.5 ? 'High' : ecData.ec < 0.5 ? 'Low' : 'Good';

  html += '<h3 style="margin-top: 20px;">EC Prediction</h3>';
  html += `<div class="ion-balance-summary" style="margin-top: 10px;">
    <div class="ion-balance-card" style="background: ${ecColor}15; border-color: ${ecColor};">
      <div style="font-size: 0.9em; color: #666;">Predicted EC</div>
      <div style="font-size: 1.5em; font-weight: bold; color: ${ecColor};">${ecData.ec.toFixed(2)} mS/cm</div>
      <div style="font-size: 0.9em; color: ${ecColor};">${ecStatus}</div>
    </div>
    <div class="ion-balance-card">
      <div style="font-size: 0.9em; color: #666;">Ionic Strength</div>
      <div style="font-size: 1.3em; font-weight: bold;">${ecData.ionicStrength.toFixed(4)} mol/L</div>
    </div>
  </div>`;
  html += '<div class="conversion-note" style="margin-top: 10px;"><strong>Note:</strong> EC prediction uses the LMCv2 ion conductivity model. Optimal EC for most crops is 1.5-2.5 mS/cm.</div>';

  // Add nutrient ratio analysis
  const ratios = calculateNutrientRatios(result.achieved);
  if (ratios.length > 0) {
    html += '<h3 style="margin-top: 20px;">Nutrient Ratio Analysis</h3>';
    html += '<div class="nutrient-ratio-grid">';

    ratios.forEach(ratio => {
      const unit = ratio.unit || 'ppm';
      html += `
        <div class="nutrient-ratio-card">
          <div style="font-weight: bold; margin-bottom: 8px; color: #007bff; font-size: 1.1em;">
            ${ratio.name}
          </div>
          <div style="font-size: 1.3em; font-weight: bold; color: #333; margin-bottom: 8px;">
            ${ratio.ratio}
          </div>
          <div style="font-size: 0.85em; color: #666;">
            ${ratio.labels.map((label, i) => `${label}: ${ratio.values[i].toFixed(1)} ${unit}`).join(' | ')}
          </div>
        </div>
      `;
    });

    html += '</div>';
  }

  // Nutritional warnings (from checkWarnings function)
  const nutritionalWarnings = checkWarnings(result.achieved, activeFertilizers);
  if (nutritionalWarnings.length > 0) {
    html += '<h3 style="margin-top: 20px;">Warnings & Recommendations</h3>';
    nutritionalWarnings.forEach(warning => {
      const boxClass = warning.level === 'warning' ? 'warning-box' :
                       warning.level === 'error' ? 'error-box' : 'conversion-note';
      const icon = warning.level === 'warning' ? '⚠️' :
                   warning.level === 'error' ? '❌' : 'ℹ️';
      html += `
        <div class="${boxClass}" style="margin-bottom: 10px;">
          <strong>${icon} ${warning.category}</strong><br>
          ${warning.message}
        </div>
      `;
    });
  }

  // Warnings or errors (target deviation warnings)
  if (!allGood) {
    html += '<div class="error-box"><strong>⚠ Cannot achieve exact targets</strong><ul>';
    warnings.forEach(w => html += `<li>${w}</li>`);
    html += '</ul><p>This is the closest formula achievable with available fertilizers. Consider adjusting your targets or accepting the shown deviations.</p></div>';
  } else if (warnings.length > 0) {
    html += '<div class="warning-box"><strong>Note:</strong><ul>';
    warnings.forEach(w => html += `<li>${w}</li>`);
    html += '</ul></div>';
  }

  outputDiv.innerHTML = html;
  resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Calculate ion balance for formula (returns summary data)
function calculateIonBalanceForFormula(activeFertilizers, volume) {
  let totalCations = 0;
  let totalAnions = 0;

  activeFertilizers.forEach(fert => {
    const ionData = ION_DATA[fert.id];
    if (!ionData) return;

    const moles = fert.grams / ionData.molarMass;

    ionData.ions.forEach(ionInfo => {
      const meq = moles * ionInfo.count * ionInfo.charge * 1000;
      const meqPerLiter = meq / volume;

      if (ionInfo.type === 'cation') {
        totalCations += meqPerLiter;
      } else {
        totalAnions += meqPerLiter;
      }
    });
  });

  const average = (totalCations + totalAnions) / 2;
  const imbalance = average > 0 ? Math.abs(totalCations - totalAnions) / average * 100 : 0;

  let statusColor, statusText;
  if (imbalance <= 10) {
    statusColor = '#28a745';
    statusText = 'Balanced ✓';
  } else if (imbalance <= 20) {
    statusColor = '#ffc107';
    statusText = 'Caution ⚠';
  } else {
    statusColor = '#dc3545';
    statusText = 'Imbalanced ✗';
  }

  return { totalCations, totalAnions, imbalance, statusColor, statusText };
}

// ============================================================================
// TWO-TANK SYSTEM FUNCTIONS
// ============================================================================

// Split fertilizers into two compatible tanks
// Tank A: Calcium-containing fertilizers + compatible neutrals
// Tank B: Sulfate/Phosphate-containing fertilizers + compatible neutrals
// Neutral fertilizers can be split between tanks to help balance ions
function splitIntoTwoTanks(formula, volume) {
  const tankA = { fertilizers: {}, name: 'Tank A (Calcium)', description: 'Contains calcium sources - keep separate from sulfates and silicates' };
  const tankB = { fertilizers: {}, name: 'Tank B (Sulfates/Phosphates/Silicates)', description: 'Contains sulfate, phosphate, and silicate sources' };

  const neutralFertilizers = [];

  // First pass: categorize fertilizers
  Object.entries(formula).forEach(([fertId, grams]) => {
    if (grams <= 0) return;

    const hasCa = hasCaContent(fertId);
    const hasS = hasSulfateContent(fertId);
    const hasP = hasPhosphateContent(fertId);
    const hasSi = hasSilicateContent(fertId);

    if (hasCa && !hasS && !hasSi) {
      // Pure calcium source -> Tank A
      tankA.fertilizers[fertId] = grams;
    } else if (hasS && !hasCa) {
      // Sulfate source (no calcium) -> Tank B
      tankB.fertilizers[fertId] = grams;
    } else if (hasP && !hasCa && !hasS) {
      // Pure phosphate source -> Tank B (safer with sulfates than calcium at high conc)
      tankB.fertilizers[fertId] = grams;
    } else if (hasSi && !hasCa) {
      // Silicate source (no calcium) -> Tank B (silicates precipitate with calcium)
      tankB.fertilizers[fertId] = grams;
    } else if (hasCa && hasS) {
      // Contains both Ca and S - problematic, put in Tank A with warning
      tankA.fertilizers[fertId] = grams;
    } else if (hasCa && hasSi) {
      // Contains both Ca and Si - problematic, put in Tank A with warning
      tankA.fertilizers[fertId] = grams;
    } else {
      // Neutral fertilizer - will be assigned to help balance
      neutralFertilizers.push({ fertId, grams });
    }
  });

  // Calculate initial ion balance for each tank
  let tankABalance = calculateTankIonBalance(tankA.fertilizers, volume);
  let tankBBalance = calculateTankIonBalance(tankB.fertilizers, volume);

  // Second pass: distribute neutral fertilizers to help balance tanks
  neutralFertilizers.forEach(({ fertId, grams }) => {
    // Get ion contribution of this fertilizer
    const ionData = ION_DATA[fertId];

    // Determine which tank needs more help with balance
    // Also consider if one tank is empty
    const tankAEmpty = Object.keys(tankA.fertilizers).length === 0;
    const tankBEmpty = Object.keys(tankB.fertilizers).length === 0;

    if (tankAEmpty && tankBEmpty) {
      // Both empty, put in Tank A
      tankA.fertilizers[fertId] = grams;
    } else if (tankAEmpty) {
      // Tank A is empty, put there to give it something
      tankA.fertilizers[fertId] = grams;
    } else if (tankBEmpty) {
      // Tank B is empty, put there
      tankB.fertilizers[fertId] = grams;
    } else {
      // Both tanks have items - assign to the one with worse balance
      // or split if both are similar
      const tankAImbalance = tankABalance.imbalance;
      const tankBImbalance = tankBBalance.imbalance;

      if (Math.abs(tankAImbalance - tankBImbalance) < 5) {
        // Similar imbalance - check which direction each tank leans
        // and assign to help correct it
        const tankAExcess = tankABalance.totalCations - tankABalance.totalAnions;
        const tankBExcess = tankBBalance.totalCations - tankBBalance.totalAnions;

        // Check if this fertilizer contributes more cations or anions
        let fertCations = 0, fertAnions = 0;
        if (ionData) {
          const testFert = [{ id: fertId, grams: grams }];
          const testBalance = calculateTankIonBalance({ [fertId]: grams }, volume);
          fertCations = testBalance.totalCations;
          fertAnions = testBalance.totalAnions;
        }

        const fertExcess = fertCations - fertAnions;

        // Assign to tank where it helps balance
        if (tankAExcess > 0 && fertExcess < 0) {
          tankA.fertilizers[fertId] = grams;
        } else if (tankBExcess > 0 && fertExcess < 0) {
          tankB.fertilizers[fertId] = grams;
        } else if (tankAExcess < 0 && fertExcess > 0) {
          tankA.fertilizers[fertId] = grams;
        } else if (tankBExcess < 0 && fertExcess > 0) {
          tankB.fertilizers[fertId] = grams;
        } else {
          // Can't help balance either way - put in tank with higher imbalance
          if (tankAImbalance >= tankBImbalance) {
            tankA.fertilizers[fertId] = grams;
          } else {
            tankB.fertilizers[fertId] = grams;
          }
        }
      } else if (tankAImbalance > tankBImbalance) {
        tankA.fertilizers[fertId] = grams;
      } else {
        tankB.fertilizers[fertId] = grams;
      }
    }

    // Recalculate balances after assignment
    tankABalance = calculateTankIonBalance(tankA.fertilizers, volume);
    tankBBalance = calculateTankIonBalance(tankB.fertilizers, volume);
  });

  // Final balance calculation
  tankA.ionBalance = calculateTankIonBalance(tankA.fertilizers, volume);
  tankB.ionBalance = calculateTankIonBalance(tankB.fertilizers, volume);

  // Calculate nutrient contributions for each tank
  tankA.nutrients = calculateTankNutrients(tankA.fertilizers, volume);
  tankB.nutrients = calculateTankNutrients(tankB.fertilizers, volume);

  return { tankA, tankB };
}

// Calculate ion balance for a single tank
function calculateTankIonBalance(fertilizers, volume) {
  let totalCations = 0;
  let totalAnions = 0;

  Object.entries(fertilizers).forEach(([fertId, grams]) => {
    const ionData = ION_DATA[fertId];
    if (!ionData) return;

    const moles = grams / ionData.molarMass;

    ionData.ions.forEach(ionInfo => {
      const meq = moles * ionInfo.count * ionInfo.charge * 1000;
      const meqPerLiter = meq / volume;

      if (ionInfo.type === 'cation') {
        totalCations += meqPerLiter;
      } else {
        totalAnions += meqPerLiter;
      }
    });
  });

  const average = (totalCations + totalAnions) / 2;
  const imbalance = average > 0 ? Math.abs(totalCations - totalAnions) / average * 100 : 0;

  let statusColor, statusText;
  if (imbalance <= 10) {
    statusColor = '#28a745';
    statusText = 'Balanced';
  } else if (imbalance <= 20) {
    statusColor = '#ffc107';
    statusText = 'Caution';
  } else {
    statusColor = '#dc3545';
    statusText = 'Imbalanced';
  }

  return { totalCations, totalAnions, imbalance, statusColor, statusText };
}

// Calculate nutrient PPM contributions for a tank
function calculateTankNutrients(fertilizers, volume) {
  const nutrients = {
    N_total: 0, N_NO3: 0, N_NH4: 0,
    P2O5: 0, P: 0, K2O: 0, K: 0,
    Ca: 0, Mg: 0, S: 0
  };

  Object.entries(fertilizers).forEach(([fertId, grams]) => {
    const fert = FERTILIZERS.find(f => f.id === fertId);
    if (!fert) return;

    Object.keys(nutrients).forEach(nutrient => {
      if (fert.pct[nutrient]) {
        nutrients[nutrient] += (grams * fert.pct[nutrient] / 100) / volume * 1000;
      }
    });
  });

  // Calculate total N
  nutrients.N_total = nutrients.N_NO3 + nutrients.N_NH4;

  // Calculate elemental from oxide if not directly available
  if (nutrients.P2O5 > 0 && nutrients.P === 0) {
    nutrients.P = nutrients.P2O5 * OXIDE_CONVERSIONS.P2O5_to_P;
  }
  if (nutrients.K2O > 0 && nutrients.K === 0) {
    nutrients.K = nutrients.K2O * OXIDE_CONVERSIONS.K2O_to_K;
  }

  return nutrients;
}

// Display two-tank results for formula builder
function displayTwoTankFormulaResults() {
  if (!lastFormulaCalculation) {
    alert('No formula results to split. Please build a formula first.');
    return;
  }

  const { result, targets, volume, mode } = lastFormulaCalculation;
  const { tankA, tankB } = splitIntoTwoTanks(result.formula, volume);

  displayTwoTankResults(tankA, tankB, volume, mode, 'formula-output', result.achieved, targets);
}

// Display two-tank results for reverse calculator
function displayTwoTankReverseResults() {
  if (!lastReverseCalculation) {
    alert('No calculation results to split. Please calculate fertilizers first.');
    return;
  }

  const { result, targets, volume, mode } = lastReverseCalculation;
  const { tankA, tankB } = splitIntoTwoTanks(result.formula, volume);

  displayTwoTankResults(tankA, tankB, volume, mode, 'reverse-output', result.achieved, targets);
}

// Display two-tank results for Grams to PPM calculator (Tab 1)
function displayTwoTankGramsToPPMResults() {
  if (!lastGramsToPPMCalculation) {
    alert('No calculation results to split. Please calculate PPM values first.');
    return;
  }

  const { activeFertilizers, volume, results } = lastGramsToPPMCalculation;

  // Convert activeFertilizers array to formula object format
  const formula = {};
  activeFertilizers.forEach(fert => {
    formula[fert.id] = fert.grams;
  });

  const { tankA, tankB } = splitIntoTwoTanks(formula, volume);

  // For Grams to PPM, we use elemental mode and no specific targets
  displayTwoTankResults(tankA, tankB, volume, 'elemental', 'selected-fertilizers-list', results, null);
}

// Store current two-tank data for copy function
let currentTwoTankData = null;

// Common display function for two-tank results
function displayTwoTankResults(tankA, tankB, volume, mode, outputDivId, achieved, targets) {
  const outputDiv = document.getElementById(outputDivId);

  // Hide header buttons when showing two-tank view
  let headerButtonsId;
  if (outputDivId === 'formula-output') {
    headerButtonsId = 'formula-header-buttons';
  } else if (outputDivId === 'reverse-output') {
    headerButtonsId = 'reverse-header-buttons';
  } else if (outputDivId === 'selected-fertilizers-list') {
    headerButtonsId = 'grams-to-ppm-header-buttons';
  }
  const headerButtons = document.getElementById(headerButtonsId);
  if (headerButtons) {
    headerButtons.style.display = 'none';
  }

  // Store data for copy function
  currentTwoTankData = { tankA, tankB, volume, mode, achieved, targets };

  let html = '<div class="two-tank-results">';

  // Header with copy button
  html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">';
  html += '<h3 style="margin: 0; color: #007bff;">Two-Tank Stock Solution System</h3>';
  html += `<button class="copy-btn" onclick="copyTwoTankResults()" title="Copy two-tank results to clipboard">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
    Copy Results
  </button>`;
  html += '</div>';

  html += '<p style="margin-bottom: 20px; color: #666;">Fertilizers separated to prevent calcium sulfate precipitation. Mix each tank with water separately, then combine in final solution.</p>';

  // Calculate combined nutrients first (needed for ratio calculations)
  const combinedNutrients = {
    N_total: tankA.nutrients.N_total + tankB.nutrients.N_total,
    P2O5: tankA.nutrients.P2O5 + tankB.nutrients.P2O5,
    P: tankA.nutrients.P + tankB.nutrients.P,
    K2O: tankA.nutrients.K2O + tankB.nutrients.K2O,
    K: tankA.nutrients.K + tankB.nutrients.K,
    Ca: tankA.nutrients.Ca + tankB.nutrients.Ca,
    Mg: tankA.nutrients.Mg + tankB.nutrients.Mg,
    S: tankA.nutrients.S + tankB.nutrients.S
  };

  // Tank A
  html += renderTankSection(tankA, volume, mode, 'A', targets, combinedNutrients);

  // Tank B
  html += renderTankSection(tankB, volume, mode, 'B', targets, combinedNutrients);

  // Calculate combined totals
  let totalGramsA = Object.values(tankA.fertilizers).reduce((sum, g) => sum + g, 0);
  let totalGramsB = Object.values(tankB.fertilizers).reduce((sum, g) => sum + g, 0);
  let grandTotalGrams = totalGramsA + totalGramsB;

  // Calculate combined EC
  const combinedEC = calculateECTDS(combinedNutrients);
  const combinedECColor = combinedEC.ec > 3.5 ? '#dc3545' : combinedEC.ec < 0.5 ? '#ffc107' : '#28a745';
  const combinedECStatus = combinedEC.ec > 3.5 ? 'High' : combinedEC.ec < 0.5 ? 'Low' : 'Good';

  // Combined totals note
  html += '<div class="combined-note" style="margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 8px; border-left: 4px solid #007bff;">';
  html += '<h4 style="margin-bottom: 10px;">Combined Solution (when mixed)</h4>';
  html += '<p style="margin-bottom: 10px; color: #666; font-size: 0.9em;">When both tanks are diluted and combined in the final reservoir, you will achieve:</p>';

  const nutrientLabels = mode === 'elemental'
    ? { N: 'N', P: 'P', K: 'K', Ca: 'Ca', Mg: 'Mg', S: 'S' }
    : { N: 'N', P: 'P₂O₅', K: 'K₂O', Ca: 'Ca', Mg: 'Mg', S: 'S' };

  html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">';
  html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>${nutrientLabels.N}:</strong> ${combinedNutrients.N_total.toFixed(1)} ppm</span>`;
  if (mode === 'elemental') {
    html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>${nutrientLabels.P}:</strong> ${combinedNutrients.P.toFixed(1)} ppm</span>`;
    html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>${nutrientLabels.K}:</strong> ${combinedNutrients.K.toFixed(1)} ppm</span>`;
  } else {
    html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>${nutrientLabels.P}:</strong> ${combinedNutrients.P2O5.toFixed(1)} ppm</span>`;
    html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>${nutrientLabels.K}:</strong> ${combinedNutrients.K2O.toFixed(1)} ppm</span>`;
  }
  html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>Ca:</strong> ${combinedNutrients.Ca.toFixed(1)} ppm</span>`;
  html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>Mg:</strong> ${combinedNutrients.Mg.toFixed(1)} ppm</span>`;
  html += `<span style="padding: 5px 10px; background: #fff; border-radius: 4px;"><strong>S:</strong> ${combinedNutrients.S.toFixed(1)} ppm</span>`;
  html += '</div>';

  // EC and Totals row
  html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; padding-top: 10px; border-top: 1px dashed #007bff;">';
  html += `<span style="padding: 5px 10px; background: ${combinedECColor}15; border: 1px solid ${combinedECColor}; border-radius: 4px;"><strong style="color: ${combinedECColor};">Combined EC: ${combinedEC.ec.toFixed(2)} mS/cm (${combinedECStatus})</strong></span>`;
  html += `<span style="padding: 5px 10px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px;"><strong style="color: #2e7d32;">Total: ${grandTotalGrams.toFixed(2)} g</strong> <span style="color: #666; font-size: 0.85em;">(Tank A: ${totalGramsA.toFixed(2)}g + Tank B: ${totalGramsB.toFixed(2)}g)</span></span>`;
  html += '</div>';
  html += '</div>';

  // Back button
  html += '<div style="margin-top: 20px;">';
  html += '<button onclick="restoreSingleTankView(\'' + outputDivId + '\')" style="padding: 10px 20px; font-size: 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">';
  html += 'Back to Single View';
  html += '</button>';
  html += '</div>';

  html += '</div>';

  outputDiv.innerHTML = html;
}

// Render a single tank section
function renderTankSection(tank, volume, mode, tankLetter, targets, combinedNutrients) {
  const bgColor = tankLetter === 'A' ? '#f0f7ff' : '#fff7f0';
  const borderColor = tankLetter === 'A' ? '#007bff' : '#fd7e14';
  const detailsId = `tank-details-${tankLetter}`;

  let html = `<div class="tank-section" style="margin-bottom: 20px; padding: 20px; background: ${bgColor}; border-radius: 8px; border-left: 4px solid ${borderColor};">`;

  // Header with name and Show Details button
  html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">`;
  html += `<h4 style="margin: 0; color: ${borderColor};">${tank.name}</h4>`;

  const fertEntries = Object.entries(tank.fertilizers);
  if (fertEntries.length > 0) {
    html += `<button onclick="toggleTankDetails('${detailsId}')" id="btn-${detailsId}" style="padding: 5px 12px; font-size: 12px; background: ${borderColor}; color: white; border: none; border-radius: 4px; cursor: pointer;">Show Details</button>`;
  }
  html += `</div>`;

  html += `<p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">${tank.description}</p>`;

  // Fertilizers list
  if (fertEntries.length === 0) {
    html += '<p style="color: #999; font-style: italic;">No fertilizers in this tank</p>';
  } else {
    let tankTotal = 0;
    html += '<div class="tank-fertilizers" style="margin-bottom: 15px;">';
    fertEntries.forEach(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      if (fert) {
        tankTotal += grams;
        html += `<div style="display: flex; justify-content: space-between; padding: 8px 12px; background: white; border-radius: 4px; margin-bottom: 5px;">`;
        html += `<span>${fert.name}</span>`;
        html += `<strong>${grams.toFixed(2)} g</strong>`;
        html += `</div>`;
      }
    });
    // Show total for this tank
    if (fertEntries.length > 1) {
      html += `<div style="display: flex; justify-content: space-between; padding: 8px 12px; background: ${borderColor}20; border-radius: 4px; border-top: 2px solid ${borderColor}; margin-top: 5px;">`;
      html += `<span style="color: ${borderColor};"><strong>TOTAL (${fertEntries.length} fertilizers)</strong></span>`;
      html += `<strong style="color: ${borderColor}; font-size: 1.1em;">${tankTotal.toFixed(2)} g</strong>`;
      html += `</div>`;
    }
    html += '</div>';

    // Quick summary - PPM and ion balance in compact form
    const nutrients = tank.nutrients;
    const pVal = mode === 'elemental' ? nutrients.P : nutrients.P2O5;
    const kVal = mode === 'elemental' ? nutrients.K : nutrients.K2O;
    const pLabel = mode === 'elemental' ? 'P' : 'P₂O₅';
    const kLabel = mode === 'elemental' ? 'K' : 'K₂O';

    // Calculate EC for this tank
    const tankEC = calculateECTDS(nutrients);
    const tankECColor = tankEC.ec > 3.5 ? '#dc3545' : tankEC.ec < 0.5 ? '#6c757d' : '#28a745';

    html += '<div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">';
    if (nutrients.N_total > 0.1) html += `<span style="padding: 4px 8px; background: white; border-radius: 4px; font-size: 0.85em;"><strong>N:</strong> ${nutrients.N_total.toFixed(1)}</span>`;
    if (pVal > 0.1) html += `<span style="padding: 4px 8px; background: white; border-radius: 4px; font-size: 0.85em;"><strong>${pLabel}:</strong> ${pVal.toFixed(1)}</span>`;
    if (kVal > 0.1) html += `<span style="padding: 4px 8px; background: white; border-radius: 4px; font-size: 0.85em;"><strong>${kLabel}:</strong> ${kVal.toFixed(1)}</span>`;
    if (nutrients.Ca > 0.1) html += `<span style="padding: 4px 8px; background: white; border-radius: 4px; font-size: 0.85em;"><strong>Ca:</strong> ${nutrients.Ca.toFixed(1)}</span>`;
    if (nutrients.Mg > 0.1) html += `<span style="padding: 4px 8px; background: white; border-radius: 4px; font-size: 0.85em;"><strong>Mg:</strong> ${nutrients.Mg.toFixed(1)}</span>`;
    if (nutrients.S > 0.1) html += `<span style="padding: 4px 8px; background: white; border-radius: 4px; font-size: 0.85em;"><strong>S:</strong> ${nutrients.S.toFixed(1)}</span>`;
    html += `<span style="padding: 4px 8px; background: ${tank.ionBalance.statusColor}20; border: 1px solid ${tank.ionBalance.statusColor}; border-radius: 4px; font-size: 0.85em;"><strong style="color: ${tank.ionBalance.statusColor};">${tank.ionBalance.imbalance.toFixed(1)}% ${tank.ionBalance.statusText}</strong></span>`;
    html += `<span style="padding: 4px 8px; background: ${tankECColor}15; border: 1px solid ${tankECColor}; border-radius: 4px; font-size: 0.85em;"><strong style="color: ${tankECColor};">EC: ${tankEC.ec.toFixed(2)}</strong></span>`;
    html += '</div>';

    // Collapsible details section
    html += `<div id="${detailsId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px dashed ${borderColor};">`;

    // Full PPM Table
    html += '<h5 style="margin-bottom: 10px; color: #333;">Nutrient PPM Values <span class="info-icon" onclick="openTwoTankPPMExplanation()" title="Click to learn how we calculate PPM" style="font-size: 0.7em; width: 18px; height: 18px; line-height: 18px;">?</span></h5>';
    html += '<table style="width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 0.9em;">';
    html += '<tr style="background: white;"><th style="padding: 8px; text-align: left; border-bottom: 1px solid #ddd;">Nutrient</th><th style="padding: 8px; text-align: right; border-bottom: 1px solid #ddd;">PPM</th></tr>';

    const ppmData = [
      { label: 'Nitrogen (N)', value: nutrients.N_total },
      { label: mode === 'elemental' ? 'Phosphorus (P)' : 'Phosphorus (P₂O₅)', value: pVal },
      { label: mode === 'elemental' ? 'Potassium (K)' : 'Potassium (K₂O)', value: kVal },
      { label: 'Calcium (Ca)', value: nutrients.Ca },
      { label: 'Magnesium (Mg)', value: nutrients.Mg },
      { label: 'Sulfur (S)', value: nutrients.S }
    ];

    ppmData.forEach(item => {
      if (item.value > 0.01) {
        html += `<tr style="background: white;"><td style="padding: 8px; border-bottom: 1px solid #eee;">${item.label}</td><td style="padding: 8px; text-align: right; border-bottom: 1px solid #eee;">${item.value.toFixed(2)}</td></tr>`;
      }
    });
    html += '</table>';
    html += '<div style="font-size: 0.8em; color: #666; margin-bottom: 15px; padding: 8px; background: #f8f9fa; border-radius: 4px;"><strong>Note:</strong> PPM (parts per million) = mg/L. Calculated as: (grams × nutrient%) ÷ volume(L) × 1000</div>';

    // Nitrogen form breakdown
    if (nutrients.N_total > 0.1) {
      const nh4Pct = (nutrients.N_NH4 / nutrients.N_total * 100) || 0;
      const no3Pct = (nutrients.N_NO3 / nutrients.N_total * 100) || 0;
      html += '<div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px;">';
      html += '<strong style="font-size: 0.9em;">Nitrogen Forms:</strong><br>';
      html += `<span style="font-size: 0.85em;">NH₄-N: ${nutrients.N_NH4.toFixed(2)} ppm (${nh4Pct.toFixed(1)}%) | NO₃-N: ${nutrients.N_NO3.toFixed(2)} ppm (${no3Pct.toFixed(1)}%)</span>`;
      html += '</div>';
    }

    // NPK:Ca:Mg Ratio relative to original user input
    html += '<h5 style="margin-bottom: 10px; color: #333;">Nutrient Ratios (relative to your input)</h5>';
    html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">';

    // Show the original user-entered ratio and this tank's proportional contribution
    // Tank's contribution = (tank_ppm / combined_ppm) * original_target_value
    if (targets && combinedNutrients) {
      // Use original target values (what user entered), not normalized
      const nTarget = targets.N || 0;
      const pTarget = targets.P || 0;
      const kTarget = targets.K || 0;
      const caTarget = targets.Ca || 0;
      const mgTarget = targets.Mg || 0;

      // Build the ratio label based on what the user entered
      let ratioLabel = 'N';
      let targetRatioValues = nTarget.toString();

      if (pTarget > 0) {
        ratioLabel += `:${pLabel}`;
        targetRatioValues += ` : ${pTarget}`;
      }
      if (kTarget > 0) {
        ratioLabel += `:${kLabel}`;
        targetRatioValues += ` : ${kTarget}`;
      }
      if (caTarget > 0) {
        ratioLabel += ':Ca';
        targetRatioValues += ` : ${caTarget}`;
      }
      if (mgTarget > 0) {
        ratioLabel += ':Mg';
        targetRatioValues += ` : ${mgTarget}`;
      }

      // Show original target ratio (what user entered)
      html += `<div style="padding: 10px 15px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px; text-align: center;">`;
      html += `<div style="font-size: 0.8em; color: #2e7d32;">Target (${ratioLabel})</div>`;
      html += `<div style="font-size: 1.1em; font-weight: bold; color: #2e7d32;">${targetRatioValues}</div>`;
      html += `</div>`;

      // Calculate this tank's contribution as proportion of target
      // Formula: (tank_ppm / combined_ppm) * original_target_value
      // Tank A contrib + Tank B contrib = original target value
      const combinedP = mode === 'elemental' ? combinedNutrients.P : combinedNutrients.P2O5;
      const combinedK = mode === 'elemental' ? combinedNutrients.K : combinedNutrients.K2O;

      const nContrib = combinedNutrients.N_total > 0 ? (nutrients.N_total / combinedNutrients.N_total) * nTarget : 0;
      const pContrib = combinedP > 0 ? (pVal / combinedP) * pTarget : 0;
      const kContrib = combinedK > 0 ? (kVal / combinedK) * kTarget : 0;
      const caContrib = combinedNutrients.Ca > 0 ? (nutrients.Ca / combinedNutrients.Ca) * caTarget : 0;
      const mgContrib = combinedNutrients.Mg > 0 ? (nutrients.Mg / combinedNutrients.Mg) * mgTarget : 0;

      // Build tank ratio values - only include nutrients that the user targeted
      let tankRatioValues = nContrib.toFixed(1);
      if (pTarget > 0) tankRatioValues += ` : ${pContrib.toFixed(1)}`;
      if (kTarget > 0) tankRatioValues += ` : ${kContrib.toFixed(1)}`;
      if (caTarget > 0) tankRatioValues += ` : ${caContrib.toFixed(1)}`;
      if (mgTarget > 0) tankRatioValues += ` : ${mgContrib.toFixed(1)}`;

      html += `<div style="padding: 10px 15px; background: white; border-radius: 4px; text-align: center;">`;
      html += `<div style="font-size: 0.8em; color: #666;">This Tank (${ratioLabel})</div>`;
      html += `<div style="font-size: 1.1em; font-weight: bold;">${tankRatioValues}</div>`;
      html += `</div>`;
    }

    // Ca:Mg ratio
    if (nutrients.Ca > 0.1 && nutrients.Mg > 0.1) {
      const caMgRatio = (nutrients.Ca / nutrients.Mg).toFixed(2);
      html += `<div style="padding: 10px 15px; background: white; border-radius: 4px; text-align: center;">`;
      html += `<div style="font-size: 0.8em; color: #666;">Ca:Mg</div>`;
      html += `<div style="font-size: 1.1em; font-weight: bold;">${caMgRatio} : 1</div>`;
      html += `</div>`;
    }

    // N:Ca ratio
    if (nutrients.N_total > 0.1 && nutrients.Ca > 0.1) {
      const nCaRatio = (nutrients.N_total / nutrients.Ca).toFixed(2);
      html += `<div style="padding: 10px 15px; background: white; border-radius: 4px; text-align: center;">`;
      html += `<div style="font-size: 0.8em; color: #666;">N:Ca</div>`;
      html += `<div style="font-size: 1.1em; font-weight: bold;">${nCaRatio} : 1</div>`;
      html += `</div>`;
    }

    // K:Ca ratio
    if (kVal > 0.1 && nutrients.Ca > 0.1) {
      const kCaRatio = (kVal / nutrients.Ca).toFixed(2);
      html += `<div style="padding: 10px 15px; background: white; border-radius: 4px; text-align: center;">`;
      html += `<div style="font-size: 0.8em; color: #666;">${kLabel}:Ca</div>`;
      html += `<div style="font-size: 1.1em; font-weight: bold;">${kCaRatio} : 1</div>`;
      html += `</div>`;
    }

    html += '</div>';

    // Ion balance details
    html += '<h5 style="margin-bottom: 10px; color: #333;">Ion Balance Details <span class="info-icon" onclick="openTwoTankIonBalanceExplanation()" title="Click to learn how we calculate Ion Balance" style="font-size: 0.7em; width: 18px; height: 18px; line-height: 18px;">?</span></h5>';
    html += '<div style="display: flex; gap: 15px; flex-wrap: wrap;">';
    html += `<div style="padding: 10px 15px; background: white; border-radius: 4px;">`;
    html += `<div style="font-size: 0.8em; color: #666;">Total Cations</div>`;
    html += `<div style="font-size: 1.1em; font-weight: bold;">${tank.ionBalance.totalCations.toFixed(2)} meq/L</div>`;
    html += `</div>`;
    html += `<div style="padding: 10px 15px; background: white; border-radius: 4px;">`;
    html += `<div style="font-size: 0.8em; color: #666;">Total Anions</div>`;
    html += `<div style="font-size: 1.1em; font-weight: bold;">${tank.ionBalance.totalAnions.toFixed(2)} meq/L</div>`;
    html += `</div>`;
    html += `<div style="padding: 10px 15px; background: ${tank.ionBalance.statusColor}20; border: 1px solid ${tank.ionBalance.statusColor}; border-radius: 4px;">`;
    html += `<div style="font-size: 0.8em; color: #666;">Imbalance</div>`;
    html += `<div style="font-size: 1.1em; font-weight: bold; color: ${tank.ionBalance.statusColor};">${tank.ionBalance.imbalance.toFixed(1)}%</div>`;
    html += `<div style="font-size: 0.8em; color: ${tank.ionBalance.statusColor};">${tank.ionBalance.statusText}</div>`;
    html += `</div>`;
    html += '</div>';
    html += '<div style="font-size: 0.8em; color: #666; margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px;"><strong>What is ion balance?</strong> Fertilizers dissolve into charged ions (cations like K⁺, Ca²⁺, NH₄⁺ and anions like NO₃⁻, SO₄²⁻, H₂PO₄⁻). Imbalance ≤10% is good; higher values may cause pH swings.</div>';

    html += '</div>'; // End details section
  }

  html += '</div>';
  return html;
}

// Toggle tank details visibility
function toggleTankDetails(detailsId) {
  const details = document.getElementById(detailsId);
  const btn = document.getElementById('btn-' + detailsId);

  if (details.style.display === 'none') {
    details.style.display = 'block';
    btn.textContent = 'Hide Details';
  } else {
    details.style.display = 'none';
    btn.textContent = 'Show Details';
  }
}

// Copy two-tank results to clipboard
function copyTwoTankResults() {
  if (!currentTwoTankData) {
    alert('No two-tank data to copy.');
    return;
  }

  const { tankA, tankB, volume, mode, achieved } = currentTwoTankData;
  const pLabel = mode === 'elemental' ? 'P' : 'P₂O₅';
  const kLabel = mode === 'elemental' ? 'K' : 'K₂O';

  let text = '═══════════════════════════════════════════\n';
  text += '       TWO-TANK STOCK SOLUTION SYSTEM\n';
  text += '═══════════════════════════════════════════\n';
  text += `Volume: ${volume}L per tank\n\n`;

  // Tank A
  text += generateTankCopyText(tankA, 'A', mode, pLabel, kLabel);

  // Tank B
  text += generateTankCopyText(tankB, 'B', mode, pLabel, kLabel);

  // Combined solution
  const combinedNutrients = {
    N_total: tankA.nutrients.N_total + tankB.nutrients.N_total,
    N_NH4: tankA.nutrients.N_NH4 + tankB.nutrients.N_NH4,
    N_NO3: tankA.nutrients.N_NO3 + tankB.nutrients.N_NO3,
    P2O5: tankA.nutrients.P2O5 + tankB.nutrients.P2O5,
    P: tankA.nutrients.P + tankB.nutrients.P,
    K2O: tankA.nutrients.K2O + tankB.nutrients.K2O,
    K: tankA.nutrients.K + tankB.nutrients.K,
    Ca: tankA.nutrients.Ca + tankB.nutrients.Ca,
    Mg: tankA.nutrients.Mg + tankB.nutrients.Mg,
    S: tankA.nutrients.S + tankB.nutrients.S
  };

  text += '═══════════════════════════════════════════\n';
  text += '         COMBINED SOLUTION (Final Mix)\n';
  text += '═══════════════════════════════════════════\n\n';

  text += 'PPM Values:\n';
  text += '───────────────────────────────────────────\n';
  text += `  Nitrogen (N):      ${combinedNutrients.N_total.toFixed(2)} ppm\n`;
  const pVal = mode === 'elemental' ? combinedNutrients.P : combinedNutrients.P2O5;
  const kVal = mode === 'elemental' ? combinedNutrients.K : combinedNutrients.K2O;
  text += `  ${pLabel.padEnd(16)} ${pVal.toFixed(2)} ppm\n`;
  text += `  ${kLabel.padEnd(16)} ${kVal.toFixed(2)} ppm\n`;
  text += `  Calcium (Ca):      ${combinedNutrients.Ca.toFixed(2)} ppm\n`;
  text += `  Magnesium (Mg):    ${combinedNutrients.Mg.toFixed(2)} ppm\n`;
  text += `  Sulfur (S):        ${combinedNutrients.S.toFixed(2)} ppm\n\n`;

  // Nitrogen forms
  if (combinedNutrients.N_total > 0.1) {
    const nh4Pct = (combinedNutrients.N_NH4 / combinedNutrients.N_total * 100) || 0;
    const no3Pct = (combinedNutrients.N_NO3 / combinedNutrients.N_total * 100) || 0;
    text += 'Nitrogen Forms:\n';
    text += `  NH₄-N: ${combinedNutrients.N_NH4.toFixed(2)} ppm (${nh4Pct.toFixed(1)}%)\n`;
    text += `  NO₃-N: ${combinedNutrients.N_NO3.toFixed(2)} ppm (${no3Pct.toFixed(1)}%)\n\n`;
  }

  // Combined ratios
  const npkValues = [combinedNutrients.N_total, pVal, kVal].filter(v => v > 0.1);
  if (npkValues.length > 0) {
    const minNPK = Math.min(...npkValues);
    text += 'Nutrient Ratios:\n';
    text += '───────────────────────────────────────────\n';
    text += `  N:${pLabel}:${kLabel} = ${(combinedNutrients.N_total/minNPK).toFixed(1)} : ${(pVal/minNPK).toFixed(1)} : ${(kVal/minNPK).toFixed(1)}\n`;
    if (combinedNutrients.Ca > 0.1 && combinedNutrients.Mg > 0.1) {
      text += `  Ca:Mg = ${(combinedNutrients.Ca/combinedNutrients.Mg).toFixed(2)} : 1\n`;
    }
  }

  text += '\n═══════════════════════════════════════════\n';
  text += 'Generated by Fertilizer Calculator\n';
  text += 'https://bhattumang7.github.io/pages/fertilizer-calculator.html\n';
  text += '═══════════════════════════════════════════\n';

  navigator.clipboard.writeText(text).then(() => {
    // Show success feedback
    const btn = event.target.closest('button');
    const originalText = btn.innerHTML;
    btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!';
    btn.style.background = '#28a745';
    setTimeout(() => {
      btn.innerHTML = originalText;
      btn.style.background = '';
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    alert('Failed to copy to clipboard');
  });
}

// Generate copy text for a single tank
function generateTankCopyText(tank, letter, mode, pLabel, kLabel) {
  let text = '';
  text += `───────────────────────────────────────────\n`;
  text += `  TANK ${letter}: ${tank.name.replace('Tank ' + letter + ' ', '').toUpperCase()}\n`;
  text += `───────────────────────────────────────────\n`;
  text += `${tank.description}\n\n`;

  const fertEntries = Object.entries(tank.fertilizers);
  if (fertEntries.length === 0) {
    text += 'No fertilizers in this tank\n\n';
    return text;
  }

  text += 'Fertilizers:\n';
  fertEntries.forEach(([fertId, grams]) => {
    const fert = FERTILIZERS.find(f => f.id === fertId);
    if (fert) {
      text += `  • ${fert.name}: ${grams.toFixed(2)} g\n`;
    }
  });
  text += '\n';

  // PPM values
  const nutrients = tank.nutrients;
  const pVal = mode === 'elemental' ? nutrients.P : nutrients.P2O5;
  const kVal = mode === 'elemental' ? nutrients.K : nutrients.K2O;

  text += 'PPM Values:\n';
  if (nutrients.N_total > 0.01) text += `  Nitrogen (N):      ${nutrients.N_total.toFixed(2)} ppm\n`;
  if (pVal > 0.01) text += `  ${pLabel.padEnd(16)} ${pVal.toFixed(2)} ppm\n`;
  if (kVal > 0.01) text += `  ${kLabel.padEnd(16)} ${kVal.toFixed(2)} ppm\n`;
  if (nutrients.Ca > 0.01) text += `  Calcium (Ca):      ${nutrients.Ca.toFixed(2)} ppm\n`;
  if (nutrients.Mg > 0.01) text += `  Magnesium (Mg):    ${nutrients.Mg.toFixed(2)} ppm\n`;
  if (nutrients.S > 0.01) text += `  Sulfur (S):        ${nutrients.S.toFixed(2)} ppm\n`;
  text += '\n';

  // Nitrogen forms
  if (nutrients.N_total > 0.1) {
    const nh4Pct = (nutrients.N_NH4 / nutrients.N_total * 100) || 0;
    const no3Pct = (nutrients.N_NO3 / nutrients.N_total * 100) || 0;
    text += 'Nitrogen Forms:\n';
    text += `  NH₄-N: ${nutrients.N_NH4.toFixed(2)} ppm (${nh4Pct.toFixed(1)}%)\n`;
    text += `  NO₃-N: ${nutrients.N_NO3.toFixed(2)} ppm (${no3Pct.toFixed(1)}%)\n\n`;
  }

  // Ratios
  const npkValues = [nutrients.N_total, pVal, kVal].filter(v => v > 0.1);
  if (npkValues.length > 0 || (nutrients.Ca > 0.1 && nutrients.Mg > 0.1)) {
    text += 'Ratios:\n';
    if (npkValues.length > 0) {
      const minNPK = Math.min(...npkValues);
      text += `  N:${pLabel}:${kLabel} = ${(nutrients.N_total/minNPK).toFixed(1)} : ${(pVal/minNPK).toFixed(1)} : ${(kVal/minNPK).toFixed(1)}\n`;
    }
    if (nutrients.Ca > 0.1 && nutrients.Mg > 0.1) {
      text += `  Ca:Mg = ${(nutrients.Ca/nutrients.Mg).toFixed(2)} : 1\n`;
    }
    if (nutrients.N_total > 0.1 && nutrients.Ca > 0.1) {
      text += `  N:Ca = ${(nutrients.N_total/nutrients.Ca).toFixed(2)} : 1\n`;
    }
    text += '\n';
  }

  // Ion balance
  text += 'Ion Balance:\n';
  text += `  Cations: ${tank.ionBalance.totalCations.toFixed(2)} meq/L\n`;
  text += `  Anions:  ${tank.ionBalance.totalAnions.toFixed(2)} meq/L\n`;
  text += `  Balance: ${tank.ionBalance.imbalance.toFixed(1)}% (${tank.ionBalance.statusText})\n\n`;

  return text;
}

// Restore single tank view
function restoreSingleTankView(outputDivId) {
  // Show header buttons again
  let headerButtonsId;
  if (outputDivId === 'formula-output') {
    headerButtonsId = 'formula-header-buttons';
  } else if (outputDivId === 'reverse-output') {
    headerButtonsId = 'reverse-header-buttons';
  } else if (outputDivId === 'selected-fertilizers-list') {
    headerButtonsId = 'grams-to-ppm-header-buttons';
  }
  const headerButtons = document.getElementById(headerButtonsId);
  if (headerButtons) {
    headerButtons.style.display = 'flex';
  }

  if (outputDivId === 'formula-output' && lastFormulaCalculation) {
    displayFormulaResults(
      lastFormulaCalculation.result,
      lastFormulaCalculation.targets,
      lastFormulaCalculation.volume,
      lastFormulaCalculation.mode
    );
  } else if (outputDivId === 'reverse-output' && lastReverseCalculation) {
    displayReverseResults(
      lastReverseCalculation.result,
      lastReverseCalculation.targets,
      lastReverseCalculation.volume,
      lastReverseCalculation.targetEC
    );
  } else if (outputDivId === 'selected-fertilizers-list' && lastGramsToPPMCalculation) {
    // For Grams to PPM, re-display the selected fertilizers list
    displaySelectedFertilizers(lastGramsToPPMCalculation.activeFertilizers);
  }
}

// ============================================================================
// REVERSE CALCULATOR FUNCTIONS
// ============================================================================

// Render reverse fertilizers list
function renderReverseFertilizersList() {
  const container = document.getElementById('reverse-fertilizers-list');
  if (!container) return;

  container.innerHTML = '';

  FERTILIZERS.forEach(fert => {
    const item = document.createElement('div');
    item.className = 'fertilizer-checkbox-item';
    item.id = `reverse-item-${fert.id}`;

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `reverse-${fert.id}`;
    checkbox.checked = COMMON_FERTILIZERS.includes(fert.id); // Pre-select common fertilizers

    const label = document.createElement('label');
    label.htmlFor = `reverse-${fert.id}`;

    const nameSpan = document.createElement('span');
    nameSpan.className = 'fertilizer-label-name';
    nameSpan.textContent = fert.name;
    label.appendChild(nameSpan);

    if (fert.aliases && fert.aliases.length > 0) {
      const aliasSpan = document.createElement('span');
      aliasSpan.className = 'fertilizer-label-aliases';
      aliasSpan.textContent = fert.aliases.join(', ');
      label.appendChild(aliasSpan);
    }

    item.appendChild(checkbox);
    item.appendChild(label);
    container.appendChild(item);
  });
}

// Select all reverse fertilizers
function selectAllReverseFertilizers() {
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`reverse-${fert.id}`);
    if (checkbox) checkbox.checked = true;
  });
}

// Deselect all reverse fertilizers
function deselectAllReverseFertilizers() {
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`reverse-${fert.id}`);
    if (checkbox) checkbox.checked = false;
  });
}

// Select only common reverse fertilizers
function selectCommonReverseFertilizers() {
  FERTILIZERS.forEach(fert => {
    const checkbox = document.getElementById(`reverse-${fert.id}`);
    if (checkbox) {
      checkbox.checked = COMMON_FERTILIZERS.includes(fert.id);
    }
  });
}

// Filter reverse fertilizers based on search term
function filterReverseFertilizers(searchTerm) {
  const normalizedSearch = searchTerm.toLowerCase().trim();

  FERTILIZERS.forEach(fert => {
    const item = document.getElementById(`reverse-item-${fert.id}`);
    if (!item) return;

    // Search in name and aliases
    const nameMatch = fert.name.toLowerCase().includes(normalizedSearch);
    const aliasMatch = fert.aliases && fert.aliases.some(alias =>
      alias.toLowerCase().includes(normalizedSearch)
    );

    // Show/hide based on match
    if (nameMatch || aliasMatch || normalizedSearch === '') {
      item.style.display = '';
    } else {
      item.style.display = 'none';
    }
  });
}

// Clear reverse calculator
// Update input labels based on calculation mode
function updateReverseCalculationMode() {
  const mode = document.getElementById('reverse-calculation-mode').value;
  const pLabel = document.querySelector('label[for="reverse-p"]');
  const kLabel = document.querySelector('label[for="reverse-k"]');

  if (mode === 'elemental') {
    pLabel.textContent = 'Phosphorus (P)';
    kLabel.textContent = 'Potassium (K)';
  } else {
    pLabel.textContent = 'Phosphorus (P₂O₅)';
    kLabel.textContent = 'Potassium (K₂O)';
  }
}

// Update input labels for formula builder based on calculation mode
function updateFormulaCalculationMode() {
  const mode = document.getElementById('formula-calculation-mode').value;
  const pLabel = document.getElementById('target-p-label');
  const kLabel = document.getElementById('target-k-label');

  if (mode === 'elemental') {
    pLabel.textContent = 'Phosphorus (P) *';
    kLabel.textContent = 'Potassium (K) *';
  } else {
    pLabel.textContent = 'Phosphorus (P₂O₅) *';
    kLabel.textContent = 'Potassium (K₂O) *';
  }
}

function clearReverseCalculator() {
  // Clear target inputs and remove error states
  const targetIds = ['reverse-n', 'reverse-p', 'reverse-k', 'reverse-ca', 'reverse-mg', 'reverse-s', 'reverse-si'];
  targetIds.forEach(id => {
    const input = document.getElementById(id);
    if (input) {
      input.value = id === 'reverse-si' ? '0' : '';  // Si defaults to 0
      input.classList.remove('input-error');
    }
  });

  // Reset volume
  const volumeInput = document.getElementById('reverse-volume');
  if (volumeInput) {
    volumeInput.value = '10';
    volumeInput.classList.remove('input-error');
  }

  // Reset fertilizer selections to common only
  selectCommonReverseFertilizers();

  // Clear search box
  const searchInput = document.getElementById('reverse-fertilizer-search');
  if (searchInput) {
    searchInput.value = '';
    filterReverseFertilizers('');
  }

  // Hide results
  const resultsSection = document.getElementById('reverse-results');
  if (resultsSection) {
    resultsSection.style.display = 'none';
  }
}

// Main reverse calculator function
async function calculateReverse() {
  // Get target values
  // Note: P and K inputs are treated as P2O5 and K2O (industry standard N-P2O5-K2O)
  const targets = {
    N: parseFloat(document.getElementById('reverse-n').value) || 0,
    P: parseFloat(document.getElementById('reverse-p').value) || 0,
    K: parseFloat(document.getElementById('reverse-k').value) || 0,
    Ca: parseFloat(document.getElementById('reverse-ca').value) || 0,
    Mg: parseFloat(document.getElementById('reverse-mg').value) || 0,
    S: parseFloat(document.getElementById('reverse-s').value) || 0,
    Si: parseFloat(document.getElementById('reverse-si').value) || 0
  };

  const volume = parseFloat(document.getElementById('reverse-volume').value) || 10;
  const concentrationValue = document.getElementById('reverse-concentration').value;

  // Check if targeting EC or PPM base
  let targetEC = null;
  let concentration = 100;  // Default reference concentration for EC-based calculation

  if (concentrationValue.startsWith('ec:')) {
    targetEC = parseFloat(concentrationValue.substring(3));
  } else {
    concentration = parseFloat(concentrationValue) || 75;
  }

  // Validate inputs
  let hasError = false;
  const allNutrientFields = ['reverse-n', 'reverse-p', 'reverse-k', 'reverse-ca', 'reverse-mg', 'reverse-s', 'reverse-si'];

  // Validate all nutrient fields - must be valid numbers >= 0 or blank (treated as 0)
  allNutrientFields.forEach(id => {
    const input = document.getElementById(id);
    const value = input.value.trim();

    // Allow empty fields (treated as 0) or valid numbers >= 0
    if (value !== '' && (isNaN(parseFloat(value)) || parseFloat(value) < 0)) {
      input.classList.add('input-error');
      hasError = true;
    } else {
      input.classList.remove('input-error');
    }
  });

  // Check that at least one nutrient has a value > 0
  const hasAtLeastOneNutrient = Object.values(targets).some(val => val > 0);
  if (!hasAtLeastOneNutrient) {
    alert('Please enter at least one nutrient value greater than zero.');
    return;
  }

  // Validate volume
  const volumeInput = document.getElementById('reverse-volume');
  if (!volume || volume <= 0) {
    volumeInput.classList.add('input-error');
    hasError = true;
  } else {
    volumeInput.classList.remove('input-error');
  }

  if (hasError) {
    alert('Please fill in all nutrient fields with valid values (0 or greater). At least one nutrient must be greater than zero.');
    return;
  }

  // Get selected fertilizers
  const selectedFertilizers = FERTILIZERS.filter(fert => {
    const checkbox = document.getElementById(`reverse-${fert.id}`);
    return checkbox && checkbox.checked;
  });

  if (selectedFertilizers.length === 0) {
    alert('Please select at least one fertilizer to use.');
    return;
  }

  // Get calculation mode (oxide vs elemental)
  const calculationMode = document.getElementById('reverse-calculation-mode').value;

  // Show progress bar
  progressBar.show('Calculating Fertilizers');
  progressBar.update(10, 'Validating inputs...');

  try {
    // Allow UI to update
    await new Promise(resolve => setTimeout(resolve, 50));

    progressBar.update(30, 'Preparing optimization model...');
    await new Promise(resolve => setTimeout(resolve, 50));

    progressBar.update(50, 'Running MILP solver...');
    progressBar.setIndeterminate('Optimizing fertilizer combination...');

    // Run optimization
    let result = await optimizeFormula(targets, volume, selectedFertilizers, concentration, calculationMode, { useMilp: true });

    // If targeting EC, scale fertilizer amounts to achieve target EC
    if (targetEC !== null && Object.keys(result.formula).length > 0) {
      progressBar.update(70, 'Scaling to target EC...');
      await new Promise(resolve => setTimeout(resolve, 50));

      // Calculate predicted EC from initial result
      const initialEC = estimateECFromPPM(result.achieved);
      const predictedEC = initialEC.ec_mS_cm;

      if (predictedEC > 0) {
        // Scale factor to achieve target EC
        const scaleFactor = targetEC / predictedEC;

        // Scale all fertilizer grams
        const scaledFormula = {};
        for (const [fertId, grams] of Object.entries(result.formula)) {
          scaledFormula[fertId] = grams * scaleFactor;
        }

        // Recalculate achieved values based on scaled grams
        const scaledAchieved = {
          N_total: result.achieved.N_total * scaleFactor,
          N_NO3: result.achieved.N_NO3 * scaleFactor,
          N_NH4: result.achieved.N_NH4 * scaleFactor,
          P2O5: result.achieved.P2O5 * scaleFactor,
          K2O: result.achieved.K2O * scaleFactor,
          P: result.achieved.P * scaleFactor,
          K: result.achieved.K * scaleFactor,
          Ca: result.achieved.Ca * scaleFactor,
          Mg: result.achieved.Mg * scaleFactor,
          S: result.achieved.S * scaleFactor,
          Si: result.achieved.Si * scaleFactor
        };

        // Update result with scaled values
        result = {
          ...result,
          formula: scaledFormula,
          achieved: scaledAchieved,
          ecScaling: {
            targetEC: targetEC,
            initialEC: predictedEC,
            scaleFactor: scaleFactor
          }
        };
      }
    }

    progressBar.update(90, 'Preparing results...');
    await new Promise(resolve => setTimeout(resolve, 50));

    progressBar.update(100, 'Complete!');
    await new Promise(resolve => setTimeout(resolve, 200));

    // Hide progress bar
    progressBar.hide();

    // Display results
    displayReverseResults(result, targets, volume, targetEC);
  } catch (error) {
    progressBar.hide();
    console.error('Reverse calculation error:', error);
    alert('An error occurred during calculation. Please try again.');
  }
}

// Store last reverse calculation result for explanation modals
let lastReverseCalculation = null;

// Display reverse calculator results
function displayReverseResults(result, targets, volume, targetEC = null) {
  // Get calculation mode for storage
  const mode = document.getElementById('reverse-calculation-mode').value;
  // Store data for explanation modals and two-tank feature
  lastReverseCalculation = { result, targets, volume, mode, targetEC };

  const resultsSection = document.getElementById('reverse-results');
  const outputDiv = document.getElementById('reverse-output');

  resultsSection.style.display = 'block';

  let html = '<div class="formula-result"><h3>Fertilizers to Add (per ' + volume + 'L)</h3>';

  // Display formula
  if (Object.keys(result.formula).length === 0) {
    html += '<div class="error-box"><strong>Unable to calculate formula</strong><p>The selected fertilizers cannot achieve the target nutrient ratios. Try selecting different fertilizers or adjusting your targets.</p></div>';
  } else {
    let totalGrams = 0;
    let fertCount = 0;

    Object.entries(result.formula).forEach(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      if (fert && grams > 0.01) { // Only show if significant amount
        totalGrams += grams;
        fertCount++;
        const composition = Object.entries(fert.pct)
          .map(([key, val]) => `${key}: ${val}%`)
          .join(', ');
        html += `
          <div class="formula-fertilizer">
            <div class="formula-fertilizer-info">
              <div class="formula-fertilizer-name">${fert.name}</div>
              <div class="formula-fertilizer-composition">${composition}</div>
            </div>
            <div class="formula-fertilizer-amount">${grams.toFixed(2)} g</div>
          </div>
        `;
      }
    });

    // Show total
    if (fertCount > 1) {
      html += `
        <div class="formula-fertilizer" style="border-top: 2px solid #007bff; margin-top: 10px; padding-top: 10px; background: #e3f2fd;">
          <div class="formula-fertilizer-info">
            <div class="formula-fertilizer-name" style="color: #007bff;"><strong>TOTAL (${fertCount} fertilizers)</strong></div>
            <div class="formula-fertilizer-composition">${(totalGrams / volume).toFixed(2)} g/L</div>
          </div>
          <div class="formula-fertilizer-amount" style="color: #007bff; font-size: 1.2em;"><strong>${totalGrams.toFixed(2)} g</strong></div>
        </div>
      `;
    }
  }

  html += '</div>';

  // Note: Input values for P and K are treated as commercial oxide forms (P2O5, K2O)
  // This matches standard fertilizer labeling conventions
  // We'll display both oxide and elemental forms in the results table

  // Calculate achieved ratios using COMMERCIAL values (N:P2O5:K2O)
  // Note: Si is treated as absolute PPM, not as a ratio
  const achievedPPM_Commercial = {
    N: result.achieved.N_total,
    P2O5: result.achieved.P2O5,
    K2O: result.achieved.K2O,
    Ca: result.achieved.Ca,
    Mg: result.achieved.Mg,
    S: result.achieved.S
  };

  // Normalize achieved values to ratios (find smallest non-zero value) - excluding Si
  const achievedValues = Object.values(achievedPPM_Commercial).filter(v => v > 0);
  const minAchieved = achievedValues.length > 0 ? Math.min(...achievedValues) : 1;
  const achievedRatios = {
    N: achievedPPM_Commercial.N > 0 ? achievedPPM_Commercial.N / minAchieved : 0,
    P2O5: achievedPPM_Commercial.P2O5 > 0 ? achievedPPM_Commercial.P2O5 / minAchieved : 0,
    K2O: achievedPPM_Commercial.K2O > 0 ? achievedPPM_Commercial.K2O / minAchieved : 0,
    Ca: achievedPPM_Commercial.Ca > 0 ? achievedPPM_Commercial.Ca / minAchieved : 0,
    Mg: achievedPPM_Commercial.Mg > 0 ? achievedPPM_Commercial.Mg / minAchieved : 0,
    S: achievedPPM_Commercial.S > 0 ? achievedPPM_Commercial.S / minAchieved : 0
  };
  // Si is stored as absolute PPM
  const achievedSiPPM = result.achieved.Si || 0;

  // Normalize target values to ratios - excluding Si
  const targetNutrients = { N: targets.N, P: targets.P, K: targets.K, Ca: targets.Ca, Mg: targets.Mg, S: targets.S };
  const targetValues = Object.values(targetNutrients).filter(v => v > 0);
  const minTarget = targetValues.length > 0 ? Math.min(...targetValues) : 1;
  const targetRatios = {
    N: targets.N > 0 ? targets.N / minTarget : 0,
    P2O5: targets.P > 0 ? targets.P / minTarget : 0,  // P input is treated as P2O5
    K2O: targets.K > 0 ? targets.K / minTarget : 0,   // K input is treated as K2O
    Ca: targets.Ca > 0 ? targets.Ca / minTarget : 0,
    Mg: targets.Mg > 0 ? targets.Mg / minTarget : 0,
    S: targets.S > 0 ? targets.S / minTarget : 0
  };
  // Si target is absolute PPM
  const targetSiPPM = targets.Si || 0;

  // Get calculation mode preference
  const calculationMode = document.getElementById('reverse-calculation-mode').value; // 'oxide' or 'elemental'

  // Comparison table - showing nutrients based on selected mode
  html += '<h3>Target vs Achieved Ratios <span class="info-icon" onclick="openReversePPMExplanation()" title="Click to learn how we calculate PPM">?</span></h3>';
  html += '<div class="comparison-table-wrapper">';
  html += '<table class="comparison-table">';
  html += '<tr><th>Nutrient</th><th>Target Ratio</th><th>Achieved Ratio</th><th>PPM Achieved</th></tr>';

  // Display nutrients based on calculation mode
  let displayNutrients;
  if (calculationMode === 'elemental') {
    // Elemental mode: Show P and K (pure elements)
    displayNutrients = [
      { key: 'N', label: 'Nitrogen (N)', isCommercial: false },
      { key: 'P', label: 'Phosphorus (P)', isCommercial: false },
      { key: 'K', label: 'Potassium (K)', isCommercial: false },
      { key: 'Ca', label: 'Calcium (Ca)', isCommercial: false },
      { key: 'Mg', label: 'Magnesium (Mg)', isCommercial: false },
      { key: 'S', label: 'Sulfur (S)', isCommercial: false },
      { key: 'Si', label: 'Silicon (Si)', isCommercial: false }
    ];
  } else {
    // Oxide mode: Show P₂O₅ and K₂O (commercial standard)
    displayNutrients = [
      { key: 'N', label: 'Nitrogen (N)', isCommercial: false },
      { key: 'P2O5', label: 'Phosphorus (P₂O₅)', isCommercial: true },
      { key: 'K2O', label: 'Potassium (K₂O)', isCommercial: true },
      { key: 'Ca', label: 'Calcium (Ca)', isCommercial: false },
      { key: 'Mg', label: 'Magnesium (Mg)', isCommercial: false },
      { key: 'S', label: 'Sulfur (S)', isCommercial: false },
      { key: 'Si', label: 'Silicon (Si)', isCommercial: false }
    ];
  }

  let allGood = true;
  const warnings = [];

  displayNutrients.forEach(nutrient => {
    let targetRatio, achievedRatio, achievedPPM;

    // Get the ratio values for comparison (normalized)
    if (nutrient.key === 'N') {
      targetRatio = targetRatios.N || 0;
      achievedRatio = achievedRatios.N || 0;
      achievedPPM = result.achieved.N_total || 0;
    } else if (nutrient.key === 'P') {
      // Elemental P - use P2O5 ratio but show elemental PPM
      targetRatio = targetRatios.P2O5 || 0;
      achievedRatio = achievedRatios.P2O5 || 0;
      achievedPPM = result.achieved.P || 0;
    } else if (nutrient.key === 'P2O5') {
      // Oxide form P2O5 (commercial)
      targetRatio = targetRatios.P2O5 || 0;
      achievedRatio = achievedRatios.P2O5 || 0;
      achievedPPM = result.achieved.P2O5 || 0;
    } else if (nutrient.key === 'K') {
      // Elemental K - use K2O ratio but show elemental PPM
      targetRatio = targetRatios.K2O || 0;
      achievedRatio = achievedRatios.K2O || 0;
      achievedPPM = result.achieved.K || 0;
    } else if (nutrient.key === 'K2O') {
      // Oxide form K2O (commercial)
      targetRatio = targetRatios.K2O || 0;
      achievedRatio = achievedRatios.K2O || 0;
      achievedPPM = result.achieved.K2O || 0;
    } else if (nutrient.key === 'Si') {
      // Silicon is treated as absolute PPM, not ratio
      // Handle specially below
      targetRatio = null;
      achievedRatio = null;
      achievedPPM = achievedSiPPM;
    } else {
      // Ca, Mg, S - already elemental
      targetRatio = targetRatios[nutrient.key] || 0;
      achievedRatio = achievedRatios[nutrient.key] || 0;
      achievedPPM = result.achieved[nutrient.key] || 0;
    }

    // Special handling for Silicon (PPM-based, not ratio-based)
    if (nutrient.key === 'Si') {
      // Skip if both target and achieved are zero
      if (targetSiPPM === 0 && achievedSiPPM === 0) return;

      // Compare absolute PPM values for Si
      const ppmDiff = targetSiPPM > 0 ? Math.abs((achievedSiPPM - targetSiPPM) / targetSiPPM * 100) : 0;

      let className = 'match';
      let status = '✓';

      if (ppmDiff > 20) {
        className = 'miss';
        status = '✗';
        allGood = false;
        warnings.push(`${nutrient.label} is ${ppmDiff.toFixed(1)}% off target PPM`);
      } else if (ppmDiff > 10) {
        className = 'close';
        status = '⚠';
        warnings.push(`${nutrient.label} is ${ppmDiff.toFixed(1)}% off target PPM (acceptable range)`);
      }

      html += `
        <tr>
          <td>${nutrient.label} <small style="color:#666">(PPM)</small></td>
          <td>${Number(targetSiPPM || 0).toFixed(1)} ppm</td>
          <td class="${className}">${Number(achievedSiPPM || 0).toFixed(1)} ppm ${status}</td>
          <td>${Number(achievedSiPPM || 0).toFixed(1)} ppm</td>
        </tr>
      `;
      return;
    }

    // Skip if both target and achieved are zero
    if (targetRatio === 0 && achievedRatio === 0) return;

    // Compare RATIOS, not absolute PPM values
    const ratioDiff = targetRatio > 0 ? Math.abs((achievedRatio - targetRatio) / targetRatio * 100) : 0;

    let className = 'match';
    let status = '✓';

    if (ratioDiff > 15) {
      className = 'miss';
      status = '✗';
      allGood = false;
      if (!nutrient.isCommercial) {  // Only warn once for elemental form
        warnings.push(`${nutrient.label} ratio is ${ratioDiff.toFixed(1)}% off target`);
      }
    } else if (ratioDiff > 5) {
      className = 'close';
      status = '⚠';
      if (!nutrient.isCommercial) {  // Only warn once for elemental form
        warnings.push(`${nutrient.label} ratio is ${ratioDiff.toFixed(1)}% off target (acceptable range)`);
      }
    }

    html += `
      <tr>
        <td>${nutrient.label}</td>
        <td>${Number(targetRatio || 0).toFixed(2)}</td>
        <td class="${className}">${Number(achievedRatio || 0).toFixed(2)} ${status}</td>
        <td>${Number(achievedPPM || 0).toFixed(1)} ppm</td>
      </tr>
    `;
  });

  html += '</table>';
  html += '</div>';

  // Add mode-specific conversion note
  if (calculationMode === 'elemental') {
    html += `<div class="conversion-note" style="margin-top: 15px;">
      <strong>Elemental Mode:</strong> Values shown are pure elements (P, K).
      <br>
      To convert to oxide forms: P₂O₅ = P × 2.29, K₂O = K × 1.20
    </div>`;
  } else {
    html += `<div class="conversion-note" style="margin-top: 15px;">
      <strong>Oxide Mode:</strong> Values shown are commercial oxide forms (P₂O₅, K₂O).
      <br>
      To convert to elements: P = P₂O₅ × 0.436, K = K₂O × 0.830
    </div>`;
  }

  // NH4-N percentage
  const nh4Percent = result.achieved.N_total > 0 ? (result.achieved.N_NH4 / result.achieved.N_total * 100) : 0;
  html += `<div class="conversion-note" style="margin-top: 15px;">
    <strong>Nitrogen Form:</strong> ${result.achieved.N_NH4.toFixed(1)} ppm NH₄-N (${nh4Percent.toFixed(1)}% of total N),
    ${result.achieved.N_NO3.toFixed(1)} ppm NO₃-N (${(100 - nh4Percent).toFixed(1)}% of total N)
  </div>`;

  // Calculate ion balance for this formula
  const activeFertilizers = Object.entries(result.formula).map(([fertId, grams]) => {
    const fert = FERTILIZERS.find(f => f.id === fertId);
    return { ...fert, grams };
  });

  const ionBalance = calculateIonBalanceForFormula(activeFertilizers, volume);

  html += '<h3 style="margin-top: 20px;">Ion Balance <span class="info-icon" onclick="openReverseIonBalanceExplanation()" title="Click to learn how we calculate Ion Balance">?</span></h3>';
  html += `<div class="ion-balance-summary" style="margin-top: 10px;">
    <div class="ion-balance-card">
      <div style="font-size: 0.9em; color: #666;">Cations</div>
      <div style="font-size: 1.3em; font-weight: bold;">${ionBalance.totalCations.toFixed(2)} meq/L</div>
    </div>
    <div class="ion-balance-card">
      <div style="font-size: 0.9em; color: #666;">Anions</div>
      <div style="font-size: 1.3em; font-weight: bold;">${ionBalance.totalAnions.toFixed(2)} meq/L</div>
    </div>
    <div class="ion-balance-card status" style="background: ${ionBalance.statusColor}20; border-color: ${ionBalance.statusColor};">
      <div style="font-size: 0.9em; color: #666;">Imbalance</div>
      <div style="font-size: 1.3em; font-weight: bold; color: ${ionBalance.statusColor};">${ionBalance.imbalance.toFixed(1)}%</div>
      <div style="font-size: 0.9em; color: ${ionBalance.statusColor};">${ionBalance.statusText}</div>
    </div>
  </div>`;

  // Calculate and display EC prediction using new ionic molar conductivity model
  const ecPrediction = estimateECFromPPM(result.achieved);
  const ecValue = ecPrediction.ec_mS_cm;

  // Determine EC status color and text
  let ecStatusColor, ecStatusText;
  if (ecValue < 0.8) {
    ecStatusColor = '#17a2b8';  // Info blue - very light
    ecStatusText = 'Very Light';
  } else if (ecValue < 1.2) {
    ecStatusColor = '#28a745';  // Green - light/seedlings
    ecStatusText = 'Light';
  } else if (ecValue < 1.8) {
    ecStatusColor = '#28a745';  // Green - moderate
    ecStatusText = 'Moderate';
  } else if (ecValue < 2.5) {
    ecStatusColor = '#ffc107';  // Yellow - strong
    ecStatusText = 'Strong';
  } else if (ecValue < 3.5) {
    ecStatusColor = '#fd7e14';  // Orange - very strong
    ecStatusText = 'Very Strong';
  } else {
    ecStatusColor = '#dc3545';  // Red - too high
    ecStatusText = 'Very High!';
  }

  // Show different header based on whether EC was targeted
  if (targetEC !== null) {
    html += '<h3 style="margin-top: 20px;">Target EC Achieved</h3>';
    html += `<div class="ion-balance-summary" style="margin-top: 10px;">
      <div class="ion-balance-card">
        <div style="font-size: 0.9em; color: #666;">Target EC</div>
        <div style="font-size: 1.5em; font-weight: bold; color: #007bff;">${targetEC.toFixed(2)} <span style="font-size: 0.6em;">mS/cm</span></div>
      </div>
      <div class="ion-balance-card" style="flex: 2;">
        <div style="font-size: 0.9em; color: #666;">Achieved EC (25°C)</div>
        <div style="font-size: 1.8em; font-weight: bold; color: ${ecStatusColor};">${ecValue.toFixed(2)} <span style="font-size: 0.6em;">mS/cm</span></div>
        <div style="font-size: 0.9em; color: ${ecStatusColor}; margin-top: 5px;">${ecStatusText}</div>
      </div>
      <div class="ion-balance-card">
        <div style="font-size: 0.9em; color: #666;">Ionic Strength</div>
        <div style="font-size: 1.3em; font-weight: bold;">${(ecPrediction.ionicStrength * 1000).toFixed(1)} <span style="font-size: 0.7em;">mM</span></div>
      </div>
    </div>`;

    // Show scaling info if available
    if (result.ecScaling) {
      const accuracy = ((ecValue / targetEC) * 100).toFixed(1);
      html += `<div style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 4px; font-size: 0.9em;">
        <strong>EC Scaling Applied:</strong> Fertilizer amounts scaled by ${result.ecScaling.scaleFactor.toFixed(3)}x to achieve target EC.
        <br><span style="color: #666;">Accuracy: ${accuracy}% of target</span>
      </div>`;
    }
  } else {
    html += '<h3 style="margin-top: 20px;">Predicted EC</h3>';
    html += `<div class="ion-balance-summary" style="margin-top: 10px;">
      <div class="ion-balance-card" style="flex: 2;">
        <div style="font-size: 0.9em; color: #666;">Electrical Conductivity (25°C)</div>
        <div style="font-size: 1.8em; font-weight: bold; color: ${ecStatusColor};">${ecValue.toFixed(2)} <span style="font-size: 0.6em;">mS/cm</span></div>
        <div style="font-size: 0.9em; color: ${ecStatusColor}; margin-top: 5px;">${ecStatusText}</div>
      </div>
      <div class="ion-balance-card">
        <div style="font-size: 0.9em; color: #666;">Ionic Strength</div>
        <div style="font-size: 1.3em; font-weight: bold;">${(ecPrediction.ionicStrength * 1000).toFixed(1)} <span style="font-size: 0.7em;">mM</span></div>
      </div>
    </div>`;
  }

  // EC breakdown by ion (collapsible)
  const ionContributions = Object.entries(ecPrediction.contributions)
    .sort((a, b) => b[1].contribution_mS_cm - a[1].contribution_mS_cm);

  if (ionContributions.length > 0) {
    html += `<details style="margin-top: 10px;">
      <summary style="cursor: pointer; color: #007bff; font-size: 0.9em;">Show EC breakdown by ion</summary>
      <div style="margin-top: 10px; background: #f8f9fa; padding: 15px; border-radius: 4px;">
        <table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">
          <thead>
            <tr style="border-bottom: 2px solid #dee2e6;">
              <th style="text-align: left; padding: 8px;">Ion</th>
              <th style="text-align: right; padding: 8px;">Conc. (mmol/L)</th>
              <th style="text-align: right; padding: 8px;">λ (S·cm²/mol)</th>
              <th style="text-align: right; padding: 8px;">EC Contrib.</th>
            </tr>
          </thead>
          <tbody>`;

    ionContributions.forEach(([ion, data]) => {
      const percentage = (data.contribution_mS_cm / ecPrediction.rawEC * 100).toFixed(1);
      html += `
            <tr style="border-bottom: 1px solid #dee2e6;">
              <td style="padding: 8px;">${ion}</td>
              <td style="text-align: right; padding: 8px;">${data.concentration_mmolL.toFixed(2)}</td>
              <td style="text-align: right; padding: 8px;">${data.lambda}</td>
              <td style="text-align: right; padding: 8px;">${data.contribution_mS_cm.toFixed(3)} mS/cm (${percentage}%)</td>
            </tr>`;
    });

    html += `
          </tbody>
        </table>
        <div style="margin-top: 10px; font-size: 0.8em; color: #666;">
          <strong>Note:</strong> Raw EC = ${ecPrediction.rawEC.toFixed(3)} mS/cm.
          Ionic strength correction applied (factor: ${(ecPrediction.rawEC / ecPrediction.ec_mS_cm).toFixed(3)}).
        </div>
      </div>
    </details>`;
  }

  // Add nutrient ratio analysis
  const ratios = calculateNutrientRatios(result.achieved);
  if (ratios.length > 0) {
    html += '<h3 style="margin-top: 20px;">Nutrient Ratio Analysis</h3>';
    html += '<div class="nutrient-ratio-grid">';

    ratios.forEach(ratio => {
      const unit = ratio.unit || 'ppm';
      html += `
        <div class="nutrient-ratio-card">
          <div style="font-weight: bold; margin-bottom: 8px; color: #007bff; font-size: 1.1em;">
            ${ratio.name}
          </div>
          <div style="font-size: 1.3em; font-weight: bold; color: #333; margin-bottom: 8px;">
            ${ratio.ratio}
          </div>
          <div style="font-size: 0.85em; color: #666;">
            ${ratio.labels.map((label, i) => `${label}: ${ratio.values[i].toFixed(1)} ${unit}`).join(' | ')}
          </div>
        </div>
      `;
    });

    html += '</div>';
  }

  // Nutritional warnings (from checkWarnings function)
  const nutritionalWarnings = checkWarnings(result.achieved, activeFertilizers);
  if (nutritionalWarnings.length > 0) {
    html += '<h3 style="margin-top: 20px;">Warnings & Recommendations</h3>';
    nutritionalWarnings.forEach(warning => {
      const boxClass = warning.level === 'warning' ? 'warning-box' :
                       warning.level === 'error' ? 'error-box' : 'conversion-note';
      const icon = warning.level === 'warning' ? '⚠️' :
                   warning.level === 'error' ? '❌' : 'ℹ️';
      html += `
        <div class="${boxClass}" style="margin-bottom: 10px;">
          <strong>${icon} ${warning.category}</strong><br>
          ${warning.message}
        </div>
      `;
    });
  }

  // Warnings or errors (target deviation warnings)
  if (!allGood) {
    html += '<div class="error-box"><strong>⚠ Cannot achieve exact targets</strong><ul>';
    warnings.forEach(w => html += `<li>${w}</li>`);
    html += '</ul><p>This is the closest formula achievable with selected fertilizers. Consider:</p><ul><li>Selecting additional fertilizers</li><li>Adjusting your target values</li><li>Accepting the shown deviations</li></ul></div>';
  } else if (warnings.length > 0) {
    html += '<div class="warning-box"><strong>Note:</strong><ul>';
    warnings.forEach(w => html += `<li>${w}</li>`);
    html += '</ul></div>';
  } else {
    html += '<div style="background: #d4edda; border-left: 4px solid #28a745; padding: 15px; border-radius: 4px; margin-top: 15px;"><strong style="color: #28a745;">✓ Targets Successfully Achieved!</strong><p style="margin: 5px 0 0 0;">All nutrient values are within acceptable ranges.</p></div>';
  }

  outputDiv.innerHTML = html;
  resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// PPM Explanation Modal Functions
let calculationData = null; // Store calculation data for the modal

function openPPMExplanation() {
  const modal = document.getElementById('ppm-modal');
  const modalBody = modal.querySelector('.modal-body');

  // Generate dynamic content based on current calculation
  modalBody.innerHTML = generateExplanationContent();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden'; // Prevent scrolling when modal is open
}

function closePPMExplanation(event) {
  if (event && event.target !== event.currentTarget) return;

  const modal = document.getElementById('ppm-modal');
  modal.classList.remove('active');
  document.body.style.overflow = ''; // Restore scrolling
}

function generateExplanationContent() {
  const volumeInput = document.getElementById('volume');
  const volume = parseFloat(volumeInput.value) || 10;

  // Get active fertilizers
  const activeFertilizers = FERTILIZERS.filter(fert => {
    const checkbox = document.getElementById(`check-${fert.id}`);
    const input = document.getElementById(`grams-${fert.id}`);
    const grams = input ? parseFloat(input.value) : 0;
    return checkbox && checkbox.checked && grams > 0;
  }).map(fert => {
    const input = document.getElementById(`grams-${fert.id}`);
    return {
      ...fert,
      grams: parseFloat(input.value)
    };
  });

  let content = `
    <!-- What is PPM? -->
    <div class="explanation-section">
      <h3>What is PPM?</h3>
      <p>
        <strong>PPM stands for "Parts Per Million"</strong> - it's a way to measure very small concentrations.
        Think of it like this: <span class="highlight">1 PPM = 1 milligram per liter (mg/L)</span>.
      </p>
      <p>
        For example, 100 PPM of Nitrogen means there are 100 milligrams of nitrogen in every liter of water.
      </p>
    </div>

    <!-- The Basic Formula -->
    <div class="explanation-section">
      <h3>The Basic Formula</h3>
      <div class="formula-box">
        <div class="formula">PPM = (grams × 1000 × percentage) ÷ liters</div>
        <div class="description">This tells us the concentration of nutrients in your solution</div>
      </div>
      <p><strong>Where:</strong></p>
      <ul style="line-height: 1.8;">
        <li><strong>grams</strong> = Amount of fertilizer you're adding</li>
        <li><strong>1000</strong> = Converts grams to milligrams (mg)</li>
        <li><strong>percentage</strong> = The nutrient content in the fertilizer (÷ 100)</li>
        <li><strong>liters</strong> = Volume of water in your solution</li>
      </ul>
    </div>
  `;

  if (activeFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>
          Add some fertilizers and click "Calculate" to see your personalized calculation breakdown here!
        </p>
        <p>
          The calculator will show you step-by-step how we arrived at each PPM value based on your specific fertilizer selections and amounts.
        </p>
      </div>
    `;
  } else {
    content += `
      <!-- Your Calculation -->
      <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
        <h3 style="color: #17a2b8;">Your Current Calculation</h3>
        <p><strong>Solution Volume:</strong> ${volume} liters</p>
        <p><strong>Fertilizers Used:</strong> ${activeFertilizers.length}</p>
      </div>
    `;

    // Calculate contributions from each fertilizer
    const nutrientContributions = {};

    content += `
      <div class="explanation-section">
        <h3>Step-by-Step Breakdown</h3>
        <p>Here's exactly how we calculated each nutrient from your selected fertilizers:</p>
    `;

    activeFertilizers.forEach((fert, index) => {
      content += `
        <div class="step">
          <h4 style="margin-top: 0; color: #007bff;">
            <span class="step-number">${index + 1}</span>
            ${fert.name}
          </h4>
          <p style="margin: 10px 0 10px 38px;"><strong>Amount used:</strong> ${fert.grams} grams</p>
          <div style="margin-left: 38px;">
            <table class="conversion-table" style="font-size: 0.9em;">
              <thead>
                <tr>
                  <th>Nutrient</th>
                  <th>% in Fertilizer</th>
                  <th>Calculation</th>
                  <th>PPM</th>
                </tr>
              </thead>
              <tbody>
      `;

      Object.entries(fert.pct).forEach(([nutrient, percentage]) => {
        const ppm = (fert.grams * 1000 * (percentage / 100)) / volume;
        const calculation = `(${fert.grams} × 1000 × ${percentage / 100}) ÷ ${volume}`;

        // Track contributions for summary
        if (!nutrientContributions[nutrient]) {
          nutrientContributions[nutrient] = [];
        }
        nutrientContributions[nutrient].push({
          fertilizer: fert.name,
          ppm: ppm,
          percentage: percentage
        });

        content += `
          <tr>
            <td data-label="Nutrient"><strong>${nutrient}</strong></td>
            <td data-label="% in Fertilizer">${percentage}%</td>
            <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">${calculation}</td>
            <td data-label="PPM"><strong>${ppm.toFixed(2)} PPM</strong></td>
          </tr>
        `;
      });

      content += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    });

    content += `</div>`;

    // Summary section showing total PPM for each nutrient
    if (Object.keys(nutrientContributions).length > 0) {
      content += `
        <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
          <h3 style="color: #28a745;">Final Results - Total PPM</h3>
          <p>When using multiple fertilizers, we add up the PPM from each source:</p>
          <div style="margin-top: 15px;">
      `;

      // Calculate final results with oxide conversions
      const finalResults = {};
      Object.entries(nutrientContributions).forEach(([nutrient, contributions]) => {
        const totalPPM = contributions.reduce((sum, c) => sum + c.ppm, 0);

        // Check if this is an oxide that needs conversion
        let displayNutrient = nutrient;
        let displayPPM = totalPPM;
        let conversionNote = '';

        if (nutrient === 'P2O5' && OXIDE_CONVERSIONS.P2O5_to_P) {
          const convertedPPM = totalPPM * OXIDE_CONVERSIONS.P2O5_to_P;
          finalResults['P'] = convertedPPM;
          conversionNote = ` → <strong>${convertedPPM.toFixed(2)} PPM P</strong> (elemental form)`;
          displayNutrient = 'P₂O₅';
        } else if (nutrient === 'K2O' && OXIDE_CONVERSIONS.K2O_to_K) {
          const convertedPPM = totalPPM * OXIDE_CONVERSIONS.K2O_to_K;
          finalResults['K'] = convertedPPM;
          conversionNote = ` → <strong>${convertedPPM.toFixed(2)} PPM K</strong> (elemental form)`;
          displayNutrient = 'K₂O';
        } else if (nutrient === 'MgO' && OXIDE_CONVERSIONS.MgO_to_Mg) {
          const convertedPPM = totalPPM * OXIDE_CONVERSIONS.MgO_to_Mg;
          finalResults['Mg'] = convertedPPM;
          conversionNote = ` → <strong>${convertedPPM.toFixed(2)} PPM Mg</strong> (elemental form)`;
        } else if (nutrient === 'CaO' && OXIDE_CONVERSIONS.CaO_to_Ca) {
          const convertedPPM = totalPPM * OXIDE_CONVERSIONS.CaO_to_Ca;
          finalResults['Ca'] = convertedPPM;
          conversionNote = ` → <strong>${convertedPPM.toFixed(2)} PPM Ca</strong> (elemental form)`;
        } else {
          finalResults[nutrient] = totalPPM;
        }

        content += `
          <div style="background: white; padding: 15px; margin: 10px 0; border-radius: 6px; border-left: 3px solid #28a745;">
            <strong style="font-size: 1.1em; color: #28a745;">${displayNutrient}:</strong>
        `;

        if (contributions.length > 1) {
          content += `<div style="margin: 8px 0 8px 20px; line-height: 1.8;">`;
          contributions.forEach(c => {
            content += `<div>• ${c.fertilizer}: ${c.ppm.toFixed(2)} PPM</div>`;
          });
          content += `</div>`;
          content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 2px solid #dee2e6;">`;
          content += `<strong>Total: ${totalPPM.toFixed(2)} PPM${conversionNote}</strong>`;
          content += `</div>`;
        } else {
          content += ` <strong>${totalPPM.toFixed(2)} PPM${conversionNote}</strong>`;
        }

        content += `</div>`;
      });

      content += `
          </div>
        </div>
      `;

      // Oxide conversion explanation if applicable
      const hasOxides = Object.keys(nutrientContributions).some(n =>
        n === 'P2O5' || n === 'K2O' || n === 'MgO' || n === 'CaO'
      );

      if (hasOxides) {
        content += `
          <div class="explanation-section">
            <h3>About Oxide Conversions</h3>
            <p>
              Some fertilizers list nutrients in <strong>oxide form</strong> (like P₂O₅, K₂O),
              but plants use the <strong>elemental form</strong> (P, K). The calculator automatically converts these:
            </p>
            <table class="conversion-table" style="margin-top: 10px;">
              <thead>
                <tr>
                  <th>Oxide Form</th>
                  <th>Elemental Form</th>
                  <th>Conversion Factor</th>
                </tr>
              </thead>
              <tbody>
        `;

        if (nutrientContributions['P2O5']) {
          content += `
                <tr>
                  <td data-label="Oxide Form">P₂O₅ (Phosphate)</td>
                  <td data-label="Elemental Form">P (Phosphorus)</td>
                  <td data-label="Conversion Factor">×0.436</td>
                </tr>
          `;
        }
        if (nutrientContributions['K2O']) {
          content += `
                <tr>
                  <td data-label="Oxide Form">K₂O (Potash)</td>
                  <td data-label="Elemental Form">K (Potassium)</td>
                  <td data-label="Conversion Factor">×0.830</td>
                </tr>
          `;
        }
        if (nutrientContributions['MgO']) {
          content += `
                <tr>
                  <td data-label="Oxide Form">MgO (Magnesium Oxide)</td>
                  <td data-label="Elemental Form">Mg (Magnesium)</td>
                  <td data-label="Conversion Factor">×0.603</td>
                </tr>
          `;
        }
        if (nutrientContributions['CaO']) {
          content += `
                <tr>
                  <td data-label="Oxide Form">CaO (Calcium Oxide)</td>
                  <td data-label="Elemental Form">Ca (Calcium)</td>
                  <td data-label="Conversion Factor">×0.715</td>
                </tr>
          `;
        }

        content += `
              </tbody>
            </table>
          </div>
        `;
      }
    }
  }

  // Always include helpful tips
  content += `
    <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
      <h3 style="color: #28a745;">Quick Tips</h3>
      <ul style="line-height: 1.8;">
        <li>1 PPM = 1 mg/L (milligram per liter)</li>
        <li>Start with lower PPM values and increase gradually</li>
        <li>Different plants need different nutrient levels</li>
        <li>More fertilizer ≠ better growth; balance is key</li>
        <li>Check your water's existing nutrient content if possible</li>
      </ul>
    </div>
  `;

  return content;
}

// Ion Balance Explanation Modal Functions
function openIonBalanceExplanation() {
  const modal = document.getElementById('ion-balance-modal');
  const modalBody = modal.querySelector('#ion-balance-modal-body');

  // Generate dynamic content based on current calculation
  modalBody.innerHTML = generateIonBalanceExplanation();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeIonBalanceExplanation(event) {
  if (event && event.target !== event.currentTarget) return;

  const modal = document.getElementById('ion-balance-modal');
  modal.classList.remove('active');
  document.body.style.overflow = '';
}

function generateIonBalanceExplanation() {
  const volumeInput = document.getElementById('volume');
  const volume = parseFloat(volumeInput.value) || 10;

  // Get active fertilizers
  const activeFertilizers = FERTILIZERS.filter(fert => {
    const checkbox = document.getElementById(`check-${fert.id}`);
    const input = document.getElementById(`grams-${fert.id}`);
    const grams = input ? parseFloat(input.value) : 0;
    return checkbox && checkbox.checked && grams > 0;
  }).map(fert => {
    const input = document.getElementById(`grams-${fert.id}`);
    return {
      ...fert,
      grams: parseFloat(input.value)
    };
  });

  let content = `
    <!-- What is Ion Balance? -->
    <div class="explanation-section">
      <h3>What is Ion Balance?</h3>
      <p>
        When fertilizers dissolve in water, they break apart into <strong>charged particles called ions</strong>:
      </p>
      <ul style="line-height: 1.8;">
        <li><strong>Cations (+)</strong> - Positively charged ions like K⁺, Ca²⁺, Mg²⁺, NH₄⁺</li>
        <li><strong>Anions (-)</strong> - Negatively charged ions like NO₃⁻, SO₄²⁻, H₂PO₄⁻</li>
      </ul>
      <p>
        For a <span class="highlight">healthy nutrient solution</span>, the total positive charges should roughly equal the total negative charges.
        This keeps the pH stable and prevents nutrient lockout.
      </p>
    </div>

    <!-- What is meq/L? -->
    <div class="explanation-section">
      <h3>Understanding meq/L (Milliequivalents per Liter)</h3>
      <p>
        <strong>meq/L</strong> is a unit that measures the <strong>electrical charge</strong> of ions in solution, not their weight.
      </p>
      <p>
        Think of it like this: A calcium ion (Ca²⁺) has twice the charge of a potassium ion (K⁺), even if they weigh the same.
        meq/L accounts for this difference in charge.
      </p>
      <div class="formula-box">
        <div class="formula">meq/L = (grams ÷ molar mass) × ion count × charge × 1000 ÷ liters</div>
        <div class="description">This tells us the electrical charge contribution of each ion</div>
      </div>
      <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #6c757d;">
        <p style="margin: 0; font-size: 0.95em; line-height: 1.6;">
          <strong>📌 Important Notes:</strong>
        </p>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; line-height: 1.8; font-size: 0.9em;">
          <li><strong>Hydration water</strong> (e.g., ·7H₂O, ·4H₂O) adds to molar mass but NOT to charge - it's just water in the crystal structure</li>
          <li><strong>Urea</strong> doesn't form charged ions, so it's excluded from ion balance (but its nitrogen still counts for nutrients)</li>
        </ul>
      </div>
    </div>
  `;

  if (activeFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>
          Add some fertilizers and click "Calculate" to see your personalized ion balance breakdown here!
        </p>
        <p>
          The calculator will show you step-by-step how each fertilizer contributes cations and anions to your solution.
        </p>
      </div>
    `;
  } else {
    // Calculate ion balance
    let totalCations = 0;
    let totalAnions = 0;
    const ionDetails = {};
    const fertilizerBreakdown = [];

    activeFertilizers.forEach(fert => {
      const ionData = ION_DATA[fert.id];

      if (!ionData) {
        return; // Skip fertilizers without ion data
      }

      const moles = fert.grams / ionData.molarMass;
      const fertIons = [];

      ionData.ions.forEach(ionInfo => {
        const meq = moles * ionInfo.count * ionInfo.charge * 1000;
        const meqPerLiter = meq / volume;

        fertIons.push({
          ...ionInfo,
          meq: meqPerLiter,
          calculation: {
            moles: moles,
            meq: meq,
            meqPerLiter: meqPerLiter
          }
        });

        // Track by ion name
        if (!ionDetails[ionInfo.ion]) {
          ionDetails[ionInfo.ion] = {
            meq: 0,
            type: ionInfo.type
          };
        }
        ionDetails[ionInfo.ion].meq += meqPerLiter;

        // Add to totals
        if (ionInfo.type === 'cation') {
          totalCations += meqPerLiter;
        } else {
          totalAnions += meqPerLiter;
        }
      });

      fertilizerBreakdown.push({
        fert: fert,
        ionData: ionData,
        moles: moles,
        ions: fertIons
      });
    });

    const average = (totalCations + totalAnions) / 2;
    const imbalance = average > 0 ? Math.abs(totalCations - totalAnions) / average * 100 : 0;

    content += `
      <!-- Your Calculation -->
      <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
        <h3 style="color: #17a2b8;">Your Current Solution</h3>
        <p><strong>Solution Volume:</strong> ${volume} liters</p>
        <p><strong>Fertilizers Used:</strong> ${activeFertilizers.length}</p>
      </div>

      <!-- Step-by-Step Breakdown -->
      <div class="explanation-section">
        <h3>Step-by-Step Ion Calculation</h3>
        <p>Here's how each fertilizer contributes ions to your solution:</p>
    `;

    fertilizerBreakdown.forEach((item, index) => {
      const formulaDisplay = item.ionData.formula ?
        `<span style="background: #e8f4f8; padding: 4px 8px; border-radius: 4px; font-family: monospace; margin-left: 10px; font-size: 0.9em;">${item.ionData.formula}</span>` :
        '';

      // Check for hydration water in the formula
      const hasHydrationWater = item.ionData.formula && item.ionData.formula.includes('H₂O');

      // Check if this is urea or urea-based (name contains 'urea' but not 'urea phosphate' since that has ions)
      const isUreaOnly = item.fert.name.toLowerCase().includes('urea') &&
                         !item.fert.name.toLowerCase().includes('phosphate') &&
                         !item.fert.name.toLowerCase().includes('thiosulfate');

      content += `
        <div class="step">
          <h4 style="margin-top: 0; color: #007bff;">
            <span class="step-number">${index + 1}</span>
            ${item.fert.name}
            ${formulaDisplay}
          </h4>
          <p style="margin: 10px 0 10px 38px;">
            <strong>Amount:</strong> ${item.fert.grams} grams<br>
            <strong>Molar Mass:</strong> ${item.ionData.molarMass} g/mol<br>
            <strong>Moles:</strong> ${item.fert.grams} ÷ ${item.ionData.molarMass} = <strong>${item.moles.toFixed(4)} mol</strong>
          </p>
      `;

      // Add note about hydration water if applicable
      if (hasHydrationWater) {
        content += `
          <div style="margin: 10px 0 10px 38px; padding: 10px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; font-size: 0.9em;">
            <strong>💧 About Hydration Water:</strong> The water molecules (like ·7H₂O) in this formula add to the molar mass
            but do NOT contribute to the ion balance. They're just water trapped in the crystal structure.
          </div>
        `;
      }

      // Add note about urea if applicable
      if (isUreaOnly) {
        content += `
          <div style="margin: 10px 0 10px 38px; padding: 10px; background: #d1ecf1; border-left: 3px solid #17a2b8; border-radius: 4px; font-size: 0.9em;">
            <strong>ℹ️ About Urea:</strong> Urea does NOT form charged ions like nitrate (NO₃⁻) or ammonium (NH₄⁺).
            Therefore, it is NOT counted in ion balance calculations. However, its nitrogen content IS still counted
            when calculating nutrient PPM values.
          </div>
        `;
      }

      content += `
          <div style="margin-left: 38px;">
            <table class="conversion-table" style="font-size: 0.9em;">
              <thead>
                <tr>
                  <th>Ion</th>
                  <th>Type</th>
                  <th>Count × Charge</th>
                  <th>Calculation</th>
                  <th>meq/L</th>
                </tr>
              </thead>
              <tbody>
      `;

      item.ions.forEach(ion => {
        const chargeSymbol = ion.type === 'cation' ? '+' : '-';
        const calculation = `${item.moles.toFixed(4)} × ${ion.count} × ${ion.charge} × 1000 ÷ ${volume}`;

        content += `
          <tr>
            <td data-label="Ion"><strong>${ion.ion}</strong></td>
            <td data-label="Type">${ion.type === 'cation' ? 'Cation (+)' : 'Anion (-)'}</td>
            <td data-label="Count × Charge">${ion.count} × ${ion.charge}</td>
            <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">${calculation}</td>
            <td data-label="meq/L"><strong>${ion.meq.toFixed(2)} meq/L</strong></td>
          </tr>
        `;
      });

      content += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    });

    content += `</div>`;

    // Summary section
    const cations = Object.entries(ionDetails).filter(([ion, data]) => data.type === 'cation');
    const anions = Object.entries(ionDetails).filter(([ion, data]) => data.type === 'anion');

    let statusColor, statusText;
    if (imbalance <= 10) {
      statusColor = '#28a745';
      statusText = 'Balanced ✓';
    } else if (imbalance <= 20) {
      statusColor = '#ffc107';
      statusText = 'Caution ⚠';
    } else {
      statusColor = '#dc3545';
      statusText = 'Imbalanced ✗';
    }

    content += `
      <div class="explanation-section" style="background: ${statusColor}20; border-left-color: ${statusColor};">
        <h3 style="color: ${statusColor};">Final Ion Balance Results</h3>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Cations (+)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${totalCations.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Anions (-)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${totalAnions.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
        </div>

        <div style="background: white; padding: 20px; border-radius: 8px; text-align: center; border: 2px solid ${statusColor};">
          <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Imbalance Percentage</div>
          <div style="font-size: 2em; font-weight: bold; color: ${statusColor};">${imbalance.toFixed(1)}%</div>
          <div style="font-size: 1em; color: ${statusColor}; margin-top: 5px;">${statusText}</div>
        </div>

        <div style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px;">
          <h4 style="margin-top: 0;">How we calculated imbalance:</h4>
          <p style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px;">
            Average = (${totalCations.toFixed(2)} + ${totalAnions.toFixed(2)}) ÷ 2 = ${average.toFixed(2)} meq/L<br>
            Imbalance = |${totalCations.toFixed(2)} - ${totalAnions.toFixed(2)}| ÷ ${average.toFixed(2)} × 100 = <strong>${imbalance.toFixed(1)}%</strong>
          </p>
        </div>
      </div>
    `;

    // Individual ion breakdown
    if (cations.length > 0 || anions.length > 0) {
      content += `
        <div class="explanation-section">
          <h3>Ion Breakdown by Type</h3>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      `;

      // Cations
      content += `
        <div>
          <h4 style="color: #007bff; margin-top: 0;">Cations (+)</h4>
      `;
      cations.forEach(([ion, data]) => {
        const percentage = totalCations > 0 ? (data.meq / totalCations * 100).toFixed(1) : 0;
        content += `
          <div style="background: #f8f9fa; padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid #007bff;">
            <div style="display: flex; justify-content: space-between;">
              <strong>${ion}</strong>
              <span>${data.meq.toFixed(2)} meq/L</span>
            </div>
            <div style="font-size: 0.85em; color: #666; margin-top: 4px;">${percentage}% of total cations</div>
          </div>
        `;
      });
      content += `</div>`;

      // Anions
      content += `
        <div>
          <h4 style="color: #007bff; margin-top: 0;">Anions (-)</h4>
      `;
      anions.forEach(([ion, data]) => {
        const percentage = totalAnions > 0 ? (data.meq / totalAnions * 100).toFixed(1) : 0;
        content += `
          <div style="background: #f8f9fa; padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid #007bff;">
            <div style="display: flex; justify-content: space-between;">
              <strong>${ion}</strong>
              <span>${data.meq.toFixed(2)} meq/L</span>
            </div>
            <div style="font-size: 0.85em; color: #666; margin-top: 4px;">${percentage}% of total anions</div>
          </div>
        `;
      });
      content += `</div>`;

      content += `</div></div>`;
    }
  }

  // Always include interpretation guide
  content += `
    <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
      <h3 style="color: #28a745;">Interpreting Your Results</h3>
      <ul style="line-height: 1.8;">
        <li><strong>≤10% Imbalance:</strong> Balanced ✓ - Excellent! Your solution has good charge balance</li>
        <li><strong>10-20% Imbalance:</strong> Caution ⚠ - Acceptable, but monitor pH closely</li>
        <li><strong>>20% Imbalance:</strong> Imbalanced ✗ - May cause pH swings and nutrient lockouts</li>
      </ul>
      <p style="margin-top: 15px;">
        <strong>Why does this matter?</strong> Charge imbalance can cause pH to drift up or down,
        which may lock out certain nutrients even if they're present in your solution.
      </p>
    </div>
  `;

  return content;
}

// ==========================================
// Reverse Calculator Explanation Functions
// ==========================================

// Open PPM explanation for reverse calculator results
function openReversePPMExplanation() {
  const modal = document.getElementById('ppm-modal');
  const modalBody = modal.querySelector('.modal-body');

  modalBody.innerHTML = generateReversePPMExplanation();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

// Open Ion Balance explanation for reverse calculator results
function openReverseIonBalanceExplanation() {
  const modal = document.getElementById('ion-balance-modal');
  const modalBody = modal.querySelector('#ion-balance-modal-body');

  modalBody.innerHTML = generateReverseIonBalanceExplanation();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

// Generate PPM explanation content for reverse calculator
function generateReversePPMExplanation() {
  if (!lastReverseCalculation) {
    return `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>Please run a calculation first to see the explanation.</p>
      </div>
    `;
  }

  const { result, targets, volume } = lastReverseCalculation;

  // Get active fertilizers from result
  const activeFertilizers = Object.entries(result.formula)
    .filter(([fertId, grams]) => grams > 0.01)
    .map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { ...fert, grams };
    });

  let content = `
    <!-- What is PPM? -->
    <div class="explanation-section">
      <h3>What is PPM?</h3>
      <p>
        <strong>PPM stands for "Parts Per Million"</strong> - it's a way to measure very small concentrations.
        Think of it like this: <span class="highlight">1 PPM = 1 milligram per liter (mg/L)</span>.
      </p>
      <p>
        For example, 100 PPM of Nitrogen means there are 100 milligrams of nitrogen in every liter of water.
      </p>
    </div>

    <!-- The Basic Formula -->
    <div class="explanation-section">
      <h3>The Basic Formula</h3>
      <div class="formula-box">
        <div class="formula">PPM = (grams × 1000 × percentage) ÷ liters</div>
        <div class="description">This tells us the concentration of nutrients in your solution</div>
      </div>
      <p><strong>Where:</strong></p>
      <ul style="line-height: 1.8;">
        <li><strong>grams</strong> = Amount of fertilizer you're adding</li>
        <li><strong>1000</strong> = Converts grams to milligrams (mg)</li>
        <li><strong>percentage</strong> = The nutrient content in the fertilizer (÷ 100)</li>
        <li><strong>liters</strong> = Volume of water in your solution</li>
      </ul>
    </div>
  `;

  if (activeFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Fertilizers in Formula</h3>
        <p>The calculation did not produce a valid formula. Try adjusting your target values or selecting different fertilizers.</p>
      </div>
    `;
  } else {
    content += `
      <!-- Your Calculation -->
      <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
        <h3 style="color: #17a2b8;">Your Current Calculation</h3>
        <p><strong>Solution Volume:</strong> ${volume} liters</p>
        <p><strong>Fertilizers Used:</strong> ${activeFertilizers.length}</p>
      </div>
    `;

    // Calculate contributions from each fertilizer
    const nutrientContributions = {};

    content += `
      <div class="explanation-section">
        <h3>Step-by-Step Breakdown</h3>
        <p>Here's exactly how each fertilizer contributes to the achieved PPM values:</p>
    `;

    activeFertilizers.forEach((fert, index) => {
      content += `
        <div class="step">
          <h4 style="margin-top: 0; color: #007bff;">
            <span class="step-number">${index + 1}</span>
            ${fert.name}
          </h4>
          <p style="margin: 10px 0 10px 38px;"><strong>Amount calculated:</strong> ${fert.grams.toFixed(2)} grams</p>
          <div style="margin-left: 38px;">
            <table class="conversion-table" style="font-size: 0.9em;">
              <thead>
                <tr>
                  <th>Nutrient</th>
                  <th>% in Fertilizer</th>
                  <th>Calculation</th>
                  <th>PPM</th>
                </tr>
              </thead>
              <tbody>
      `;

      Object.entries(fert.pct).forEach(([nutrient, percentage]) => {
        const ppm = (fert.grams * 1000 * (percentage / 100)) / volume;
        const calculation = `(${fert.grams.toFixed(2)} × 1000 × ${(percentage / 100).toFixed(4)}) ÷ ${volume}`;

        // Track contributions for summary
        if (!nutrientContributions[nutrient]) {
          nutrientContributions[nutrient] = [];
        }
        nutrientContributions[nutrient].push({
          fertilizer: fert.name,
          ppm: ppm,
          percentage: percentage
        });

        content += `
          <tr>
            <td data-label="Nutrient"><strong>${nutrient}</strong></td>
            <td data-label="% in Fertilizer">${percentage}%</td>
            <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">${calculation}</td>
            <td data-label="PPM"><strong>${ppm.toFixed(2)} PPM</strong></td>
          </tr>
        `;
      });

      content += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    });

    content += `</div>`;

    // Summary table showing totals
    content += `
      <div class="explanation-section">
        <h3>Nutrient Totals Summary</h3>
        <p>When nutrients come from multiple fertilizers, we add them together:</p>
        <table class="conversion-table">
          <thead>
            <tr>
              <th>Nutrient</th>
              <th>Sources</th>
              <th>Total PPM</th>
            </tr>
          </thead>
          <tbody>
    `;

    Object.entries(nutrientContributions).forEach(([nutrient, sources]) => {
      const total = sources.reduce((sum, s) => sum + s.ppm, 0);
      const sourceList = sources.map(s => `${s.fertilizer}: ${s.ppm.toFixed(2)}`).join(' + ');

      content += `
        <tr>
          <td data-label="Nutrient"><strong>${nutrient}</strong></td>
          <td data-label="Sources" style="font-size: 0.85em;">${sourceList}</td>
          <td data-label="Total PPM"><strong>${total.toFixed(2)} PPM</strong></td>
        </tr>
      `;
    });

    content += `
          </tbody>
        </table>
      </div>
    `;
  }

  // Oxide conversions info
  content += `
    <div class="explanation-section">
      <h3>Understanding Oxide Conversions</h3>
      <p>
        Many fertilizers list nutrients in their <strong>oxide form</strong> (like P₂O₅ for phosphorus or K₂O for potassium),
        but plants actually use the <strong>elemental form</strong>. The calculator handles this automatically!
      </p>
      <table class="conversion-table">
        <thead>
          <tr>
            <th>Oxide Form</th>
            <th>Elemental Form</th>
            <th>Conversion</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>P₂O₅</td>
            <td>P</td>
            <td>× 0.436</td>
          </tr>
          <tr>
            <td>K₂O</td>
            <td>K</td>
            <td>× 0.830</td>
          </tr>
        </tbody>
      </table>
    </div>
  `;

  return content;
}

// Generate Ion Balance explanation content for reverse calculator
function generateReverseIonBalanceExplanation() {
  if (!lastReverseCalculation) {
    return `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>Please run a calculation first to see the explanation.</p>
      </div>
    `;
  }

  const { result, volume } = lastReverseCalculation;

  // Get active fertilizers from result
  const activeFertilizers = Object.entries(result.formula)
    .filter(([fertId, grams]) => grams > 0.01)
    .map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { ...fert, grams };
    });

  let content = `
    <!-- What is Ion Balance? -->
    <div class="explanation-section">
      <h3>What is Ion Balance?</h3>
      <p>
        When fertilizers dissolve in water, they break apart into <strong>charged particles called ions</strong>:
      </p>
      <ul style="line-height: 1.8;">
        <li><strong>Cations (+)</strong> - Positively charged ions like K⁺, Ca²⁺, Mg²⁺, NH₄⁺</li>
        <li><strong>Anions (-)</strong> - Negatively charged ions like NO₃⁻, SO₄²⁻, H₂PO₄⁻</li>
      </ul>
      <p>
        For a <span class="highlight">healthy nutrient solution</span>, the total positive charges should roughly equal the total negative charges.
        This keeps the pH stable and prevents nutrient lockout.
      </p>
    </div>

    <!-- What is meq/L? -->
    <div class="explanation-section">
      <h3>Understanding meq/L (Milliequivalents per Liter)</h3>
      <p>
        <strong>meq/L</strong> is a unit that measures the <strong>electrical charge</strong> of ions in solution, not their weight.
      </p>
      <p>
        Think of it like this: A calcium ion (Ca²⁺) has twice the charge of a potassium ion (K⁺), even if they weigh the same.
        meq/L accounts for this difference in charge.
      </p>
      <div class="formula-box">
        <div class="formula">meq/L = (grams ÷ molar mass) × ion count × charge × 1000 ÷ liters</div>
        <div class="description">This tells us the electrical charge contribution of each ion</div>
      </div>
      <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #6c757d;">
        <p style="margin: 0; font-size: 0.95em; line-height: 1.6;">
          <strong>Important Notes:</strong>
        </p>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; line-height: 1.8; font-size: 0.9em;">
          <li><strong>Hydration water</strong> (e.g., ·7H₂O, ·4H₂O) adds to molar mass but NOT to charge</li>
          <li><strong>Urea</strong> doesn't form charged ions, so it's excluded from ion balance</li>
        </ul>
      </div>
    </div>
  `;

  if (activeFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Fertilizers in Formula</h3>
        <p>The calculation did not produce a valid formula. Try adjusting your target values or selecting different fertilizers.</p>
      </div>
    `;
  } else {
    // Calculate ion balance
    let totalCations = 0;
    let totalAnions = 0;
    const ionDetails = {};
    const fertilizerBreakdown = [];

    activeFertilizers.forEach(fert => {
      const ionData = ION_DATA[fert.id];

      if (!ionData) {
        return; // Skip fertilizers without ion data
      }

      const moles = fert.grams / ionData.molarMass;
      const fertIons = [];

      ionData.ions.forEach(ionInfo => {
        const meq = moles * ionInfo.count * ionInfo.charge * 1000;
        const meqPerLiter = meq / volume;

        fertIons.push({
          ...ionInfo,
          meq: meqPerLiter,
          calculation: {
            moles: moles,
            meq: meq,
            meqPerLiter: meqPerLiter
          }
        });

        // Track by ion name
        if (!ionDetails[ionInfo.ion]) {
          ionDetails[ionInfo.ion] = {
            meq: 0,
            type: ionInfo.type
          };
        }
        ionDetails[ionInfo.ion].meq += meqPerLiter;

        // Add to totals
        if (ionInfo.type === 'cation') {
          totalCations += meqPerLiter;
        } else {
          totalAnions += meqPerLiter;
        }
      });

      fertilizerBreakdown.push({
        fert: fert,
        ionData: ionData,
        moles: moles,
        ions: fertIons
      });
    });

    const average = (totalCations + totalAnions) / 2;
    const imbalance = average > 0 ? Math.abs(totalCations - totalAnions) / average * 100 : 0;

    content += `
      <!-- Your Calculation -->
      <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
        <h3 style="color: #17a2b8;">Your Current Solution</h3>
        <p><strong>Solution Volume:</strong> ${volume} liters</p>
        <p><strong>Fertilizers Used:</strong> ${activeFertilizers.length}</p>
      </div>

      <!-- Step-by-Step Breakdown -->
      <div class="explanation-section">
        <h3>Step-by-Step Ion Calculation</h3>
        <p>Here's how each fertilizer contributes ions to your solution:</p>
    `;

    fertilizerBreakdown.forEach((item, index) => {
      const formulaDisplay = item.ionData.formula ?
        `<span style="background: #e8f4f8; padding: 4px 8px; border-radius: 4px; font-family: monospace; margin-left: 10px; font-size: 0.9em;">${item.ionData.formula}</span>` :
        '';

      const hasHydrationWater = item.ionData.formula && item.ionData.formula.includes('H₂O');

      content += `
        <div class="step">
          <h4 style="margin-top: 0; color: #007bff;">
            <span class="step-number">${index + 1}</span>
            ${item.fert.name}
            ${formulaDisplay}
          </h4>
          <p style="margin: 10px 0 10px 38px;">
            <strong>Amount:</strong> ${item.fert.grams.toFixed(2)} grams<br>
            <strong>Molar Mass:</strong> ${item.ionData.molarMass} g/mol<br>
            <strong>Moles:</strong> ${item.fert.grams.toFixed(2)} ÷ ${item.ionData.molarMass} = <strong>${item.moles.toFixed(4)} mol</strong>
          </p>
      `;

      if (hasHydrationWater) {
        content += `
          <div style="margin: 10px 0 10px 38px; padding: 10px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; font-size: 0.9em;">
            <strong>About Hydration Water:</strong> The water molecules in this formula add to the molar mass
            but do NOT contribute to the ion balance.
          </div>
        `;
      }

      content += `
          <div style="margin-left: 38px;">
            <table class="conversion-table" style="font-size: 0.9em;">
              <thead>
                <tr>
                  <th>Ion</th>
                  <th>Type</th>
                  <th>Calculation</th>
                  <th>meq/L</th>
                </tr>
              </thead>
              <tbody>
      `;

      item.ions.forEach(ionInfo => {
        const typeColor = ionInfo.type === 'cation' ? '#28a745' : '#dc3545';
        const typeSymbol = ionInfo.type === 'cation' ? '+' : '-';
        content += `
          <tr>
            <td data-label="Ion"><strong>${ionInfo.ion}</strong></td>
            <td data-label="Type" style="color: ${typeColor};">${ionInfo.type} (${typeSymbol})</td>
            <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">
              ${item.moles.toFixed(4)} × ${ionInfo.count} × ${ionInfo.charge} × 1000 ÷ ${volume}
            </td>
            <td data-label="meq/L"><strong>${ionInfo.meq.toFixed(2)}</strong></td>
          </tr>
        `;
      });

      content += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    });

    content += `</div>`;

    // Results summary
    let statusColor = '#28a745';
    let statusText = 'Balanced';
    if (imbalance > 20) {
      statusColor = '#dc3545';
      statusText = 'Imbalanced';
    } else if (imbalance > 10) {
      statusColor = '#ffc107';
      statusText = 'Caution';
    }

    const cations = Object.entries(ionDetails).filter(([ion, data]) => data.type === 'cation').sort((a, b) => b[1].meq - a[1].meq);
    const anions = Object.entries(ionDetails).filter(([ion, data]) => data.type === 'anion').sort((a, b) => b[1].meq - a[1].meq);

    content += `
      <!-- Summary -->
      <div class="explanation-section" style="background: ${statusColor}15; border-left-color: ${statusColor};">
        <h3 style="color: ${statusColor};">Final Results</h3>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Cations (+)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${totalCations.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Anions (-)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${totalAnions.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
        </div>

        <div style="background: white; padding: 20px; border-radius: 8px; text-align: center; border: 2px solid ${statusColor};">
          <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Imbalance Percentage</div>
          <div style="font-size: 2em; font-weight: bold; color: ${statusColor};">${imbalance.toFixed(1)}%</div>
          <div style="font-size: 1em; color: ${statusColor}; margin-top: 5px;">${statusText}</div>
        </div>

        <div style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px;">
          <h4 style="margin-top: 0;">How we calculated imbalance:</h4>
          <p style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px;">
            Average = (${totalCations.toFixed(2)} + ${totalAnions.toFixed(2)}) ÷ 2 = ${average.toFixed(2)} meq/L<br>
            Imbalance = |${totalCations.toFixed(2)} - ${totalAnions.toFixed(2)}| ÷ ${average.toFixed(2)} × 100 = <strong>${imbalance.toFixed(1)}%</strong>
          </p>
        </div>
      </div>
    `;

    // Individual ion breakdown
    if (cations.length > 0 || anions.length > 0) {
      content += `
        <div class="explanation-section">
          <h3>Ion Breakdown by Type</h3>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      `;

      // Cations
      content += `
        <div>
          <h4 style="color: #007bff; margin-top: 0;">Cations (+)</h4>
      `;
      cations.forEach(([ion, data]) => {
        const percentage = totalCations > 0 ? (data.meq / totalCations * 100).toFixed(1) : 0;
        content += `
          <div style="background: #f8f9fa; padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid #007bff;">
            <div style="display: flex; justify-content: space-between;">
              <strong>${ion}</strong>
              <span>${data.meq.toFixed(2)} meq/L</span>
            </div>
            <div style="font-size: 0.85em; color: #666; margin-top: 4px;">${percentage}% of total cations</div>
          </div>
        `;
      });
      content += `</div>`;

      // Anions
      content += `
        <div>
          <h4 style="color: #007bff; margin-top: 0;">Anions (-)</h4>
      `;
      anions.forEach(([ion, data]) => {
        const percentage = totalAnions > 0 ? (data.meq / totalAnions * 100).toFixed(1) : 0;
        content += `
          <div style="background: #f8f9fa; padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid #007bff;">
            <div style="display: flex; justify-content: space-between;">
              <strong>${ion}</strong>
              <span>${data.meq.toFixed(2)} meq/L</span>
            </div>
            <div style="font-size: 0.85em; color: #666; margin-top: 4px;">${percentage}% of total anions</div>
          </div>
        `;
      });
      content += `</div>`;

      content += `</div></div>`;
    }
  }

  // Always include interpretation guide
  content += `
    <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
      <h3 style="color: #28a745;">Interpreting Your Results</h3>
      <ul style="line-height: 1.8;">
        <li><strong>≤10% Imbalance:</strong> Balanced - Excellent! Your solution has good charge balance</li>
        <li><strong>10-20% Imbalance:</strong> Caution - Acceptable, but monitor pH closely</li>
        <li><strong>>20% Imbalance:</strong> Imbalanced - May cause pH swings and nutrient lockouts</li>
      </ul>
      <p style="margin-top: 15px;">
        <strong>Why does this matter?</strong> Charge imbalance can cause pH to drift up or down,
        which may lock out certain nutrients even if they're present in your solution.
      </p>
    </div>
  `;

  return content;
}

// ==========================================
// Two-Tank View Explanation Functions
// ==========================================

// Open PPM explanation for two-tank view
function openTwoTankPPMExplanation() {
  const modal = document.getElementById('ppm-modal');
  const modalBody = modal.querySelector('.modal-body');

  modalBody.innerHTML = generateTwoTankPPMExplanation();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

// Open Ion Balance explanation for two-tank view
function openTwoTankIonBalanceExplanation() {
  const modal = document.getElementById('ion-balance-modal');
  const modalBody = modal.querySelector('#ion-balance-modal-body');

  modalBody.innerHTML = generateTwoTankIonBalanceExplanation();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

// Helper function to convert tank fertilizers object to array with full fertilizer data
// Used by both PPM and Ion Balance explanation functions
function getTankFertilizerArray(tankFertilizers, tankLabel) {
  return Object.entries(tankFertilizers)
    .filter(([id, grams]) => grams > 0.01)
    .map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return fert ? { ...fert, grams, tank: tankLabel } : null;
    })
    .filter(f => f !== null);
}

// Generate PPM explanation content for two-tank view
function generateTwoTankPPMExplanation() {
  if (!currentTwoTankData) {
    return `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>Please run a calculation first to see the explanation.</p>
      </div>
    `;
  }

  const { tankA, tankB, volume } = currentTwoTankData;

  // Use helper function to convert fertilizer objects to arrays with full fertilizer data
  const tankAFerts = getTankFertilizerArray(tankA.fertilizers, 'A');
  const tankBFerts = getTankFertilizerArray(tankB.fertilizers, 'B');
  const allFertilizers = [...tankAFerts, ...tankBFerts];

  let content = `
    <!-- What is PPM? -->
    <div class="explanation-section">
      <h3>What is PPM?</h3>
      <p>
        <strong>PPM stands for "Parts Per Million"</strong> - it's a way to measure very small concentrations.
        Think of it like this: <span class="highlight">1 PPM = 1 milligram per liter (mg/L)</span>.
      </p>
      <p>
        For example, 100 PPM of Nitrogen means there are 100 milligrams of nitrogen in every liter of water.
      </p>
    </div>

    <!-- The Basic Formula -->
    <div class="explanation-section">
      <h3>The Basic Formula</h3>
      <div class="formula-box">
        <div class="formula">PPM = (grams × 1000 × percentage) ÷ liters</div>
        <div class="description">This tells us the concentration of nutrients in your solution</div>
      </div>
      <p><strong>Where:</strong></p>
      <ul style="line-height: 1.8;">
        <li><strong>grams</strong> = Amount of fertilizer you're adding</li>
        <li><strong>1000</strong> = Converts grams to milligrams (mg)</li>
        <li><strong>percentage</strong> = The nutrient content in the fertilizer (÷ 100)</li>
        <li><strong>liters</strong> = Volume of water in your solution</li>
      </ul>
    </div>

    <!-- Two-Tank Note -->
    <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
      <h3 style="color: #17a2b8;">Two-Tank System</h3>
      <p><strong>Solution Volume:</strong> ${volume} liters per tank</p>
      <p><strong>Tank A Fertilizers:</strong> ${tankAFerts.length}</p>
      <p><strong>Tank B Fertilizers:</strong> ${tankBFerts.length}</p>
      <p style="margin-top: 10px;">
        <strong>Important:</strong> Each tank is prepared separately with ${volume}L of water.
        When mixed at equal rates, the PPM values from both tanks combine to give your final solution concentration.
      </p>
    </div>
  `;

  if (allFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Fertilizers in Formula</h3>
        <p>The calculation did not produce a valid formula.</p>
      </div>
    `;
  } else {
    // Calculate contributions from each fertilizer
    const nutrientContributions = {};

    content += `
      <div class="explanation-section">
        <h3>Step-by-Step Breakdown</h3>
        <p>Here's exactly how each fertilizer contributes to the PPM values:</p>
    `;

    allFertilizers.forEach((fert, index) => {
      const tankLabel = fert.tank === 'A' ?
        '<span style="background: #c8e6c9; color: #2e7d32; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;">Tank A</span>' :
        '<span style="background: #bbdefb; color: #1565c0; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;">Tank B</span>';

      content += `
        <div class="step">
          <h4 style="margin-top: 0; color: #007bff;">
            <span class="step-number">${index + 1}</span>
            ${fert.name}
            ${tankLabel}
          </h4>
          <p style="margin: 10px 0 10px 38px;"><strong>Amount:</strong> ${fert.grams.toFixed(2)} grams</p>
          <div style="margin-left: 38px;">
            <table class="conversion-table" style="font-size: 0.9em;">
              <thead>
                <tr>
                  <th>Nutrient</th>
                  <th>% in Fertilizer</th>
                  <th>Calculation</th>
                  <th>PPM</th>
                </tr>
              </thead>
              <tbody>
      `;

      Object.entries(fert.pct).forEach(([nutrient, percentage]) => {
        const ppm = (fert.grams * 1000 * (percentage / 100)) / volume;
        const calculation = `(${fert.grams.toFixed(2)} × 1000 × ${(percentage / 100).toFixed(4)}) ÷ ${volume}`;

        // Track contributions for summary
        if (!nutrientContributions[nutrient]) {
          nutrientContributions[nutrient] = { tankA: [], tankB: [] };
        }
        nutrientContributions[nutrient][fert.tank === 'A' ? 'tankA' : 'tankB'].push({
          fertilizer: fert.name,
          ppm: ppm,
          percentage: percentage
        });

        content += `
          <tr>
            <td data-label="Nutrient"><strong>${nutrient}</strong></td>
            <td data-label="% in Fertilizer">${percentage}%</td>
            <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">${calculation}</td>
            <td data-label="PPM"><strong>${ppm.toFixed(2)} PPM</strong></td>
          </tr>
        `;
      });

      content += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    });

    content += `</div>`;

    // Summary table showing totals by tank
    content += `
      <div class="explanation-section">
        <h3>Nutrient Totals by Tank</h3>
        <p>When nutrients come from multiple fertilizers, we add them together:</p>
        <table class="conversion-table">
          <thead>
            <tr>
              <th>Nutrient</th>
              <th>Tank A PPM</th>
              <th>Tank B PPM</th>
              <th>Combined PPM</th>
            </tr>
          </thead>
          <tbody>
    `;

    Object.entries(nutrientContributions).forEach(([nutrient, sources]) => {
      const tankATotal = sources.tankA.reduce((sum, s) => sum + s.ppm, 0);
      const tankBTotal = sources.tankB.reduce((sum, s) => sum + s.ppm, 0);
      const combined = tankATotal + tankBTotal;

      content += `
        <tr>
          <td data-label="Nutrient"><strong>${nutrient}</strong></td>
          <td data-label="Tank A PPM" style="color: #2e7d32;">${tankATotal.toFixed(2)}</td>
          <td data-label="Tank B PPM" style="color: #1565c0;">${tankBTotal.toFixed(2)}</td>
          <td data-label="Combined PPM"><strong>${combined.toFixed(2)} PPM</strong></td>
        </tr>
      `;
    });

    content += `
          </tbody>
        </table>
      </div>
    `;
  }

  // Oxide conversions info
  content += `
    <div class="explanation-section">
      <h3>Understanding Oxide Conversions</h3>
      <p>
        Many fertilizers list nutrients in their <strong>oxide form</strong> (like P₂O₅ for phosphorus or K₂O for potassium),
        but plants actually use the <strong>elemental form</strong>. The calculator handles this automatically!
      </p>
      <table class="conversion-table">
        <thead>
          <tr>
            <th>Oxide Form</th>
            <th>Elemental Form</th>
            <th>Conversion</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>P₂O₅</td>
            <td>P</td>
            <td>× 0.436</td>
          </tr>
          <tr>
            <td>K₂O</td>
            <td>K</td>
            <td>× 0.830</td>
          </tr>
        </tbody>
      </table>
    </div>
  `;

  return content;
}

// Generate Ion Balance explanation content for two-tank view
function generateTwoTankIonBalanceExplanation() {
  if (!currentTwoTankData) {
    return `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>Please run a calculation first to see the explanation.</p>
      </div>
    `;
  }

  const { tankA, tankB, volume } = currentTwoTankData;

  // Combine fertilizers from both tanks using the helper function
  const allFertilizers = [
    ...getTankFertilizerArray(tankA.fertilizers, 'A'),
    ...getTankFertilizerArray(tankB.fertilizers, 'B')
  ];

  let content = `
    <!-- What is Ion Balance? -->
    <div class="explanation-section">
      <h3>What is Ion Balance?</h3>
      <p>
        When fertilizers dissolve in water, they break apart into <strong>charged particles called ions</strong>:
      </p>
      <ul style="line-height: 1.8;">
        <li><strong>Cations (+)</strong> - Positively charged ions like K⁺, Ca²⁺, Mg²⁺, NH₄⁺</li>
        <li><strong>Anions (-)</strong> - Negatively charged ions like NO₃⁻, SO₄²⁻, H₂PO₄⁻</li>
      </ul>
      <p>
        For a <span class="highlight">healthy nutrient solution</span>, the total positive charges should roughly equal the total negative charges.
        This keeps the pH stable and prevents nutrient lockout.
      </p>
    </div>

    <!-- What is meq/L? -->
    <div class="explanation-section">
      <h3>Understanding meq/L (Milliequivalents per Liter)</h3>
      <p>
        <strong>meq/L</strong> is a unit that measures the <strong>electrical charge</strong> of ions in solution, not their weight.
      </p>
      <p>
        Think of it like this: A calcium ion (Ca²⁺) has twice the charge of a potassium ion (K⁺), even if they weigh the same.
        meq/L accounts for this difference in charge.
      </p>
      <div class="formula-box">
        <div class="formula">meq/L = (grams ÷ molar mass) × ion count × charge × 1000 ÷ liters</div>
        <div class="description">This tells us the electrical charge contribution of each ion</div>
      </div>
      <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #6c757d;">
        <p style="margin: 0; font-size: 0.95em; line-height: 1.6;">
          <strong>Important Notes:</strong>
        </p>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; line-height: 1.8; font-size: 0.9em;">
          <li><strong>Hydration water</strong> (e.g., ·7H₂O, ·4H₂O) adds to molar mass but NOT to charge</li>
          <li><strong>Urea</strong> doesn't form charged ions, so it's excluded from ion balance</li>
        </ul>
      </div>
    </div>

    <!-- Two-Tank Note -->
    <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
      <h3 style="color: #17a2b8;">Two-Tank System Ion Balance</h3>
      <p><strong>Solution Volume:</strong> ${volume} liters per tank</p>
      <p style="margin-top: 10px;">
        <strong>Important:</strong> Each tank has its own ion balance. When mixed at equal rates,
        the ion concentrations combine. The individual tank ion balances shown below help you understand
        each tank's chemistry independently.
      </p>
    </div>
  `;

  if (allFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Fertilizers in Formula</h3>
        <p>The calculation did not produce a valid formula.</p>
      </div>
    `;
  } else {
    // Calculate ion balance for each tank
    const tankResults = { A: { cations: 0, anions: 0, ions: {}, breakdown: [] }, B: { cations: 0, anions: 0, ions: {}, breakdown: [] } };

    allFertilizers.forEach(fert => {
      const ionData = ION_DATA[fert.id];
      if (!ionData) return;

      const tankKey = fert.tank;
      const moles = fert.grams / ionData.molarMass;
      const fertIons = [];

      ionData.ions.forEach(ionInfo => {
        const meq = moles * ionInfo.count * ionInfo.charge * 1000;
        const meqPerLiter = meq / volume;

        fertIons.push({
          ...ionInfo,
          meq: meqPerLiter,
          calculation: { moles, meq, meqPerLiter }
        });

        if (!tankResults[tankKey].ions[ionInfo.ion]) {
          tankResults[tankKey].ions[ionInfo.ion] = { meq: 0, type: ionInfo.type };
        }
        tankResults[tankKey].ions[ionInfo.ion].meq += meqPerLiter;

        if (ionInfo.type === 'cation') {
          tankResults[tankKey].cations += meqPerLiter;
        } else {
          tankResults[tankKey].anions += meqPerLiter;
        }
      });

      tankResults[tankKey].breakdown.push({
        fert: fert,
        ionData: ionData,
        moles: moles,
        ions: fertIons
      });
    });

    // Show breakdown for each tank
    ['A', 'B'].forEach(tankKey => {
      const tank = tankResults[tankKey];
      const tankColor = tankKey === 'A' ? '#2e7d32' : '#1565c0';
      const tankBg = tankKey === 'A' ? '#c8e6c9' : '#bbdefb';

      if (tank.breakdown.length === 0) return;

      const average = (tank.cations + tank.anions) / 2;
      const imbalance = average > 0 ? Math.abs(tank.cations - tank.anions) / average * 100 : 0;

      let statusColor = '#28a745';
      let statusText = 'Balanced';
      if (imbalance > 20) {
        statusColor = '#dc3545';
        statusText = 'Imbalanced';
      } else if (imbalance > 10) {
        statusColor = '#ffc107';
        statusText = 'Caution';
      }

      content += `
        <div class="explanation-section" style="background: ${tankBg}40; border-left-color: ${tankColor};">
          <h3 style="color: ${tankColor};">Tank ${tankKey} Ion Calculations</h3>
      `;

      tank.breakdown.forEach((item, index) => {
        const formulaDisplay = item.ionData.formula ?
          `<span style="background: #e8f4f8; padding: 4px 8px; border-radius: 4px; font-family: monospace; margin-left: 10px; font-size: 0.9em;">${item.ionData.formula}</span>` :
          '';

        content += `
          <div class="step">
            <h4 style="margin-top: 0; color: #007bff;">
              <span class="step-number">${index + 1}</span>
              ${item.fert.name}
              ${formulaDisplay}
            </h4>
            <p style="margin: 10px 0 10px 38px;">
              <strong>Amount:</strong> ${item.fert.grams.toFixed(2)} grams<br>
              <strong>Molar Mass:</strong> ${item.ionData.molarMass} g/mol<br>
              <strong>Moles:</strong> ${item.fert.grams.toFixed(2)} ÷ ${item.ionData.molarMass} = <strong>${item.moles.toFixed(4)} mol</strong>
            </p>
            <div style="margin-left: 38px;">
              <table class="conversion-table" style="font-size: 0.9em;">
                <thead>
                  <tr>
                    <th>Ion</th>
                    <th>Type</th>
                    <th>Calculation</th>
                    <th>meq/L</th>
                  </tr>
                </thead>
                <tbody>
        `;

        item.ions.forEach(ionInfo => {
          const typeColor = ionInfo.type === 'cation' ? '#28a745' : '#dc3545';
          const typeSymbol = ionInfo.type === 'cation' ? '+' : '-';
          content += `
            <tr>
              <td data-label="Ion"><strong>${ionInfo.ion}</strong></td>
              <td data-label="Type" style="color: ${typeColor};">${ionInfo.type} (${typeSymbol})</td>
              <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">
                ${item.moles.toFixed(4)} × ${ionInfo.count} × ${ionInfo.charge} × 1000 ÷ ${volume}
              </td>
              <td data-label="meq/L"><strong>${ionInfo.meq.toFixed(2)}</strong></td>
            </tr>
          `;
        });

        content += `
                </tbody>
              </table>
            </div>
          </div>
        `;
      });

      // Tank summary
      content += `
          <div style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px; border: 2px solid ${statusColor};">
            <h4 style="margin-top: 0;">Tank ${tankKey} Summary</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">
              <div>
                <div style="font-size: 0.85em; color: #666;">Cations</div>
                <div style="font-size: 1.3em; font-weight: bold;">${tank.cations.toFixed(2)} meq/L</div>
              </div>
              <div>
                <div style="font-size: 0.85em; color: #666;">Anions</div>
                <div style="font-size: 1.3em; font-weight: bold;">${tank.anions.toFixed(2)} meq/L</div>
              </div>
              <div>
                <div style="font-size: 0.85em; color: #666;">Imbalance</div>
                <div style="font-size: 1.3em; font-weight: bold; color: ${statusColor};">${imbalance.toFixed(1)}% ${statusText}</div>
              </div>
            </div>
          </div>
        </div>
      `;
    });

    // Combined totals
    const combinedCations = tankResults.A.cations + tankResults.B.cations;
    const combinedAnions = tankResults.A.anions + tankResults.B.anions;
    const combinedAverage = (combinedCations + combinedAnions) / 2;
    const combinedImbalance = combinedAverage > 0 ? Math.abs(combinedCations - combinedAnions) / combinedAverage * 100 : 0;

    let combinedStatusColor = '#28a745';
    let combinedStatusText = 'Balanced';
    if (combinedImbalance > 20) {
      combinedStatusColor = '#dc3545';
      combinedStatusText = 'Imbalanced';
    } else if (combinedImbalance > 10) {
      combinedStatusColor = '#ffc107';
      combinedStatusText = 'Caution';
    }

    content += `
      <div class="explanation-section" style="background: ${combinedStatusColor}15; border-left-color: ${combinedStatusColor};">
        <h3 style="color: ${combinedStatusColor};">Combined Solution Results</h3>
        <p>When Tank A and Tank B are mixed at equal rates:</p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Cations (+)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${combinedCations.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total Anions (-)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${combinedAnions.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
        </div>

        <div style="background: white; padding: 20px; border-radius: 8px; text-align: center; border: 2px solid ${combinedStatusColor};">
          <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Combined Imbalance</div>
          <div style="font-size: 2em; font-weight: bold; color: ${combinedStatusColor};">${combinedImbalance.toFixed(1)}%</div>
          <div style="font-size: 1em; color: ${combinedStatusColor}; margin-top: 5px;">${combinedStatusText}</div>
        </div>
      </div>
    `;
  }

  // Interpretation guide
  content += `
    <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
      <h3 style="color: #28a745;">Interpreting Your Results</h3>
      <ul style="line-height: 1.8;">
        <li><strong>≤10% Imbalance:</strong> Balanced - Excellent! Your solution has good charge balance</li>
        <li><strong>10-20% Imbalance:</strong> Caution - Acceptable, but monitor pH closely</li>
        <li><strong>>20% Imbalance:</strong> Imbalanced - May cause pH swings and nutrient lockouts</li>
      </ul>
      <p style="margin-top: 15px;">
        <strong>Why does this matter?</strong> Charge imbalance can cause pH to drift up or down,
        which may lock out certain nutrients even if they're present in your solution.
      </p>
    </div>
  `;

  return content;
}

// Formula Builder (PPM to Grams) explanation functions
function openFormulaIonBalanceExplanation() {
  const modal = document.getElementById('ion-balance-modal');
  const modalBody = modal.querySelector('#ion-balance-modal-body');

  modalBody.innerHTML = generateFormulaIonBalanceExplanation();

  modal.classList.add('active');
  document.body.style.overflow = 'hidden';
}

// Generate Ion Balance explanation content for formula builder
function generateFormulaIonBalanceExplanation() {
  if (!lastFormulaCalculation) {
    return `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Calculation Yet</h3>
        <p>Please run a calculation first to see the explanation.</p>
      </div>
    `;
  }

  const { result, volume } = lastFormulaCalculation;

  // Get active fertilizers from result
  const activeFertilizers = Object.entries(result.formula)
    .filter(([fertId, grams]) => grams > 0.01)
    .map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { ...fert, grams };
    });

  let content = `
    <!-- What is Ion Balance? -->
    <div class="explanation-section">
      <h3>What is Ion Balance?</h3>
      <p>
        When fertilizers dissolve in water, they break apart into <strong>charged particles called ions</strong>:
      </p>
      <ul style="line-height: 1.8;">
        <li><strong>Cations (+)</strong> - Positively charged ions like K⁺, Ca²⁺, Mg²⁺, NH₄⁺</li>
        <li><strong>Anions (-)</strong> - Negatively charged ions like NO₃⁻, SO₄²⁻, H₂PO₄⁻</li>
      </ul>
      <p>
        For a <span class="highlight">healthy nutrient solution</span>, the total positive charges should roughly equal the total negative charges.
        This keeps the pH stable and prevents nutrient lockout.
      </p>
    </div>

    <!-- What is meq/L? -->
    <div class="explanation-section">
      <h3>Understanding meq/L (Milliequivalents per Liter)</h3>
      <p>
        <strong>meq/L</strong> is a unit that measures the <strong>electrical charge</strong> of ions in solution, not their weight.
      </p>
      <p>
        Think of it like this: A calcium ion (Ca²⁺) has twice the charge of a potassium ion (K⁺), even if they weigh the same.
        meq/L accounts for this difference in charge.
      </p>
      <div class="formula-box">
        <div class="formula">meq/L = (grams ÷ molar mass) × ion count × charge × 1000 ÷ liters</div>
        <div class="description">This tells us the electrical charge contribution of each ion</div>
      </div>
      <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #6c757d;">
        <p style="margin: 0; font-size: 0.95em; line-height: 1.6;">
          <strong>Important Notes:</strong>
        </p>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; line-height: 1.8; font-size: 0.9em;">
          <li><strong>Hydration water</strong> (e.g., ·7H₂O, ·4H₂O) adds to molar mass but NOT to charge</li>
          <li><strong>Urea</strong> doesn't form charged ions, so it's excluded from ion balance</li>
        </ul>
      </div>
    </div>
  `;

  if (activeFertilizers.length === 0) {
    content += `
      <div class="explanation-section" style="background: #fff3cd; border-left-color: #ffc107;">
        <h3 style="color: #856404;">No Fertilizers in Formula</h3>
        <p>The calculation did not produce a valid formula. Try adjusting your target values or selecting different fertilizers.</p>
      </div>
    `;
  } else {
    // Calculate ion balance
    let totalCations = 0;
    let totalAnions = 0;
    const ionDetails = {};
    const fertilizerBreakdown = [];

    activeFertilizers.forEach(fert => {
      const ionData = ION_DATA[fert.id];

      if (!ionData) {
        return;
      }

      const moles = fert.grams / ionData.molarMass;
      const fertIons = [];

      ionData.ions.forEach(ionInfo => {
        const meq = moles * ionInfo.count * ionInfo.charge * 1000;
        const meqPerLiter = meq / volume;

        fertIons.push({
          ...ionInfo,
          meq: meqPerLiter
        });

        if (!ionDetails[ionInfo.ion]) {
          ionDetails[ionInfo.ion] = { meq: 0, type: ionInfo.type };
        }
        ionDetails[ionInfo.ion].meq += meqPerLiter;

        if (ionInfo.type === 'cation') {
          totalCations += meqPerLiter;
        } else {
          totalAnions += meqPerLiter;
        }
      });

      fertilizerBreakdown.push({
        fert: fert,
        ionData: ionData,
        moles: moles,
        ions: fertIons
      });
    });

    const average = (totalCations + totalAnions) / 2;
    const imbalance = average > 0 ? Math.abs(totalCations - totalAnions) / average * 100 : 0;

    content += `
      <div class="explanation-section" style="background: #e8f4f8; border-left-color: #17a2b8;">
        <h3 style="color: #17a2b8;">Your Current Solution</h3>
        <p><strong>Solution Volume:</strong> ${volume} liters</p>
        <p><strong>Fertilizers Used:</strong> ${activeFertilizers.length}</p>
      </div>

      <div class="explanation-section">
        <h3>Step-by-Step Ion Calculation</h3>
        <p>Here's how each fertilizer contributes ions to your solution:</p>
    `;

    fertilizerBreakdown.forEach((item, index) => {
      const formulaDisplay = item.ionData.formula ?
        `<span style="background: #e8f4f8; padding: 4px 8px; border-radius: 4px; font-family: monospace; margin-left: 10px; font-size: 0.9em;">${item.ionData.formula}</span>` :
        '';

      content += `
        <div class="step">
          <h4 style="margin-top: 0; color: #007bff;">
            <span class="step-number">${index + 1}</span>
            ${item.fert.name}
            ${formulaDisplay}
          </h4>
          <p style="margin: 10px 0 10px 38px;">
            <strong>Amount:</strong> ${item.fert.grams.toFixed(2)} grams<br>
            <strong>Molar Mass:</strong> ${item.ionData.molarMass} g/mol<br>
            <strong>Moles:</strong> ${item.fert.grams.toFixed(2)} ÷ ${item.ionData.molarMass} = <strong>${item.moles.toFixed(4)} mol</strong>
          </p>
          <div style="margin-left: 38px;">
            <table class="conversion-table" style="font-size: 0.9em;">
              <thead>
                <tr><th>Ion</th><th>Type</th><th>Calculation</th><th>meq/L</th></tr>
              </thead>
              <tbody>
      `;

      item.ions.forEach(ionInfo => {
        const typeColor = ionInfo.type === 'cation' ? '#28a745' : '#dc3545';
        content += `
          <tr>
            <td data-label="Ion"><strong>${ionInfo.ion}</strong></td>
            <td data-label="Type" style="color: ${typeColor};">${ionInfo.type}</td>
            <td data-label="Calculation" style="font-family: monospace; font-size: 0.85em;">
              ${item.moles.toFixed(4)} × ${ionInfo.count} × ${ionInfo.charge} × 1000 ÷ ${volume}
            </td>
            <td data-label="meq/L"><strong>${ionInfo.meq.toFixed(2)}</strong></td>
          </tr>
        `;
      });

      content += `</tbody></table></div></div>`;
    });

    content += `</div>`;

    // Results summary
    let statusColor = '#28a745';
    let statusText = 'Balanced';
    if (imbalance > 20) {
      statusColor = '#dc3545';
      statusText = 'Imbalanced';
    } else if (imbalance > 10) {
      statusColor = '#ffc107';
      statusText = 'Caution';
    }

    content += `
      <div class="explanation-section" style="background: ${statusColor}15; border-left-color: ${statusColor};">
        <h3 style="color: ${statusColor};">Final Results</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666;">Total Cations (+)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${totalCations.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
          <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #666;">Total Anions (-)</div>
            <div style="font-size: 1.8em; font-weight: bold; color: #007bff;">${totalAnions.toFixed(2)}</div>
            <div style="font-size: 0.9em; color: #666;">meq/L</div>
          </div>
        </div>
        <div style="background: white; padding: 20px; border-radius: 8px; text-align: center; border: 2px solid ${statusColor};">
          <div style="font-size: 0.9em; color: #666;">Imbalance</div>
          <div style="font-size: 2em; font-weight: bold; color: ${statusColor};">${imbalance.toFixed(1)}%</div>
          <div style="font-size: 1em; color: ${statusColor};">${statusText}</div>
        </div>
      </div>
    `;
  }

  content += `
    <div class="explanation-section" style="background: #d4edda; border-left-color: #28a745;">
      <h3 style="color: #28a745;">Interpreting Your Results</h3>
      <ul style="line-height: 1.8;">
        <li><strong>≤10% Imbalance:</strong> Balanced - Excellent!</li>
        <li><strong>10-20% Imbalance:</strong> Caution - Monitor pH closely</li>
        <li><strong>>20% Imbalance:</strong> Imbalanced - May cause pH swings</li>
      </ul>
    </div>
  `;

  return content;
}

// ==========================================
// Copy Results Functions (WhatsApp Friendly)
// ==========================================

// Helper function to copy text to clipboard and show feedback
async function copyToClipboard(text, button) {
  try {
    await navigator.clipboard.writeText(text);

    // Show feedback
    const originalText = button.innerHTML;
    button.classList.add('copied');
    button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
      Copied!
    `;

    setTimeout(() => {
      button.classList.remove('copied');
      button.innerHTML = originalText;
    }, 2000);
  } catch (err) {
    console.error('Failed to copy:', err);
    alert('Failed to copy to clipboard. Please try again.');
  }
}

// Copy Grams to PPM results (Tab 1)
function copyGramsToPPMResults() {
  if (!lastGramsToPPMCalculation) {
    alert('Please run a calculation first.');
    return;
  }

  const { activeFertilizers, volume, results, ecData, ionBalance, ratios } = lastGramsToPPMCalculation;

  let text = `*🌱 Fertilizer Calculator Results*\n`;
  text += `━━━━━━━━━━━━━━━━━━━━━\n\n`;

  // Fertilizers used
  text += `*📦 Fertilizers Used* (${volume}L solution)\n`;
  activeFertilizers.forEach(fert => {
    text += `• ${fert.name}: *${fert.grams.toFixed(2)}g*\n`;
  });
  text += `\n`;

  // PPM Results
  text += `*📊 Nutrient Concentrations (PPM)*\n`;

  const displayOrder = [
    { key: 'N_total', label: 'Total N' },
    { key: 'N_NO3', label: 'NO₃-N' },
    { key: 'N_NH4', label: 'NH₄-N' },
    { key: 'P', label: 'P' },
    { key: 'K', label: 'K' },
    { key: 'Ca', label: 'Ca' },
    { key: 'Mg', label: 'Mg' },
    { key: 'S', label: 'S' },
    { key: 'Fe', label: 'Fe' },
    { key: 'Mn', label: 'Mn' },
    { key: 'Zn', label: 'Zn' },
    { key: 'B', label: 'B' },
    { key: 'Cu', label: 'Cu' },
    { key: 'Mo', label: 'Mo' }
  ];

  displayOrder.forEach(item => {
    if (results[item.key] !== undefined && results[item.key] > 0.01) {
      text += `• ${item.label}: *${results[item.key].toFixed(2)} ppm*\n`;
    }
  });
  text += `\n`;

  // Ion Balance
  if (ionBalance) {
    text += `*⚖️ Ion Balance*\n`;
    text += `• Cations: *${ionBalance.totalCations.toFixed(2)} meq/L*\n`;
    text += `• Anions: *${ionBalance.totalAnions.toFixed(2)} meq/L*\n`;
    text += `• Imbalance: *${ionBalance.imbalance.toFixed(1)}%* (${ionBalance.statusText})\n`;
    text += `\n`;
  }

  // EC Prediction
  if (ecData && ecData.ec) {
    text += `*⚡ EC Prediction*\n`;
    text += `• EC: *${ecData.ec.toFixed(2)} mS/cm*\n`;
    text += `\n`;
  }

  // Key Ratios
  if (ratios && ratios.length > 0) {
    text += `*📐 Key Ratios*\n`;
    ratios.slice(0, 4).forEach(ratio => {
      text += `• ${ratio.name}: *${ratio.ratio}*\n`;
    });
    text += `\n`;
  }

  text += `━━━━━━━━━━━━━━━━━━━━━\n`;
  text += `_Generated by https://umangbhatt.in/fertilizer-calculator/_`;

  const button = event.target.closest('.copy-btn');
  copyToClipboard(text, button);
}

// Copy PPM to Grams results (Tab 2 - Formula Builder)
function copyPPMToGramsResults() {
  if (!lastFormulaCalculation) {
    alert('Please run a calculation first.');
    return;
  }

  const { result, targets, volume, mode } = lastFormulaCalculation;

  let text = `*🌱 Formula Builder Results*\n`;
  text += `━━━━━━━━━━━━━━━━━━━━━\n\n`;

  // Target values
  text += `*🎯 Target PPM Values*\n`;
  const targetLabels = mode === 'elemental'
    ? { N: 'N', P: 'P', K: 'K', Ca: 'Ca', Mg: 'Mg', S: 'S' }
    : { N: 'N', P: 'P₂O₅', K: 'K₂O', Ca: 'Ca', Mg: 'Mg', S: 'S' };

  Object.entries(targets).forEach(([key, value]) => {
    if (value > 0) {
      const label = targetLabels[key] || key;
      text += `• ${label}: *${value} ppm*\n`;
    }
  });
  text += `\n`;

  // Fertilizers to add
  text += `*📦 Fertilizers to Add* (${volume}L)\n`;
  const activeFertilizers = Object.entries(result.formula)
    .filter(([fertId, grams]) => grams > 0.01)
    .map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { name: fert ? fert.name : fertId, grams };
    });

  if (activeFertilizers.length === 0) {
    text += `_No suitable formula found_\n`;
  } else {
    activeFertilizers.forEach(fert => {
      text += `• ${fert.name}: *${fert.grams.toFixed(2)}g*\n`;
    });
  }
  text += `\n`;

  // Achieved values
  text += `*✅ Achieved PPM*\n`;
  const achievedOrder = mode === 'elemental'
    ? [
        { key: 'N_total', label: 'N' },
        { key: 'P', label: 'P' },
        { key: 'K', label: 'K' },
        { key: 'Ca', label: 'Ca' },
        { key: 'Mg', label: 'Mg' },
        { key: 'S', label: 'S' }
      ]
    : [
        { key: 'N_total', label: 'N' },
        { key: 'P2O5', label: 'P₂O₅' },
        { key: 'K2O', label: 'K₂O' },
        { key: 'Ca', label: 'Ca' },
        { key: 'Mg', label: 'Mg' },
        { key: 'S', label: 'S' }
      ];

  achievedOrder.forEach(item => {
    const value = result.achieved[item.key];
    if (value !== undefined && value > 0.01) {
      text += `• ${item.label}: *${value.toFixed(1)} ppm*\n`;
    }
  });
  text += `\n`;

  // Ion Balance
  const ionBalance = calculateIonBalanceForFormula(
    Object.entries(result.formula).map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { ...fert, grams };
    }),
    volume
  );

  if (ionBalance) {
    text += `*⚖️ Ion Balance*\n`;
    text += `• Cations: *${ionBalance.totalCations.toFixed(2)} meq/L*\n`;
    text += `• Anions: *${ionBalance.totalAnions.toFixed(2)} meq/L*\n`;
    text += `• Imbalance: *${ionBalance.imbalance.toFixed(1)}%* (${ionBalance.statusText})\n`;
    text += `\n`;
  }

  text += `━━━━━━━━━━━━━━━━━━━━━\n`;
  text += `_Generated by https://umangbhatt.in/fertilizer-calculator/_`;

  const button = event.target.closest('.copy-btn');
  copyToClipboard(text, button);
}

// Copy NPK Ratio to Grams results (Tab 3 - Reverse Calculator)
function copyNPKRatioResults() {
  if (!lastReverseCalculation) {
    alert('Please run a calculation first.');
    return;
  }

  const { result, targets, volume } = lastReverseCalculation;
  const calculationMode = document.getElementById('reverse-calculation-mode').value;

  let text = `*🌱 NPK Ratio Calculator Results*\n`;
  text += `━━━━━━━━━━━━━━━━━━━━━\n\n`;

  // Target ratios
  text += `*🎯 Target Ratios*\n`;
  const targetLabels = calculationMode === 'elemental'
    ? { N: 'N', P: 'P', K: 'K', Ca: 'Ca', Mg: 'Mg', S: 'S' }
    : { N: 'N', P: 'P₂O₅', K: 'K₂O', Ca: 'Ca', Mg: 'Mg', S: 'S' };

  const targetParts = [];
  ['N', 'P', 'K', 'Ca', 'Mg', 'S'].forEach(key => {
    if (targets[key] > 0) {
      const label = targetLabels[key] || key;
      targetParts.push(`${label}:${targets[key]}`);
    }
  });
  text += `• Ratio: *${targetParts.join(' : ')}*\n\n`;

  // Fertilizers to add
  text += `*📦 Fertilizers to Add* (${volume}L)\n`;
  const activeFertilizers = Object.entries(result.formula)
    .filter(([fertId, grams]) => grams > 0.01)
    .map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { name: fert ? fert.name : fertId, grams };
    });

  if (activeFertilizers.length === 0) {
    text += `_No suitable formula found_\n`;
  } else {
    activeFertilizers.forEach(fert => {
      text += `• ${fert.name}: *${fert.grams.toFixed(2)}g*\n`;
    });
  }
  text += `\n`;

  // Achieved PPM values
  text += `*✅ Achieved PPM*\n`;
  const achievedOrder = calculationMode === 'elemental'
    ? [
        { key: 'N_total', label: 'N' },
        { key: 'P', label: 'P' },
        { key: 'K', label: 'K' },
        { key: 'Ca', label: 'Ca' },
        { key: 'Mg', label: 'Mg' },
        { key: 'S', label: 'S' }
      ]
    : [
        { key: 'N_total', label: 'N' },
        { key: 'P2O5', label: 'P₂O₅' },
        { key: 'K2O', label: 'K₂O' },
        { key: 'Ca', label: 'Ca' },
        { key: 'Mg', label: 'Mg' },
        { key: 'S', label: 'S' }
      ];

  achievedOrder.forEach(item => {
    const value = result.achieved[item.key];
    if (value !== undefined && value > 0.01) {
      text += `• ${item.label}: *${value.toFixed(1)} ppm*\n`;
    }
  });
  text += `\n`;

  // Nitrogen breakdown
  if (result.achieved.N_NO3 > 0 || result.achieved.N_NH4 > 0) {
    text += `*🧪 Nitrogen Forms*\n`;
    text += `• NO₃-N: *${result.achieved.N_NO3.toFixed(1)} ppm*\n`;
    text += `• NH₄-N: *${result.achieved.N_NH4.toFixed(1)} ppm*\n`;
    const nh4Percent = result.achieved.N_total > 0 ? (result.achieved.N_NH4 / result.achieved.N_total * 100) : 0;
    text += `• NH₄ ratio: *${nh4Percent.toFixed(0)}%*\n`;
    text += `\n`;
  }

  // Ion Balance
  const ionBalance = calculateIonBalanceForFormula(
    Object.entries(result.formula).map(([fertId, grams]) => {
      const fert = FERTILIZERS.find(f => f.id === fertId);
      return { ...fert, grams };
    }),
    volume
  );

  if (ionBalance) {
    text += `*⚖️ Ion Balance*\n`;
    text += `• Cations: *${ionBalance.totalCations.toFixed(2)} meq/L*\n`;
    text += `• Anions: *${ionBalance.totalAnions.toFixed(2)} meq/L*\n`;
    text += `• Imbalance: *${ionBalance.imbalance.toFixed(1)}%* (${ionBalance.statusText})\n`;
    text += `\n`;
  }

  text += `━━━━━━━━━━━━━━━━━━━━━\n`;
  text += `_Generated by https://umangbhatt.in/fertilizer-calculator/_`;

  const button = event.target.closest('.copy-btn');
  copyToClipboard(text, button);
}

// Initialize when page loads
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</script>
